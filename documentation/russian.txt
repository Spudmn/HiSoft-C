     
     
           Несколько слов о новых  перспективах.
     
      Надеюсь, что  в  скором  времени  удасться отработать
 нормальный   алгоритм просмотра файла и ввести  режимы  прос-
 мотра всех   используемых  на  ZX-Spectrum форматов текстовых
 файлов: языков  Си,  Паскаль,  Ассемблера, редакторов TLW 2+,
 RusTas. (Разумеется у "корифеев iS-Dos" это все есть,  но ведь
 у них не допросишься.  Или введут ограничение на 8 просмотров
 а там покупай новую дискету. {* это шутка *})
     
    Я приглашаю   программистов   включиться   в   разработку
 подобного типа программ. Пускай они плодятся, как в свое время
 boot-ты.
    
 
     Ребята! На планете Spectrum обнаружен новый материк !
  
                                                           

  - Уже на следующий день,  как задышал TxtView1 в TR-DOS поя-
 вился роман "Как размножаются ежики" , статья про НЛО и сбор-
 ник анекдотиков.  Побочные дети растут энергичнее долго вына-
 шиваемого дитяти   из  за  которого  все и начиналось.  Итак,
 появилась новая сфера развлечений - литература на Spectrum.
  - На  этой  дискете есть TxtView и я с легкостью обратился к
 вам и рассказал о своей программе.  Теперь каждый может легко
 донести до  другого слово свое.  Надеюсь оно будет добрым.  А
 каждая программа получит свое описание.  Быть может даже ста-
 нет неприличным выпускать программу без описания?
   - По классификации ИНФОРКОМа эта дискета относится к самому
 простому классу  обучающих программ - информационным програм-
 мам. Может быть и Вам уже давно хочется поделиться опытом?
     
     
    27.11.94                 C уважением Сергей Д. Шиляев.
     
     
     
     
     
     
     
     
     
                       По нашему  опыту,   "Си"  показал  себя
                     приятным, выразительным  и разносторонним
                     языком на широком множестве разнообразных
                     программ. Его  легко выучить,   и  он  не
                     теряет своих    качеств  с  ростом  опыта
                     программиста. Мы надеемся , что эта книга
                     поможет вам хорошо его использовать.
                                       Брайен В. Керниган
                                       Деннис М. Ричи
     
     
     
     
              ОТ ИЗДАТЕЛЯ СПЕКТРУМОВСКОЙ ВЕРСИИ
     
     
     
          Книга "Язык программирования Си" написанная Деннисом
 Ричи и     Брайеном   Керниганом   наконец-то   издается  для
 пользователей ZX-Spectrum.
     Почему издатель    (одновременно    и   автор   программы
 "TxtView1") решился  на  такой  шаг?   Этому  есть  несколько
 причин:
   - Сердце мое настойчиво требовало от меня  выполнения  этой
 работы. Видимо  это  сейчас нужно.
   - Необходимо отметить,  что "Си" на  ZX-Spectrum  вовсе  не
 игрушка. Во    всяком  случае,   когда возникла необходимость
 создания програмных средств для устройства ввода  изображения
 для ZX-Spectrum,  то оказалось, что только этот язык позволил
 справиться с задачей в  наиболее  короткие  сроки  (трудность
 была в   том,  что требовалось сочетание удобного интерфейса,
 вычислительной мощности и высокой скорости работы  ).   Более
 того, по  мере дальнейшего знакомства открывались все новые и
 новые возможности и росло удивление,   почему  этот  чудесный
 язык совершенно   не  пользуется популярностью спектрумовских
 программистов. Мой  ответ на этот вопрос будет очень прост  -
 язык Си   (Hisoft)   попал  в  нашу  страну  без  описания  и
 практически без библиотек.  И это еще половина беды.  А самая
 беда в   том что в качестве учебника новичкам была предложена
 работа по "Высшему пилотажу".
    Jan Bielecki, чья книга "Один на один с языком Си"(1989г.)
 с завидным     упорством   перепечатана   в    многочисленных
 справочниках по    системным  программам  в  виде  фирменного
 описания языка, определенно гений! Мне отрадно сознавать, что
 наконец-то после нескольких лет трудов я начинаю понимать ход
 мыслей и остроумие этого автора.   И  совершенно  ясно,   что
 оставлять новичка один на один с таким описанием преступлению
 подобно.
     
   - Меня самого наставила "на путь истинный" именно та книга,
 что я   имею честь представлять теперь Вам.  Да!Да!Да!  это -
 лучшее описание самого стандарта языка  "Си"  и  одновременно
 лучший учебник.    Эта  книга ДЕЙСТВИТЕЛЬНО предназначена для
 того, чтобы  помочь  читателю  научиться  программировать  на
 языке "C".
     
     
      Я не стал адаптировать материал для ZX-Spectrum, поэтому
 в книге нет никакой отсебятины и самое главное у пользователя
 будет возможность сравнить,  как аналогичные вопросы решаются
 в других системах.  Поэтому "фирменное" описание языка Си для
 ZX-Spectrum тоже   абсолютно   необходимо   если  Ваш  подход
 серьезен.
     
     
     
      Диск спроектирован таким образом, что каждая глава книги
 содержится в отдельном файле.   Поэтому  читателю  необходимо
 найти нужный ему раздел в оглавлении а потом по номеру разде-
 ла отыскать в каталоге нужный файл.  Для просмотра текста на-
 писана специальная программа TxtView1.
 ( Возможно,  что для экономии места в каталоге на вашем диске
 эта программа переименована в "boot".  Тогда  Вы  попадете  в
 режим просмотра автоматически. )
     
      Управление в   программе   возможно   от   Kempston  или
 Interface 2    джойстиков,    курсора   а   так   же   клавиш
 "Q","A","O","P","M". Заново    перечитать  каталог по клавише
 EDIT (CapsShift+1). Закончить программу и вернуться в TR -DOS
 по команде STOP (SimbolShift+A).
    Дискета спроектирована   без   защиты   от    копирования.
 Копируйте на здоровье себе ,  всем друзьям и недругам (пускай
 добреют). Все  файлы небольшого размера и,  я  надеюсь,   Вам
 удастся их   распечатать  на  своем  принтере.  В этом случае
 пользоваться книгой будет удобнее.  "TxtView1" -  это  первая
 версия, она  может показывать тексты только в формате ZX-WORD
 ( или PC ).  Мне пришлось торопиться и, кроме скрытых ошибок,
 в программе имеются явные некрасивости. Надеюсь не все осудят
 меня слишком строго.
    
      Программа написана  на  языке  "Си"  (исключая   конечно
 драйвер экрана).  Для того, чтобы Вам было интересней жить, в
 приложении приведен исходный текст этой программы. Пожалуйста
 экспериментируйте с ним сколько хотите.  (Иногда в приложении
 Вы можете встретить  текст  другой  программы  ScrView2  т.е.
 программы для просмотра экранных файлов. Она гораздо короче и
 понятней. )   Я с удовольствием поделился бы всем ,  что имею
 наработанного, но  на диске нет больше места. Делать же пакет
 из двух дисков я не решился,  т.к.  один  из  них  все  равно
 потеряется при     перекопировании;   кроме   того   -   цена
 распространения вырастет в два раза.
     
         
  
    В приложении   содержится:
     
           - Tv.H1     - текст  программы   "TxtView1";
           - 64CHRv.l  - библиотека драйвера экрана;
           - Fman.l    - (File manager) работа с каталогом и
                         файлами;
           - trd.l     - отладочная библиотека для работы  в
                         системе TR-DOS;
           - 64.A95    - текст драйвера экрана на ассемблере;
     
     
     
  Я пользуюсь   версией   языка  Си  ,   которая  при  запуске
компилятора печатает следующую информацию:
     
         HISOFT-C Compiler V1.1B
         1991 TJU B-disk version
 
                  ( Внимание,   в  стандартно  поставляемой  с
                   языком библиотеке   stdio.l stdio.h имеются
                   ошибки, я    предпочитаю  использовать   их
                   только как справочные файлы )
                                                       
     
    Хотелось бы,   пользуясь возможностью,  выразить искреннюю
признательность лично   не  знакомому  программисту   TJU   за
прекрасно сделанную   адаптацию.  (Может быть он найдет время,
чтобы добавить в компилятор опцию "компиляция на диск",  а  не
только через   буфер  в  памяти  или  расскажет  о  внутреннем
устройстве компилятора,  способах  трансляции  в  произвольные
адреса памяти?)
     
             С уважением  и пожеланием творческих успехов всем
                     синклеристам
                                         Сергей Д. Шиляев
                    
     Адрес для писем: 160022, Вологда а/я 15. Шиляеву С.Д.
                     
     
                                                 15.11.94
     
     
     
     
     
     
                       Аннотация
    Язык "C"(произносится "си")   -  это  универсальный  язык
программирования, для     которого  характерны  экономичность
выражения, современный  поток управления и структуры  данных,
богатый набор   операторов.   Язык  "C" не является ни языком
"очень высокого   уровня",   ни  "большим"  языком,    и   не
предназначается для некоторой специальной области применения.
но отсутствие ограничений и общность языка делают  его  более
удобным и     эффективным   для  многих  задач,   чем  языки,
предположительно более мощные.
    Язык "C",   первоначально предназначавшийся для написания
операционной системы "UNIX" на ЭВМ DEC PDP-11, был разработан
и реализован   на  этой  системе Деннисом Ричи.  Операционная
система, компилятор  с языка "C" и по существу все прикладные
программы системы       "UNIX"   (включая   все   программное
обеспечение, использованное    при  подготовке  этой   книги)
написаны на   "C".   Коммерческие  компиляторы  с  языка  "C"
существуют также на некоторых других ЭВМ, включая IBM SYSTEM/
370, HONEYWELL  6000,  INTERDATA 8/32.  Язык "C",  однако, не
связан с какими-либо определенными аппаратными средствами или
системами, и    на нем легко писать программы,  которые можно
пропускать без     изменений   на   любой    ЭВМ,     имеющей
"C"-компилятор.
    Эта книга предназначена для того,  чтобы помочь  читателю
научиться программировать на языке "C".  Она содержит учебное
введение, цель   которого  -  позволить  новым  пользователям
начать программировать как можно быстрее,  отдельные главы по
всем основным особенностям языка  и  справочное  руководство.
Обучение построено в основном на чтении,  написании и разборе
примеров, а не голой формулировке правил. Примеры, приводимые
в книге,    по  большей части являются законченными реальными
программами, а  не отдельными фрагментами.  Все примеры  были
проверены непосредственно с текста книги,  где они напечатаны
в виде,  пригодном для ввода в машину.  Кроме указаний о том,
как сделать  использование языка более эффективным,  мы также
пытались, где    это  возможно,   проиллюстрировать  полезные
алгоритмы и принципы хорошего стиля и разумной разработки.
    Настоящая книга   не   является    вводным    курсом    в
программирование; она  предполагает определенное знакомство с
основными понятиями программирования такими  как  переменные,
операторы присваивания,    циклы,   функции.   Тем не менее и
новичок в   программировании  должен  оказаться  в  состоянии
читать подряд   и  освоиться с языком,  хотя при этом была бы
полезной помощь более опытного коллеги.
    По нашему   опыту   ,    "C"   показал   себя   приятным,
выразительным и разносторонним языком  на  широком  множестве
разнообразных программ.   Его легко выучить ,  и он не теряет
своих качеств с ростом опыта программиста.  Мы надеемся , что
эта книга поможет вам хорошо его использовать.
    Вдумчивая критика и предложения  многих  наших  друзей  и
коллег очень   много добавили как для самой книги,  так и для
нашего удовольствия при ее  написании.   В  частности,   Майк
Биапси, Джим  Блю,  Стью Фельдман,  Доуг Мак-Илрой, Билл Рум,
Боб Розин   и  Ларри  Рослер  тщательно  прочитали  множество
вариантов. Мы    также  обязаны  Элю Ахо,  Стиву Борну,  Дэву
Двораку, Чаку  Хэлею,  Дебби Хэлей,  Мариону  Харрису,   Рику
Холту, Стиву  Джонсону, Джону Машею, Бобу Митцу, Ральфу Мьюа,
Питеру Нельсону,  Эллиоту Пинсону,   Биллу  Плагеру,   Джерри
Спиваку, Кену    Томпсону  и  Питеру  Вейнбергеру за полезные
замечания на различных этапах и Майку Лоску и Джо  Осанна  за
неоценимую помощь при печатании книги.
                                       Брайен В. Керниган
                                       Деннис М. Ричи

 
     
     
    
     
      
                             Содержание
 
       Aннотация ........................................
 0.1.  Введение   .......................................
 1.    Учебное введение..................................
 1.1.     Hачинаем.......................................
 1.2.     Переменные и арифметика........................
 1.3.     Оператор FOR...................................
 1.4.     Символические константы........................
 1.5.     Набор полезных программ........................
 1.5.1.     Ввод и вывод символов........................
 1.5.2.     Копирование файла............................
 1.5.3.     Подсчет символов.............................
 1.5.4.     Подсчет строк................................
 1.5.5.     Подсчет слов.................................
 1.6.     Массивы........................................
 1.7.     Функции........................................
 1.8.     Аргументы - вызов по значению..................
 1.9.     Массивы символов...............................
 1.10.    Область действия: внешние переменные...........
 1.11.    Резюме.........................................
 2.    Типы, операции и выражения........................
 2.1.     Имена переменных...............................
 2.2.     Типы и размеры данных..........................
 2.3.     Константы......................................
 2.3.1.     Символьная константа.........................
 2.3.2.     Константное выражение........................
 2.3.3.     Строчная константа...........................
 2.4.     Описания.......................................
 2.5.     Арифметические операции........................
 2.6.     Операции отношения и логические операции.......
 2.7.     Преобразование типов...........................
 2.8.     Операции увеличения и уменьшения...............
 2.9.     Побитовые логические операции..................
 2.10.    Операции и выражения присваивания..............
 2.11.    Условные выражения.............................
 2.12.    Старшинство и порядок вычисления...............
 3.    Поток управления..................................
 3.1.     Операторы и блоки..............................
 3.2.     IF - ELSE......................................
 3.3.     ELSE - IF......................................
 3.4.     Переключатель..................................
 3.5.     Циклы - WHILE и FOR............................
 3.6.     Цикл DO - WHILE................................
 3.7.     Оператор BREAK.................................
 3.8.     Оператор CONTINUE..............................
 3.9.     Оператор GOTO и метки..........................
 4.    Функции и структура программ......................
 4.1.     Основные сведения..............................
 4.2.     Функции, возвращающие нецелые значения.........
 4.3.     Еще об аргументах функций......................
 4.4.     Внешние переменные.............................
 4.5.     Правила, определяющие область действия.........
 4.5.1.     Область действия.............................
 4.6.     Статические переменные.........................
 4.7.     Регистровые переменные.........................
 4.8.     Блочная структура..............................
 4.9.     Инициализация..................................
 4.10.    Рекурсия.......................................
 4.11.    Препроцессор языка "C".........................
 4.11.1.    Включение файлов.............................
 4.11.2.    Mакроподстановка.............................
 5.       Указатели и массивы............................
 5.1.     Указатели и адреса.............................
 5.2.     Указатели и аргументы функций..................
 5.3.     указатели и массивы............................
 5.4.     Адресная арифметика............................
 5.5.     указатели символов и функции...................
 5.6.     Указатели - не целые...........................
 5.7.     Многомерные массивы............................
 5.8.     Массивы указателей; указатели указателей.......
 5.9.     Инициализация массивов указателей..............
 5.10.    Указатели и многомерные массивы................
 5.11.    Командная строка аргументов....................
 5.12.    Указатели на функции...........................
 6.    Структуры.........................................
 6.1.     Основные сведения..............................
 6.2.     Структуры и функции............................
 6.3.     Массивы сруктур................................
 6.4.     Указатели на структуры.........................
 6.5.     Структуры, ссылающиеся на себя.................
 6.6.     Поиск в таблице................................
 6.7.     Поля...........................................
 6.8.     Объединения....................................
 6.9.     Определение типа...............................
 7.    Ввод и вывод......................................
 7.1.     Обращение к стандартной библиотеке.............
 7.2.     Стандартный ввод и вывод - функции  GETCHAR
          и PUTCHAR......................................
 7.3.     Форматный вывод - функция PRINTF...............
 7.4.     Форматный ввод - функция SCANF.................
 7.5.     Форматное преобразование в памяти..............
 7.6.     Доступ к файлам................................
 7.7.     Обработка ошибок - STDERR и EXIT...............
 7.8.     Ввод и вывод строк.............................
 7.9.     Несколько разнообразных функций................
 7.9.1.     Проверка вида символов и преобразования......
 7.9.2.     Функция UNGETC...............................
 7.9.3.     Обращение к системе..........................
 7.9.4.     Управление памятью...........................
 8.    Интерфейс системы UNIX............................
 8.1.     Дескрипторы файлов.............................
 8.2.     Низкоуровневый ввод/вывод - операторы  READ
          и WRITE........................................
 8.3.     Открытие, создание, закрытие и  расцепление
          (UNLINK).......................................
 8.4.     Произвольный доступ - SEEK и LSEEK.............
 8.5.     Пример - реализация функций FOPEN и GETC.......
 8.6.     Пример - распечатка справочников...............
 8.7.     Пример - распределитель памяти.................
       Приложение а: справочное руководство по языку 'C'.
 9.1.     Введение.......................................
 10.   Лексические соглашения............................
 10.1.    Комментарии....................................
 10.2.    Идентификаторы (имена).........................
 10.3.    Ключевые слова.................................
 10.4.    Константы......................................
 10.4.1.    Целые константы..............................
 10.4.2.    Явные длинные константы......................
 10.4.3.    Символьные константы.........................
 10.4.4.    Плавающие константы..........................
 10.5.    Строки.........................................
 10.6.    Характеристики аппаратных средств..............
 11.   Синтаксическая нотация............................
 12.   Что в имене тебе моем?............................
 13.   Объекты и L-значения..............................
 14.   Преобразования....................................
 14.1.    Символы и целые................................
 14.2.    Типы FLOAT и DOUBLE............................
 14.3.    Плавающие и целочисленные величины.............
 14.4.    Указатели и целые..............................
 14.5.    Целое без знака................................
 14.6.    Арифметические преобразования..................
 15.   Выражения.........................................
 15.1.    Первичные выражения............................
 15.2.    Унарные операции...............................
 15.3.    Мультипликативные операции.....................
 15.4.    Аддитивные операции............................
 15.5.    Операции сдвига................................
 15.6.    Операции отношения.............................
 15.7.    Операции равенства.............................
 15.8.    Побитовая операция 'и'.........................
 15.9.    Побитовая операция исключающего 'или'..........
 15.10.   Побитовая операция включающего 'или'...........
 15.11.   Логическая операция 'и'........................
 15.12.   Операция логического 'или'.....................
 15.13.   Условная операция..............................
 15.14.   Операция присваивания..........................
 15.15.   Операция запятая...............................
 16.   Описания..........................................
 16.1.    Спецификаторы класса памяти....................
 16.2.    Спецификаторы типа.............................
 16.3.    Описатели......................................
 16.4.    Смысл описателей...............................
 16.5.    Описание структур и объединений................
 16.6.    Инициализация..................................
 16.7.    Имена типов....................................
 16.8.    TYPEDEF........................................
 17.   Операторы.........................................
 17.1.    Пператорное выражение..........................
 17.2.    Составной оператор (или блок)..................
 17.3.    Условные операторы.............................
 17.4.    Оператор WHILE.................................
 17.5.    Оператор DO....................................
 17.6.    Оператор FOR...................................
 17.7.    Оператор SWITCH................................
 17.8.    Оператор BREAK.................................
 17.9.    Оператор CONTINUE..............................
 17.10.   Оператор возврата..............................
 17.11.   Оператор GOTO..................................
 17.12.   Оомеченный оператор............................
 17.13.   Оустой оператор................................
 18.   Внешние определения...............................
 18.1.    Внешнее определение функции....................
 18.2.    Внешние определения данных.....................
 19.   Правила, определяющие область действия............
 19.1.    Лексическая область действия...................
 19.2.    Область действия внешних идентификаторов.......
 20.   Строки управления компилятором....................
 20.1.    Замена лексем..................................
 20.2.    Включение файлов...............................
 20.3.    Условная компиляция............................
 21.   Неявные описания..................................
 22.   Снова о типах.....................................
 22.1.    Структуры и объединения........................
 22.2.    Функции........................................
 22.3.    Массивы, указатели и индексация................
 22.4.    Явные преобразования указателей................
 23.   Константные выражения.............................
 24.   Соображения о переносимости.......................
 25.   Анахронизмы.......................................
 26.   Сводка синтаксических правил......................
 26.1.    Выражения......................................
 26.2.    Описания.......................................
 26.3.    Операторы......................................
 26.4.    Внешние определения............................
 26.5.    Препроцессор...................................
 27.   Присваивание структуры............................
 28.   Тип перечисления..................................
 29.   Таблица изображений непечатных символов языка "C".
 

     
     
     
     
 
     
     
     
                           0.1. Введение.
    Язык "C"  является универсальным языком программирования.
Он тесно связан с операционной системой "UNIX" ,  так как был
развит на   этой  системе  и  так как "UNIX" и ее программное
обеспечение написано на "C".  Сам язык ,  однако, не связан с
какой-либо одной   операционной  системой или машиной; и хотя
его называют языком системного программирования,  так как  он
удобен для написания операционных систем, он с равным успехом
использовался при написании больших вычислительных  программ,
программ для обработки текстов и баз данных.
    Язык "C" - это язык  относительно  "низкого  уровня".   В
такой характеристике   нет ничего оскорбительного; это просто
означает, что  "C" имеет дело с объектами того же вида, что и
большинство ЭВМ,  а именно,  с символами, числами и адресами.
Они могут объединяться  и  пересылаться  посредством  обычных
арифметических и     логических   операций,    осуществляемых
реальными ЭВМ.
    В языке   "C"   отсутствуют   операции,    имеющие   дело
непосредственно с   составными  объектами,  такими как строки
символов, множества, списки или с массивами, рассматриваемыми
как целое. Здесь, например, нет никакого аналога операциям PL
/1, оперирующим  с целыми  массивами  и  строками.   Язык  не
предоставляет никаких     других  возможностей  распределения
памяти, кроме  статического определения и  механизма  стеков,
обеспечиваемого локальными   переменных функций; здесь нет ни
"куч"(HEAP), ни  "сборки мусора", как это предусматривается в
АЛГОЛЕ-68. Наконец,   сам по себе "C" не обеспечивает никаких
возможностей ввода-вывода:  здесь  нет  операторов  READ  или
WRITE и никаких встроенных методов доступа к файлам.  Все эти
механизмы высокого    уровня   должны   обеспечиваться   явно
вызываемыми функциями.
    Аналогично, язык   "C"   предлагает    только    простые,
последовательные конструкции   потоков управления:  проверки,
циклы, группирование        и    подпрограммы,      но     не
мультипрограммирование, параллельные  операции, синхронизацию
или сопрограммы.
    Хотя отсутствие некоторых из этих средств может выглядеть
как удручающая   неполноценность  ("выходит,   что  я  должен
обращаться к функции,  чтобы  сравнить  две  строки  символов
?!"), но    удержание языка в скромных размерах дает реальные
преимущества. Так  как "C" относительно мал,  он  не  требует
много места   для своего описания и может быть быстро выучен.
Компилятор с "C" может быть простым и компактным. Кроме того,
компиляторы легко   пишутся;  при  использовании  современной
технологии можно ожидать написания компилятора для новой  ЭВМ
за пару   месяцев  и  при  этом  окажется,   что 80 процентов
программы нового компилятора будет общей с программой для уже
существующих компиляторов.   Это обеспечивает высокую степень
мобильности языка.    Поскольку  типы   данных   и   стуктуры
управления, имеющиеся  в "C",  непосредственно поддерживаются
большинством существующих ЭВМ,  библиотека,   необходимая  во
время прогона   изолированных  программ,   оказывается  очень
маленькой. На   PDP  -11,   например,   она  содержит  только
программы для     32-битового   умножения  и  деления  и  для
выполнения программ   ввода  и  вывода   последовательностей.
Конечно, каждая      реализация  обеспечивает  исчерпывающую,
совместимую библиотеку функций для выполнения операций ввода-
вывода, обработки   строк и распределения памяти,  но так как
обращение к ним осуществляется только явно,   можно  ,   если
необходимо, избежать    их  вызова;  эти  функции  могут быть
компактно написаны на самом "C".
    Опять же  из-за того ,  что язык "C" отражает возможности
современных компьютеров,    программы  на   "C"   оказываются
достаточно эффективными,    так  что  не возникает побуждения
писать вместо этого программы на языке ассемблера.   Наиболее
убедительным примером     этого  является  сама  операционная
система "UNIX",  которая почти полностью написана на "C".  Из
13000 строк   программы системы только около 800 строк самого
низкого уровня  написаны  на  ассемблере.   Кроме  того,   по
существу все    прикладное  программное  обеспечение  системы
"UNIX" написано на "C"; подавляющее большинство пользователей
системы "UNIX"(включая одного из авторов этой книги)  даже не
знает языка ассемблера PDP-11.
    Хотя "C"  соответствует  возможностям  многих ЭВМ,  он не
зависит от какой-либо конкретной архитектуры машины и в  силу
этого без    особых  усилий  позволяет  писать  "переносимые"
программы, т.е.   программы,  которые  можно  пропускать  без
изменений на  различных аппаратных средствах.  В наших кругах
стал уже    традицией   перенос   программного   обеспечения,
разработанного на системе "UNIX",  на системы ЭВМ: HONEYWELL,
IBM и INTERDATA.  Фактически компиляторы с "C" и  программное
обеспечение во    время  прогона  программ  на  этих  четырех
системах, по-видимому,     гораздо  более  совместимы,    чем
стандартные версии     фортрана  американского  национального
института стандартов   (ANSI).   Сама  операционная  система
"UNIX" теперь работает   как  на  PDP-11,  так и на INTERDATA
8/32. За  исключением программ, которые неизбежно оказываются
в некоторой степени машинно-зависимыми, таких как компилятор,
ассемблер и отладчик.  Написанное на  языке  "C"  программное
обеспечение идентично     на  обеих  машинах.   Внутри  самой
операционной системы    7000   строк   программы,    исключая
математическое обеспечение  языка ассемблера ЭВМ и управления
операциями ввода-вывода, совпадают на 95 процентов.
    Программистам, знакомым с другими языками,  для сравнения
и противопоставления   может  оказаться  полезным  упоминание
нескольких исторических,  технических и философских  аспектов
"C".
    Многие из  наиболее важных идей "C" происходят от гораздо
более старого,  но все еще вполне  жизненного  языка  BCPL  ,
разработанного Мартином Ричардсом.  Косвенно язык BCPL оказал
влияние на "C" через язык "B",  написанный Кеном Томпсоном  в
1970 году   для  первой  операционной  системы  "UNIX" на ЭВМ
PDP-7.
    Хотя язык "C" имеет несколько общих  с  BCPL  характерных
особенностей, он     никоим  образом  не  является  диалектом
последнего. И  BCPL и "B" - "безтипные"  языки;  единственным
видом данных   для  них  являются машинное слово,  а доступ к
другим объектам   реализуется  специальными  операторами  или
обращением к  функциям.  В языке "C" объектами основных типов
данных являются символы,  целые числа нескольких  размеров  и
числа с   плавающей  точкой.   Кроме  того,  имеется иерархия
производных типов данных, создаваемых указателями, массивами,
структурами, объединениями и функциями.
    Язык "C" включает основные конструкции потока управления,
требуемые для хорошо структуированных программ: группирование
операторов, принятие     решений  (IF),   циклы  с  проверкой
завершения в начале (WHILE,  FOR)  или в конце (DO)  и  выбор
одного из   множества возможных вариантов (SWITCH).  (Все эти
возможности обеспечивались и в BCPL,  хотя  и  при  несколько
отличном синтаксисе;   этот  язык  предчувствовал наступившую
через несколько лет моду на структурное программирование).
    В языке "C"  имеются  указатели  и  возможность  адресной
арифметики. Аргументы      передаются   функциям  посредством
копирования значения аргумента , и вызванная функция не может
изменить фактический   аргумент в вызывающей программе.  Если
желательно добиться "вызова по ссылке", можно неявно передать
указатель, и  функция сможет изменить объект, на который этот
указатель указывает.   Имена  массивов  передаются  указанием
начала массивов,   так что аргументы типа массивов эффективно
вызываются по ссылке.
    К любой  функции  можно  обращаться  рекурсивно,   и   ее
локальные переменные обычно "автоматические",  т.е. Создаются
заново при каждом обращении.  Описание одной функции не может
содержаться внутри другой,  но переменные могут описываться в
соответствии с обычной блочной структурой.  Функции в  "C"  -
программе могут   транслироваться  отдельно.   переменные  по
отношению к функции могут быть  внутренними,   внешними,   но
известными только   в  пределах  одного исходного файла,  или
полностью глобальными.    Внутренние  переменные  могут  быть
автоматическими или  статическими.  Автоматические переменные
для большей эффективности  можно  помещать  в  регистры,   но
объявление регистра является только указанием для компилятора
и никак не связано с конкретными машинными регистрами.
    Язык "C"  не  является языком со строгими типами в смысле
Паскаля или  алгола  68.   Он  сравнительно  снисходителен  к
преобразованию данных,      хотя  и  не  будет  автоматически
преобразовывать типы данных с буйной непринужденностью  языка
PL/1. Существующие    компиляторы  не предусматривают никакой
проверки во время  выполнения  программы  индексов  массивов,
типов аргументов и т.д.
    В тех ситуациях, когда желательна строгая проверка типов,
используется специальная версия компилятора.   Эта  программа
называется LINT очевидно потому, она выбирает кусочки пуха из
вашей программы. Программа LINT не генерирует машинного кода,
а делает   очень  строгую проверку всех тех сторон программы,
которые можно   проконтролировать  во  время   компиляции   и
загрузки. Она          определяет    несоответствие    типов,
несовместимость аргументов,  неиспользованные  или  очевидным
образом неинициализированные     переменные,    потенциальные
трудности переносимости    и   т.д.    Для   программ,которые
благополучно проходят   через LINT,  гарантируется отсутствие
ошибок типа примерно с той же полнотой,  как и для  программ,
написанных, например,     на  АЛГОЛЕ-68.   Другие возможности
программы LINT     будут   отмечены,    когда    представится
соответствующий случай.
    Наконец, язык  "C",  подобно любому другому языку,  имеет
свои недостатки.     Некоторые   операции   имеют   неудачное
старшинство; некоторые   разделы  синтаксиса  могли  бы  быть
лучше; сушествует   несколько  версий  языка,    отличающихся
небольшими деталями.    Тем  не менее язык "C" зарекомендовал
себя как исключительно эффективный и выразительный  язык  для
широкого разнообразия применений программирования.
    Содержание книги организовано следующим образом.  Глава 1
является учебным введением в  центральную  часть  языка  "C".
Цель -   позволить  читателю стартовать так быстро,как только
возможно, так как мы твердо убеждены, что единственный способ
изучить новый   язык  -  писать на нем программы.  При этом ,
однако, предполагается  рабочее владение основными элементами
программирования; здесь   не  объясняется,  что такое ЭВМ или
компилятор, не поясняется смысл выражений типа N=N+1. Хотя мы
и пытались,    где это возможно,  продемонстрировать полезную
технику программирования.  Эта книга не предназначается  быть
справочным руководством   по  структурам данных и алгоритмам;
там, где      мы   вынуждены   были   сделать   выбор,     мы
концентрировались на языке.
    В главах со 2-й по 6-ю различные аспекты  "C"  излагаются
более детально   и несколько более формально,  чем в главе 1,
хотя ударение   по-прежнему  делается  на  разборе   примеров
законченных, полезных программ, а не на отдельных фрагментах.
    В главе 2 обсуждаются основные типы данных,  операторы  и
выражения. В   главе 3 рассматриваются управляющие операторы:
IF-ELSE ,WHILE ,FOR и т.д.   Глава  4  охватывает  функции  и
структуру программы      -   внешние   переменные,    правила
определенных областей действия описания и  т.д.   В  главе  5
обсуждаются указатели и адресная арифметика. Глава 6 содержит
подробное описание структур и объединений.
    В главе 7 описывается стандартная библиотека ввода-вывода
языка "C",    которая  обеспечивает  стандартный  интерфейс с
операционной системой.      Эта    библиотека    ввода-вывода
поддерживается на   всех машинах,  на которых реализован "C",
так что программы, использующие ее для ввода, вывода и других
системных функций,    могут  переноситься  с одной системы на
другую по существу без изменений.
    В главе 8 описывается интерфейс между "C" - программами и
операционной системой   "UNIX".  Упор делается на ввод-вывод,
систему файлов и переносимость.  Хотя  некоторые  части  этой
главы специфичны       для   операционной   системы   "UNIX",
программисты, не  использующие "UNIX",  все же  должны  найти
здесь полезный материал,  в том числе некоторое представление
о том,  как реализована одна версия стандартной библиотеки  и
предложения для достижения переносимости программы.
    Приложение A  содержит  справочное  руководство  по языку
"C". Оно   является  "официальным"  изложением  синтаксиса  и
семантики "C"   и  (исключая чей-либо собственный компилятор)
окончательным арбитром для всех двусмысленностей и упущений в
предыдущих главах.
    Так как "C" является развивающимся языком,  реализованным
на множестве систем,  часть материла настоящей книги может не
соответствовать текущему   состоянию  разработки  на какой-то
конкретной системе.  Мы старались избегать  таких  проблем  и
предостерегать о     возможных  трудностях.   В  сомнительных
случаях, однако,   мы обычно предпочитали описывать  ситуацию
для системы  "UNIX" PDP-11 ,  так как она является средой для
большинства программирующих на языке  "C".   В  приложении  а
также описаны расхождения в реализациях языка "C" на основных
системах.

     
     
     
     
     
  

     
                        1. Учебное введение.
    
    Давайте начнем с быстрого введения в язык "C".  Наша цель
- продемонстрировать  существенные элементы языка на реальных
программах, не увязая при этом в деталях, формальных правилах
и исключениях.    В  этой  главе мы не пытаемся изложить язык
полностью или хотя бы строго (разумеется,  приводимые примеры
будут корректными).  Мы хотим как можно скорее довести вас до
такого уровня,  на котором вы  были  бы  в  состоянии  писать
полезные программы,       и   чтобы   добиться   этого,    мы
сосредотачиваемся на   основном:   переменных  и  константах,
арифметике, операторах    передачи  управления,   функциях  и
элементарных сведениях  о  вводе  и  выводе.   Мы  совершенно
намеренно оставляем   за пределами этой главы многие элементы
языка "C",    которые  имеют  первостепенное   значение   при
написании больших программ, в том числе указатели, сртуктуры,
большую часть   из  богатого  набора  операторов  языка  "C",
несколько операторов     передачи   управления   и  несметное
количество деталей.
    Такой подход имеет,  конечно,   свои  недостатки.   Самым
существенным является     то,   что  полное  описание  любого
конкретного элемента языка не излагается в  одном  месте,   а
пояснения, в  силу краткости,  могут привести к неправильному
истолкованию. Кроме  того,  из-за невозможности  использовать
всю мощь   языка,   примеры  оказываются  не столь краткими и
элегантными, как  они могли бы быть.   И  хотя  мы  старались
свести эти недостатки к минимуму, все же имейте их ввиду.
    Другой недостаток  состоит  в том,  что последующие главы
будут неизбежно повторять некоторые  части  этой  главы.   Мы
надеемся, что    такое повторение будет скорее помогать,  чем
раздражать.
    Во всяком случае, опытные программисты должны оказаться в
состоянии проэкстраполировать   материал данной главы на свои
собственные программистские нужды.  Начинающие  же  должны  в
дополнение писать     аналогичные  маленькие  самостоятельные
программы. И  те,  и другие могут использовать эту главу  как
каркас, на     который  будут  навешиваться  более  подробные
описания, начинающиеся с главы 2.




                1.1. Hачинаем.

Единственный способ  освоить  новый  язык  программирования -
писать на нем программы.  Первая программа,   которая  должна
быть написана,    - одна для всех языков:  напечатать слова :
HELLO, WORLD.
    Это - самый существенный барьер; чтобы преодолеть его, вы
должны суметь завести где-то текст  программы,   успешно  его
скомпилировать, загрузить,   прогнать и найти,  где оказалась
ваша выдача.    Если  вы  научились   справляться   с   этими
техническими деталями, все остальное сравнительно просто.
    Программа печати "HELLO, WORLD" на языке "C" имеет вид:

    MAIN ()
    {
            PRINTF("HELLO, WORLD\N");
    }
    Как пропустить эту программу -  зависит  от  используемой
вами системы.  В частности, на операционной системе "UNIX" вы
должны завести исходную  программу  в  файле,   имя  которого
оканчивается на   ".C"  ,   например,   HELLO.C  ,   и  затем
скомпилировать ее по команде
      
            CC HELLO.C
      
    Если вы  не допустили какой-либо небрежности ,  такой как
пропуск символа   или  неправильное  написание,    компиляция
пройдет без   сообщений  и  будет  создан  исполняемый файл с
именем а.OUT . Прогон его по команде
      
               A.OUT
      
    приведет к выводу
      
           HELLO, WORLD
      
    На других    системах    эти    правила    будут   иными;
проконсультируйтесь с местным авторитетом.
    
    Упражнение 1-1.
    ---------------
    Пропустите эту программу на вашей системе.  Попробуйте не
включать различные     части  программы  и  посмотрите  какие
сообщения об ошибках вы при этом получите.
    Теперь некоторые  пояснения  к  самой  программе.   Любая
"C"-программа, каков  бы ни был ее размер,  состоит из  одной
или более     "функций",   указывающих  фактические  операции
компьютера, которые  должны быть выполнены.  Функции в  языке
"C" подобны функциям и подпрограммам фортрана и процедурам PL
/1, паскаля  и т.д.  В нашем примере такой функцией  является
MAIN. Обычно  вы можете давать функциям любые имена по вашему
усмотрению, но  MAIN  -  это  особое  имя;  выполнение  вашей
программы начинается   сначала с функции MAIN.  Это означает,
что каждая   программа  должна  в  каком-то  месте  содержать
функцию с  именем MAIN.  Для выполнения определенных действий
функция MAIN обычно обращается к другим функциям,   часть  из
которых находится   в  той  же  самой программе,  а часть - в
библиотеках, содержащих ранее написанные функции.
    Одним способом  обмена  данными  между функциями является
передача посредством аргументов. Круглые скобки, следующие за
именем функции,    заключают  в себе список аргументов; здесь
маIN - функция  без  аргументов,   что  указывается  как  ().
Операторы, составляющие    функцию,   заключаются  в фигурные
скобки { и },  которые аналогичны DO-END в PL/1 или BEGIN-END
в алголе,  паскале и т.д.  Обращение к функции осуществляется
указанием ее имени,  за которым следует заключенный в круглые
скобки список аргументов.  здесь нет никаких операторов CALL,
как в фортране или PL/1. Круглые скобки должны присутствовать
и в том случае, когда функция не имеет аргументов. Строка
      
      PRINTF("HELLO, WORLD\N");
      
является обращением к функции,  которое  вызывает  функцию  с
именем PRINTF  и аргуметом "HELLO,  WORLD\N".  Функция PRINTF
является библиотечной   функцией,   которая  выдает  выходные
данные на   терминал  (если только не указано какое-то другое
место назначения).    В  данном  случае   печатается   строка
символов, являющаяся аргументом функции.
    Последовательность из    любого    количества   символов,
заключенных в удвоенные кавычки "...", называется 'символьной
строкой' или     'строчной   константой'.    Пока   мы  будем
использовать символьные строки только в  качестве  аргументов
для PRINTF и других функций.
    Последовательность \N   в   приведенной  строке  является
обозначением на языке "C" для 'символа новой строки', который
служит указанием   для  перехода  на  терминале к левому краю
следующей строки.    Если  вы  не   включите   \N   (полезный
эксперимент), то   обнаружите,  что ваша выдача не закончится
переходом терминала     на   новую   строку.    Использование
последовательности \N  - единственный способ введения символа
новой строки в аргумент функции PRINTF;  если  вы  попробуете
что-нибудь вроде
      
          PRINTF("HELLO, WORLD
          ");
      
то "C"-компилятор будет  печатать  злорадные  диагностические
сообщения о недостающих кавычках.
    Функция PRINTF не обеспечивает  автоматического  перехода
на новую  строку,  так что многократное обращение к ней можно
использовать для  поэтапной  сборки  выходной  строки.   Наша
первая программа, печатающая идентичную выдачу, с точно таким
же успехом могла бы быть написана в виде
      
     MAIN()
     {
             PRINTF("HELLO, ");
             PRINTF("WORLD");
             PRINTF("\N");
     }
      
    Подчеркнем, что   \N  представляет  только  один  символ.
Условные 'последовательности',  подобные \N ,  дают  общий  и
допускающий расширение механизм для представления трудных для
печати или невидимых символов.  Среди прочих символов в языке
"C" предусмотрены   следующие:  \т - для табуляции,  \B - для
возврата на одну позицию,  \" - для двойной кавычки и \\  для
самой обратной косой черты.
    Упражнение 1-2.
    ---------------
    Проведите эксперименты   для   того,   чтобы  узнать  что
произойдет, если  в строке,   являющейся  аргументом  функции
PRINTF будет   содержаться \X,  где X - некоторый символ,  не
входящий в вышеприведенный список.
     
     
     
     
       
     
             1.2. Переменные и арифметика.
    
    Следующая программа  печатает  приведенную  ниже  таблицу
температур по Фаренгейту и их  эквивалентов  по  стоградусной
шкале Цельсия, используя для перевода формулу
      
          C = (5/9)*(F-32).

       0       -17.8
      20        -6.7
      40         4.4
      60        15.6
     ...         ...
     260       126.7
     280       137.8
     300       140.9
      
    Теперь сама программа:
      
    /* PRINT FAHRENHEIT-CELSIUS TABLE
    FOR F = 0, 20, ..., 300 */
    MAIN()
    {
    INT LOWER, UPPER, STEP;
    FLOAT FAHR, CELSIUS;
    LOWER = 0;  /* LOWER LIMIT OF TEMPERATURE
    TABLE */
    UPPER =300; /* UPPER LIMIT */
    STEP  = 20; /* STEP SIZE */
    FAHR = LOWER;
    WHILE (FAHR <= UPPER) {
      CELSIUS = (5.0/9.0) * (FAHR -32.0);
      PRINTF("%4.0F %6.1F\N", FAHR, CELSIUS);
      FAHR = FAHR + STEP;
    }
    }
 
    Первые две строки
      
      /* PRINT FAHRENHEIT-CELSIUS TABLE
         FOR  F = 0, 20, ..., 300 */
      
являются комментарием,    который   в  данном  случае  кратко
поясняет, что  делает программа.  Любые символы между /* и */
игнорируются компилятором;     можно   свободно  пользоваться
комментариями для облегчения понимания программы. Комментарии
могут появляться   в  любом  месте,   где возможен пробел или
переход на новую строку.
    В языке "C" все переменные  должны  быть  описаны  до  их
использования, обычно    это  делается  в  начале  функции до
первого выполняемого оператора.  Если  вы  забудете  вставить
описание, то      получите   диагностическое   сообщение   от
компилятора. Описание  состоит из типа и  списка  переменных,
имеющих этот тип, как в
     
     INT LOWER, UPPER, STEP;
     FLOAT FAHR, CELSIUS;
     
    Тип INT  означает,   что все переменные списка целые; тип
FLOAT предназначен для чисел с плавающей точкой,   т.е.   для
чисел, которые  могут иметь дробную часть. Точность как INT ,
TAK и FLOAT зависит от  конкретной  машины,   на  которой  вы
работаете. На    PDP-11,   например,   тип  INT соответствует
16-битовому числу со знаком,  т.е.   числу,   лежащему  между
-32768 и   +32767.   Число типа FLOAT - это 32-битовое число,
имеющее около семи значащих цифр и  лежащее  в  диапазоне  от
10е-3 до   10е+3.   В  главе 2 приводится список размеров для
других машин.
    В языке "C" предусмотрено несколько других основных типов
данных, кроме INT и FLOAT:
    CHAR символ - один байт
    SHORT короткое целое
    LONG длинное целое
    DOUBLE плавающее с двойной точностью
    Размеры этих  объектов  тоже  машинно-независимы;  детали
приведены в главе 2.  Имеются  также  массивы,   структуры  и
объединения этих     основных  типов,   указатели  на  них  и
функции,которые их возвращают; со всеми ними мы встретимся  в
свое время.
    Фактически вычисления  в  программе  перевода  температур
начинаются с операторов присваивания
    LOWER = 0;
    UPPER =300;
    STEP = 20;
    FAHR =LOWER;
которые придают  переменным  их  начальные  значения.  каждый
отдельный оператор заканчивается точкой с запятой.
    Каждая строка таблицы вычисляется одинаковым образом, так
что мы используем цикл,  повторяющийся один раз на строку.  В
этом назначение оператора WHILE:
     
    WHILE (FAHR <= UPPER) {
    ....
    }
     
проверяется условие в круглых скобках. Если оно истинно (FAHR
меньше или равно UPPER),   то  выполняется  тело  цикла  (все
операторы, заключенные в фигурные скобки { и } ). Затем вновь
проверяется это   условие  и,   если  оно   истинно,    опять
выполняется тело цикла. Если же условие не выполняется ( FAHR
превосходит UPPER ),  цикл заканчивается и происходит переход
к выполнению оператора,  следующего за оператором цикла.  Так
как в настоящей программе нет никаких последующих операторов,
то выполнение программы завершается.
    Тело оператора  WHILE  может состоять из одного или более
операторов, заключенных  в фигурные скобки,  как в  программе
перевода температур, или из одного оператора без скобок, как,
например, в
     
     WHILE (I < J)
           I = 2 * I;
     
    В обоих случаях операторы,  управляемые оператором WHILE,
сдвинуты на одну табуляцию,  чтобы вы могли с первого взгляда
видеть, какие  операторы находятся внутри цикла.  Такой сдвиг
подчеркивает логическую   структуру  программы.  Хотя в языке
"C" допускается совершенно       произвольное    расположение
операторов в    строке,   подходящий  сдвиг  и  использование
пробелов значительно     облегчают   чтение   программ.    Мы
рекомендуем писать  только один оператор на строке и (обычно)
оставлять пробелы вокруг операторов.   Расположение  фигурных
скобок менее   существенно;  мы  выбрали  один  из нескольких
популярных стилей.  Выберите подходящий для вас стиль и затем
используйте его последовательно.
    Основная часть   работы   выполняется   в   теле   цикла.
Температура по Цельсию вычисляется и присваивается переменной
CELAIUS оператором
     
      CELSIUS = (5.0/9.0) * (FAHR-32.0);
     
причина использования  выражения  5.0/9.0  вместо выглядящего
проще 5/9 заключается в том, что в языке "C", как и во многих
других языках,     при  делении  целых  происходит  усечение,
состоящее в отбрасывании  дробной  части  результата.   Таким
образом, результат  операции 5/9 равен нулю,  и,  конечно,  в
этом случае   все  температуры  оказались  бы  равными  нулю.
Десятичная точка  в константе указывает,  что она имеет тип с
плавающей точкой,  так что,  как мы и хотели,  5.0/9.0  равно
0.5555... .
    Мы также писали 32.0 вместо 32 ,  несмотря на то, что так
как переменная FAHR имеет тип FLOAT ,  целое 32 автоматически
бы преобразовалось к типу FLOAT ( в 32.0) перед вычитанием. С
точки зрения стиля разумно писать плавающие константы с явной
десятичной точкой даже тогда, когда они имеют целые значения;
это подчеркивает   их  плавающую природу для просматривающего
программу и обеспечивает то, что компилятор будет смотреть на
вещи так же, как и Вы.
    Подробные правила   о   том,    в   каком   случае  целые
преобразуются к типу с плаваюшей точкой, приведены в главе 2.
Сейчас же отметим, что присваивание
     
            FAHR = LOWER;
     
    проверка
     
            WHILE (FAHR <= UPPER)
     
работают, как  ожидается,  - перед выполнением операций целые
преобразуются в плавающую форму.
    Этот же  пример сообщает чуть больше о том,  как работает
PRINTF. Функция   PRINTF  фактически  является  универсальной
функцией форматных   преобразований,  которая будет полностью
описана в главе 7.   Ее  первым  аргументом  является  строка
символов, которая  должна быть напечатана, причем каждый знак
% указывает,  куда должен подставляться каждый  из  остальных
аргументов /второй,   третий,  .../ и в какой форме он должен
печататься. Например, в операторе
     
      PRINTF("%4.0F %6.1F\N", FAHR, CELSIUS);
     
спецификация преобразования   %4.0F  говорит,   что  число  с
плавающей точкой должно быть напечатано  в  поле  шириной  по
крайней мере   в  четыре  символа  без  цифр после десятичной
точки. спецификация  %6.1F описывает другое  число,   которое
должно занимать  по крайней мере шесть позиций с одной цифрой
после десятичной  точки,   аналогично  спецификациям  F6.1  в
фортране или   F(6,1)   в PL/1.  Различные части спецификации
могут быть опущены: спецификация %6F говорит, что число будет
шириной по   крайней  мере  в шесть символов; спецификация %2
требует двух позиций после десятичной точки,  но  ширина  при
этом не ограничивается; спецификация %F говорит только о том,
что нужно напечатать число с плавающей точкой. Функция PRINTF
также распознает следующие спецификации: %D - для десятичного
целого, %о    -  для   восьмеричного   числа,    %х   -   для
шестнадцатиричного, %с    - для символа,  %S - для символьной
строки и %% - для самого символа %.
    Каждая конструкция   с  символом  %  в  первом  аргументе
функции PRINTF сочетается с соответствующим вторым,  третьим,
и т.д.    Аргументами;  они должны согласовываться по числу и
типу; в    противном   случае   вы   получите   бессмысленные
результаты.
    Между прочим,   функция  PRINTF  не является частью языка
"C"; в самом языке "C" не определены  операции  ввода-вывода.
Нет ничего   таинственного  и в функции PRINTF ; это - просто
полезная функция,  являющаяся частью  стандартной  библиотеки
подпрограмм, которая   обычно доступна "C"-программам.  Чтобы
сосредоточиться на   самом  языке,   мы  не  будем   подробно
останавливаться на   операциях  ввода-вывода  до  главы 7.  В
частности, мы  до тех пор отложим форматный ввод.   Если  вам
надо ввести числа - прочитайте описание функции SCANF в главе
7, раздел  7.4.  Функция SCANF во многом сходна с PRINTF , но
она считывает входные данные, а не печатает выходные.
    Упражнение 1-3.
    ----------------
    Преобразуйте программу перевода температур таким образом,
чтобы она печатала заголовок к таблице.
    Упражнение 1-4.
    ----------------
    Напишите программы    печати    соответствующей   таблицы
перехода от градусов цельсия к градусам фаренгейта.

     
     
                                
     
     
                  1.3. Оператор FOR.
    
    Как и можно было ожидать,   имеется  множество  различных
способов написания каждой программы. Давайте рассмотрим такой
вариант программы перевода температур:
     
    MAIN() /* FAHRENHEIT-CELSIUS TABLE */
    {
      INT FAHR;
      FOR (FAHR = 0; FAHR <= 300; FAHR = FAHR + 20)
    PRINTF("%4D %6.1F\N", FAHR, (5.0/9.0)*(FAHR-32.0));
    }
     
    Эта программа выдает те же самые результаты,  но выглядит
безусловно по-другому.    Главное  изменение   -   исключение
большинства переменных;   осталась  только  переменная FAHR ,
причем типа     INT   (это   сделано   для    того,     чтобы
продемонстрировать преобразование    %D  в  функции  PRINTF).
Нижняя и верхняя границы и размер щага появляются только  как
константы в   операторе  FOR  ,   который  сам является новой
конструкцией, а    выражение,   вычисляющее  температуру   по
цельсию, входит    теперь  в  виде третьего аргумента функции
PRINTF , а не в виде отдельного оператора присваивания.
    Последнее изменение  является  примером   вполне   общего
правила языка "C" - в любом контексте,  в котором допускается
использование значения переменной некоторого типа,  вы можете
использовать выражение   этого типа.  Так как третий аргумент
функции PRINTF должен  иметь  значение  с  плавающей  точкой,
чтобы соответствовать   спецификации  %6.1F,  то в этом месте
может встретиться любое выражение плавающего типа.
    Сам оператор  FOR  -  это  оператор  цикла,    обобщающий
оператор WHILE. Его функционирование должно стать ясным, если
вы сравните его с ранее описанным оператором WHILE . Оператор
FOR содержит три части,  разделяемые точкой с запятой. Первая
часть
 
    FAHR = 0
 
выполняется один раз перед входом в сам цикл.  Вторая часть -
проверка, или условие, которое управляет циклом:
 
    FAHR <= 300
 
это условие проверяется и,  если оно истинно,  то выполняется
тело цикла   (в данном случае только функция PRINTF ).  Затем
выполняется шаг реинициализации
 
    FAHR =FAHR + 20
 
и условие проверяется снова.  цикл  завершается,   когда  это
условие становится ложным.  Так же,  как и в случае оператора
WHILE ,  тело цикла может состоять из одного оператора или из
группы операторов,       заключенных   в   фигурные   скобки.
Инициализирующая и реинициализирующая части могут быть любыми
отдельными выражениями.
    Выбор между   операторами   WHILE   и  FOR  произволен  и
основывается на том , что выглядит яснее. Оператор FOR обычно
удобен для циклов,  в которых инициализация и реинициализация
логически связаны и каждая задается одним оператором, так как
в этом  случае запись более компактна,  чем при использовании
оператора WHILE     ,    а   операторы   управления    циклом
сосредотачиваются вместе в одном месте.
    Упражнение 1-5.
    ---------------
    Модифицируйте программу    перевода    температур   таким
образом, чтобы  она печатала таблицу в обратном порядке, т.е.
От 300 градусов до 0.

     
     
     
     
     
           
     
     
              1.4. Символические константы.
    
    Последнее замечание,   прежде  чем  мы  навсегда  оставим
программу перевода   температур.  Прятать "магические числа",
такие как  300  и  20,   внутрь  программы  -  это  неудачная
практика; они дают мало информации тем, кто, возможно, должен
будет разбираться в этой  программе  позднее,   и  их  трудно
изменять систематическим   образом.   К  счастью  в языке "C"
предусмотрен способ,  позволяющий избежать таких  "магических
чисел". Используя   конструкцию #DEFINE ,  вы можете в начале
программы определить   символическое  имя  или  символическую
константу, которая      будет  конкретной  строкой  символов.
Впоследствии компилятор заменит все не заключенные в  кавычки
появления этого  имени на соответствующую строку.  Фактически
это имя может быть заменено абсолютно  произвольным  текстом,
не обязательно цифрами
 
    #DEFINE LOWER 0/* LOWER LIMIT OF TABLE */
    #DEFINE UPPER 300 /* UPPER LIMIT */
    #DEFINE STEP 20 /* STEP SIZE */
    MAIN () /* FAHRENHEIT-CELSIUS TABLE */
    {
    INT FAHR;
    FOR (FAHR =LOWER; FAHR <= UPPER; FAHR =FAHR + STEP)
     PRINTF("%4D %6.1F\N", FAHR, (5.0/9.0)*(FAHR-32));
    }
 
 
    величины LOWER,  UPPER  и  STEP  являются  константами  и
поэтому они  не указываются в описаниях.  Символические имена
обычно пишут прописными буквами, чтобы их было легко отличить
от написанных строчными буквами имен переменных. отметим, что
в конце определения не ставится точка  с  запятой.   Так  как
подставляется вся  строка,  следующая за определенным именем,
то это привело бы к слишком большому числу точек с запятой  в
операторе FOR .

     
     
     
     
                                                                          
     
     
     
              1.5. Набор полезных программ.
     
    Теперь мы собираемся  рассмотреть  семейство  родственных
программ, предназначенных для выполнения простых операций над
символьными данными.  В дальнейшем вы обнаружите,  что многие
программы являются     просто   расширенными   версиями   тех
прототипов, которые мы здесь обсуждаем.
    
     
    
     
     
               1.5.1. Ввод и вывод символов.
     
    Стандартная библиотека  включает  функции  для  чтения  и
записи по одному символу  за  один  раз.   функция  GETCHAR()
извлекает следующий   вводимый  символ каждый раз,  как к ней
обращаются, и   возвращает  этот  символ  в  качестве  своего
значения. Это значит, что после
 
         C = GETCHAR()
 
переменная 'C' содержит следующий символ из  входных  данных.
Символы обычно   поступают с терминала,  но это не должно нас
касаться до главы 7.
    Функция PUTCHAR(C)   является  дополнением к GETCHAR :  в
результате обращения
 
         PUTCHAR (C)
 
содержимое переменной  'C'  выдается  на  некоторый  выходной
носитель, обычно    опять  на терминал.  Обращение к функциям
PUTCHAR и PRINTF могут перемежаться; выдача будет  появляться
в том порядке, в котором происходят обращения.
    Как и функция PRINTF ,   функции  GETCHAR  и  PUTCHAR  не
содержат ничего   экстраординарного.   Они не входят в состав
языка "C", но к ним всегда можно обратиться.

     
     
     
     
    
     
     
              1.5.2. Копирование файла.
 
    Имея в  своем  распоряжении  только  функции  GETCHAR   и
PUTCHAR вы   можете,   не  зная  ничего  более  об  операциях
ввода-вывода, написать    удивительное  количество   полезных
программ. Простейшим      примером  может  служить  программа
посимвольного копирования вводного файла в  выводной.   Общая
схема имеет вид:
    ввести символ
    WHILE (символ не является признаком конца файла)
    вывести только что прочитанный символ
    ввести новый символ
 
программа, написанная  на  языке  "C",   выглядит   следующим
 образом:
 
    MAIN()  /* COPY INPUT TO OUTPUT; 1ST VERSION */
    {
       INT C;
 
       C = GETCHAR();
       WHILE (C != EOF) {
            PUTCHAR (C);
            C = GETCHAR();
       }
    }
 
оператор отношения != означает "не равно".
    Основная проблема заключается в том,  чтобы зафиксировать
конец файла     ввода.    Обычно,    когда   функция  GETCHAR
наталкивается на конец файла ввода, она возвращает значение ,
не являющееся     действительным   символом;  таким  образом,
программа может   установить,   что  файл   ввода   исчерпан.
Единственное осложнение, являющееся значительным неудобством,
заключается в     существовании   двух    общеупотребительных
соглашений о     том,   какое  значение  фактически  является
признаком конца файла.  Мы отсрочим  решение  этого  вопроса,
использовав символическое  имя EOF для этого значения,  каким
бы оно ни было.  На практике EOF будет либо -1,  либо 0,  так
что для   правильной  работы  перед  программой должно стоять
собственно либо
 
    #DEFINE EOF -1
 
    либо
 
    #DEFINE EOF 0
 
    Использовав символическую константу EOF для представления
значения, возвращаемого  функцией GETCHAR при выходе на конец
файла, мы  обеспечили,  что только одна величина в  программе
зависит от конкретного численного значения.
    Мы также описали переменную 'C' как INT ,  а не CHAR ,  с
тем чтобы она могла хранить значение,  возвращаемое GETCHAR .
как мы увидим в главе 2,  эта величина действительно INT, так
как она   должна  быть  в  состоянии  в  дополнение  ко  всем
возможным символам представлять и EOF.
    Программистом, имеющим опыт  работы  на  "C",   программа
копирования была  бы написана более сжато.  В языке "C" любое
присваивание, такое как
 
    C = GETCHAR()
 
может быть использовано в выражении; его  значение  -  просто
значение, присваиваемое    левой  части.   Если  присваивание
символа переменной 'C'  поместить  внутрь  проверочной  части
оператора WHILE ,  то программа копирования файла запишется в
виде:
 
    MAIN()  /* COPY INPUT TO OUTPUT; 2ND VERSION */
    {
    INT C;
 
    WHILE ((C = GETCHAR()) != EOF)
    PUTCHAR(C);
    }
 
    Программа извлекает  символ ,  присваивает его переменной
'C' и затем проверяет,  не является ли этот символ  признаком
конца файла.    Если  нет - выполняется тело оператора WHILE,
выводящее этот символ.  Затем цикл WHILE повторяется.  когда,
наконец, будет   достигнут конец файла ввода,  оператор WHILE
завершается, а   вместе  с  ним  заканчивается  выполнение  и
функции MAIN .
    В этой  версии  централизуется  ввод - в программе только
одно обращение к функции GETCHAR  -  и  ужимается  программа.
Вложение присваивания в проверяемое условие - это одно из тех
мест языка "C",  которое приводит к значительному  сокращению
программ. Однако, на этом пути можно увлечься и начать писать
недоступные для понимания программы.  Эту тенденцию мы  будем
пытаться сдерживать.
    Важно понять  ,  что круглые скобки вокруг присваивания в
условном выражении   действительно  необходимы.   Старшинство
операции !=   выше,   чем  операции  присваивания  =,   а это
означает, что в отсутствие круглых скобок проверка условия !=
будет выполнена до присваивания =. Таким образом, оператор
 
    C = GETCHAR() != EOF
 
    эквивалентен оператору
 
    C = (GETCHAR() != EOF)
 
    Это, вопреки  нашему  желанию,  приведет к тому,  что 'C'
будет принимать значение 0  или  1  в  зависимости  от  того,
натолкнется или нет GETCHAR на признак конца файла. Подробнее
об этом будет сказано в главе 2/.

     
     
     
     
 
     
     
                      1.5.3. Подсчет символов.
 
    Следующая программа  подсчитывает  число  символов;   она
представляет собой  небольшое развитие программы копирования.
 
    MAIN()  /* COUNT CHARACTERS IN INPUT */
    {
        LONG NC;
 
        NC = 0;
        WHILE (GETCHAR() != EOF )
       ++NC;
        PRINTF("%1D\N", NC);
    }
 
    Оператор
 
       ++NC;
 
демонстрирует новую операцию, ++, которая означает увеличение
на единицу.  Вы могли бы написать NC = NC + 1 , но ++NC более
кратко и  зачастую более эффективно.  Имеется соответствующая
операция -- уменьшение на единицу.  Операции ++  и  --  могут
быть либо  префиксными (++NC),  либо постфиксными (NC++); эти
две формы,  как будет показано в главе 2,  имеют в выражениях
различные значения,  но как ++NC,  так и NC++ увеличивают NC.
Пока мы будем придерживаться префиксных операций.
    Программа подсчета символов накапливает их  количество  в
переменной типа   LONG,   а  не INT .  На PDP-11 максимальное
значение равно 32767,  и если описать счетчик как INT , то он
будет переполняться  даже при сравнительно малом файле ввода;
на языке "C" для HONEYWELL и IBM типы  LONG  и  INT  являются
синонимами и  имеют значительно больший размер.  Спецификация
преобразования %1D указывает PRINTF  ,   что  соответствующий
аргумент является целым типа LONG .
    Чтобы справиться  с  еще  большими  числами,   вы  можете
использовать тип DOUBLE / FLOAT  двойной  длины/.   мы  также
используем оператор     FOR   вместо   WHILE  с  тем,   чтобы
проиллюстрировать другой способ записи цикла.
 
    MAIN()  /* COUNT CHARACTERS IN INPUT */
    {
        DOUBLE  NC;
 
        FOR (NC = 0; GETCHAR() != EOF; ++NC)
       ;
        PRINTF("%.0F\N", NC);
    }
 
    Функция PRINTF использует спецификацию %F как для FLOAT ,
так и   для  DOUBLE  ;  спецификация  %.0F  подавляет  печать
несуществующей дробной части.
    Тело оператора цикла FOR здесь пусто,  так как вся работа
выполняется в   проверочной и реинициализационной частях.  Но
грамматические правила языка "C" требуют,  чтобы оператор FOR
имел тело.    Изолированная точка с запятой,  соответствуюшая
пустому оператору,  появляется  здесь,   чтобы  удовлетворить
этому требованию.  Мы выделили ее на отдельную строку,  чтобы
сделать ее более заметной.
    Прежде чем  мы   распростимся   с   программой   подсчета
символов, отметим,    что если файл ввода не содержит никаких
символов, то  условие в WHILE или FOR не выполнится при самом
первом обращении  к GETCHAR ,  и,  следовательно ,  программа
выдаст нуль,  т.е.  Правильный ответ.  это важное  замечание.
одним из приятных свойств операторов WHILE и FOR является то,
что они проверяют условие в начале цикла,  т.е. До выполнения
тела. Если делать ничего не надо, то ничего не будет сделано,
даже если это означает,  что  тело  цикла  никогда  не  будет
выполняться. программы  должны действовать разумно, когда они
обращаются с файлами типа "никаких символов". Операторы WHILE
и FOR   помогают обеспечить правильное поведение программ при
граничных значениях проверяемых условий.

     
     
     
     
     
     
     
     
              1.5.4. Подсчёт строк.
 
    Следующая программа подсчитывает количество строк в файле
ввода. Предполагается,      что  строки  ввода  заканчиваются
символом новой строки \N,  скрупулезно добавленным  к  каждой
выписанной строке.
 
    MAIN()  /* COUNT LINES IN INPUT */
    {
        INT C,NL;
 
        NL = 0;
        WHILE ((C = GETCHAR()) != EOF)
       IF (C =='\N')
           ++NL;
        PRINTF("%D\N", NL);
    }
 
    Тело WHILE  теперь содержит оператор IF ,  который в свою
очередь управляет оператором увеличения  ++NL.   Оператор  IF
проверяет заключенное   в круглые скобки условие и,  если оно
истинно, выполняет  следующий за  ним  оператор  /или  группу
операторов, заключенных     в  фигурные  скобки/.   Мы  опять
использовали сдвиг вправо, чтобы показать, что чем управляет.
    Удвоенный знак равенства == является обозначением в языке
"C" для "равно" /аналогично .EQ.  В фортране/.   Этот  символ
введен для   того,   чтобы  отличать проверку на равенство от
одиночного =,  используемого при присваивании.   Поскольку  в
типичных "C"   -  программах  знак  присваивания  встречается
примерно в два раза чаще,  чем  проверка  на  равенство,   то
естественно, чтобы знак оператора был вполовину короче.
    Любой отдельный   символ   может   быть   записан  внутри
одиночных кавычек,  и при этом  ему  соответствует  значение,
равное численному   значению  этого символа в машинном наборе
символов; это   называется   символьной   константой.    Так,
например, 'A'    - символьная константа; ее значение в наборе
символов ASCII   /американский  стандартный  код  для  обмена
информацией/ равно  65,  внутреннему представлению символа а.
Конечно, 'A'  предпочтительнее,  чем 65: его смысл очевиден и
он не зависит от конкретного машинного набора символов.
    Условные последовательности,   используемые  в символьных
строках, также   занимают  законное  место  среди  символьных
констант. Так    в проверках и арифметических выражениях '\N'
представляет значение символа новой строки.  Вы должны твердо
уяснить, что   '\N' - отдельный символ,  который в выражениях
эквивалентен одиночному целому; с другой стороны "\N"  -  это
символьная строка,    которая  содержит  только  один символ.
Вопрос о сопоставлении строк и символов обсуждается  в  главе
2.
    Упражнение 1-6.
    ----------------
    Напишите программу для подсчета пробелов, табуляций и новых строк.
    Упражнение 1-7.
    ----------------
    Напишите программу,   которая  копирует  ввод  на  вывод,
заменяя при этом  каждую  последовательность  из  одного  или
более пробелов на один пробел.

     
     
     
     
     
     
               1.5.5. Подсчёт слов.
 
    Четвертая программа  из  нашей  серии  полезных  программ
подсчитывает количество строк, слов и символов, используя при
этом весьма   широкое определение,  что словом является любая
последовательность символов,      не   содержащая   пробелов,
табуляций или  новых строк.  /Это - упрощенная версия утилиты
'WC' системы 'UNIX'/
 
    #DEFINE    YES  1
    #DEFINE    NO   0
 
    MAIN()  /* COUNT LINES, WORDS, CHARS IN INPUT */
    {
       INT C, NL, NW, INWORD;
 
       INWORD = NO;
       NL = NW = NC = 0;
       WHILE((C = GETCHAR()) != EOF)  {
           ++NC;
           IF (C == '\N')
                ++NL;
           IF (C==' ' \!\! C=='\N' \!\! C=='\T')
                INWORD = NO;
           ELSE IF (INWORD == NO)  {
                INWORD = YES;
                ++NW;
           }
       }
       PRINTF("%D %D %D\N", NL, NW, NC);
    }
 
    Каждый раз,   когда  программа  встречает  первый  символ
слова, она    увеличивает  счетчик  числа  слов  на  единицу.
Переменная INWORD следит за тем,  находится  ли  программа  в
настоящий момент     внутри   слова  или  нет;  сначала  этой
переменной присваивается " не в слове",   чему  соответствует
значение NO. Мы предпочитаем символические константы YES и NO
литерным значениям 1 и 0,  потому что  они  делают  программу
более удобной   для  чтения.   Конечно,   в  такой  крошечной
программе, как  эта, это не приводит к заметной разнице, но в
больших программах    увеличение  ясности  вполне  стоит  тех
скромных дополнительных усилий,  которых  требует  следование
этому принципу   с  самого начала.  Вы также обнаружите,  что
существенные изменения гораздо легче вносить в те  программы,
где числа фигурируют только в качестве символьных констант.
    Строка
 
       NL = NW = NC = 0;
 
полагает все три переменные  равными  нулю.   Это  не  особый
случай, а    следствие  того  обстоятельства,   что оператору
присваивания соответствует некоторое значение и  присваивания
проводятся последовательно справа налево. Таким образом, дело
обстоит так, как если бы мы написали
 
        NC = (NL = (NW = 0));
 
операция \!\! Означает   OR  , так что строка
 
        IF( C==' ' \!\! C=='\N' \!\! C=='\T')
 
говорит "если с - пробел,  или с - символ новой строки, или с
-табуляция ..."./условная   последовательность  \T   является
изображением символа табуляции/.
    Имеется соответствующая операция && для AND.   Выражения,
связанные операциями && или \!\!  ,  Рассматриваются слева на
право, и  при этом гарантируется,  что  оценивание  выражений
будет прекращено,    как только станет ясно,  является ли все
выражение истинным или ложным.  Так,   если  'C'  оказывается
пробелом, то нет никакой необходимости проверять, является ли
'C' символом новой строки или табуляции,   и  такие  проверки
действительно не   делаются.   В  данном  случае это не имеет
принципиального значения,  но,  как мы скоро увидим,  в более
сложных ситуациях эта особенность языка весьма существенна.
    Этот пример  также демонстрирует оператор ELSE языка "C",
который указывает то действие,  которое  должно  выполняться,
если условие, содержащееся в операторе IF, окажется ложным.
    Общая форма такова:
 
    IF (выражение)
    оператор-1
    ELSE оператор-2
 
    Выполняется один  и  только  один  из  двух   операторов,
связанных с   конструкцией  IF-ELSE.  Если выражение истинно,
выполняется оператор-1; если нет  -  выполняется  оператор-2.
Фактически каждый   оператор  может быть довольно сложным.  В
программе подсчета   слов  оператор,   следующий  за  ELSE  ,
является опертором IF , который управляет двумя операторами в
фигурных скобках.
    Упражнение 1-9.
    ----------------
    Как бы вы стали проверять программу подсчета слов ?
    Kакие имеются ограничения ?
    Упражнение  1-10.
    -----------------
    Напишите программу, которая будет печатать слова из файла
ввода, причём по одному на строку.
    Упражнение 1-11.
    ----------------
    Переделайте программу подсчета  слов,   используя  лучшее
пределение "слова";         считайте,      например    словом
последовательность букв,  цифр и апострофов,  начинающуюся  с
буквы.

     
     
     
     
     
20 78 2 7
3 3 1 19 78 3 0
4 3 1 18 78 4 7
5 3 1 17 78 6 8
6 3 1 16 78 2 7
7 3 1 15 78 0 7
8 3 1 14 78 2 7
9 3 1 13 78 0 7
10 9 19 8 42 0 7
     
     
                   1.6. Массивы.
 
    Давайте напишем программу подсчета числа появлений каждой
цифры, символов  пустых промежутков/пробел,  табуляции, новая
строка/ и всех остальных символов.   Конечно,   такая  задача
несколько искусственна, но она позволит нам проиллюстрировать
в одной программе сразу несколько аспектов языка "C".
    Мы разбили  вводимые  символы на двенадцать категорий,  и
нам удобнее использовать массив для хранения числа  появлений
каждой цифры,  а не десять отдельных переменных.  Вот один из
вариантов программы:
 
    MAIN()  /* COUNT DIGITS, WHITE SPACE, OTHERS */
    {
        INT  C, I, NWHITE, NOTHER;
        INT  NDIGIT[10];
 
        NWHITE = NOTHER = 0;
        FOR (I = 0; I < 10; ++I)
     NDIGIT[I] = 0;
 
        WHILE ((C = GETCHAR()) != EOF)
     IF (C >= '0' && C <= '9')
         ++NDIGIT[C-'0'];
     ELSE IF(C== ' ' \!\! C== '\N' \!\! C== '\T')
         ++NWHITE;
     ELSE
         ++NOTHER;
 
        PRINTF("DIGITS =");
        FOR (I = 0; I < 10; ++I)
        PRINTF(" %D", NDIGIT[I]);
        PRINTF("\NWHITE SPACE = %D, OTHER = %D\N",
         NWHITE, NOTHER);
    }
 
    Описание
 
       INT  NDIGIT[10];
 
объявляет, что  NDIGIT  является массивом из десяти целых.  в
языке "C" индексы массива всегда начинаются с нуля /а не с 1,
как в фортране или PL/1/, так что элементами массива являются
NDIGIT[0], NDIGIT[1],..., NDIGIT[9]. эта особенность отражена
в циклах FOR , которые инициализируют и печатают массив.
    Индекс может  быть  любым  целым  выражением,    которое,
конечно, может   включать целые переменные,  такие как I ,  и
целые константы.
    Эта конкретная программа  сильно  опирается  на  свойства
символьного представления цифр.  Так,  например,  в программе
проверка
 
       IF( C >= '0' && C <= '9')...
 
определяет, является ли символ в 'C' цифрой,  и если это так,
то численное значение этой цифры определяется по формуле /  C
- '0'/.    Такой  способ  работает только в том случае,  если
значения символьных констант '0',  '1' и т.д.   Положительны,
расположены в  порядке возрастания и нет ничего,  кроме цифр,
между константами '0' и '9'.  К счастью,  это верно для  всех
общепринятых наборов символов.
    По определению перед проведением арифметических операций,
вовлекающих переменные типа CHAR и INT, все они преобразуются
к типу   INT,  TAK что в арифметических выражениях переменные
типа CHAR по существу идентичны  переменным  типа  INT.   Это
вполне естественно   и  удобно;  например,  C -'0'- это целое
выражение со значением между 0 и  9  в  соответствии  с  тем,
какой символ от '0' до '9' хранится в 'C',  и, следовательно,
оно является подходящим индексом для массива NDIGIT.
    Выяснение вопроса,  является  ли  данный  символ  цифрой,
символом пустого промежутка или чем-либо еще,  осуществляется
последовательностью операторов
 
     IF (C >= '0' && C <= '9')
     ++NDIGIT[C-'0'];
     ELSE IF(C == ' ' \!\! C == '\N' \!\! C == '\T')
     ++NWHITE;
     ELSE
     ++NOTHER;
 
    Конструкция
      IF  (условие)
              оператор
      ELSE IF  (условие)
              оператор
      ELSE
              оператор
      
часто встречаются   в   программах   как  средство  выражения
ситуаций, в которых осуществляется выбор одного из нескольких
возможных решений.
    Программа просто движется сверху вниз до тех пор, пока не
удовлетворится какое-нибудь    условие;   тогда   выполняется
соответствующий 'оператор',    и вся конструкция завершается.
/Конечно, 'оператор' может состоять из нескольких операторов,
заключенных в   фигурные скобки/.  Если ни одно из условий не
удовлетворяется, то  выполняется 'оператор',   стоящий  после
заключительного ELSE,  если оно присутствует.  Если последнее
ELSE и соответствующий 'оператор' опущены  (как  в  программе
подсчета слов),   то никаких действий не производится.  Между
начальным IF и конечным ELSE  может  помещаться  произвольное
количество групп
 
    ELSE IF (условие)
       оператор
 
    С точки  зрения  стиля   целесообразно   записывать   эту
конструкцию так,    как  мы  показали,   с  тем чтобы длинные
выражения не залезали за правый край страницы.
    Оператор SWITCH (переключатель),  который рассматривается
в главе   3,   представляет  другую  возможность  для  записи
разветвления на  несколько вариантов.  этот оператор особенно
удобен, когда  проверяемое  выражение  является  либо  просто
некоторым целым,   либо символьным выражением,  совпадающим с
одной из некоторого набора констант.  Версия этой  программы,
использующая оператор SWITCH, будет для сравнения приведена в
главе 3.
 
    Упражнение 1-12.
    ----------------
 
    Напишите программу,  печатающую гистограмму длин слов  из
файла ввода.      Самое   легкое   -   начертить  гистограмму
горизонтально; вертикальная    ориентация   требует   больших
усилий.

     
     
     
     
      
     
                 1.7. Функции.
 
    В языке  "C"  функции  эквивалентны   подпрограммам   или
функциям в   фортране  или процедурам в PL/1,  паскале и т.д.
Функции дают   удобный  способ  заключения  некоторой   части
вычислений в    черный  ящик,   который  в  дальнейшем  можно
использовать, не   интересуясь  его  внутренним  содержанием.
Использование функций     является   фактически  единственным
способом справиться   с  потенциальной   сложностью   больших
программ. Если функции организованы должным образом, то можно
игнорировать то, как делается работа; достаточно знание того,
что делается.    Язык  "C"  разработан  таким образом,  чтобы
сделать использование функций легким,  удобным и эффективным.
Вам будут  часто встречаться функции длиной всего в несколько
строчек, вызываемые  только один  раз,   и  они  используются
только потому, что это проясняет некоторую часть программы.
    До сих пор мы  использовали  только  предоставленные  нам
функции типа PRINTF,  GETCHAR и PUTCHAR; теперь пора написать
несколько наших собственных.  так  как  в  "C"  нет  операции
возведения в степень, подобной операции ** в фортране или PL/
1, давайте  проиллюстрируем механику определения  функции  на
примере функции   POWER(M,N),   возводящей  целое  м  в целую
положительную степень N.  Так значение POWER(2,5)  равно  32.
Конечно, эта    функция не выполняет всей работы операции **,
поскольку она действует  только  с  положительными  степенями
небольших чисел,     но  лучше  не  создавать  дополнительных
затруднений, смешивая несколько различных вопросов.
    Ниже приводится функция POWER и использующая ее  основная
программа, так что вы можете видеть целиком всю структуру.
 
     MAIN()  /* TEST POWER FUNCTION */
     {
        INT I;
 
        FOR(I = 0; I < 10; ++I)
        PRINTF("%D %D %D\N",I,POWER(2,I),POWER(-3,I));
     }
 
     POWER(X,N)  /* RAISE  X  N-TH POWER; N > 0  */
     INT X,N;
     {
        INT I, P;
        P = 1;
        FOR (I =1; I <= N; ++I)
        P = P * X;
        RETURN (P);
     }
 
    Все функции имеют одинаковый вид:
     имя (список аргументов, если они имеются)
     описание аргументов, если они имеются
     {
     описания
        операторы
     }
 
 
    Эти функции  могут  быть  записаны  в  любом  порядке   и
находиться в  одном или двух исходных файлах.  Конечно,  если
исходная программа размещается в двух файлах,   вам  придется
дать больше  указаний при компиляции и загрузке,  чем если бы
она находилась в одном,  но это дело операционной системы,  а
не атрибут   языка.   В  данный  момент,   для того чтобы все
полученные сведения о прогоне "C"- программ,  не изменились в
дальнейшем, мы  будем предполагать, что обе функции находятся
в одном и том же файле.
    Функция POWER вызывается дважды в строке
 
    PRINTF("%D %D %D\N",I,POWER(2,I),POWER(-3,I));
 
при каждом обращении функция POWER,  получив  два  аргумента,
вазвращает целое   значение,   которое  печатается в заданном
формате. В  выражениях POWER(2,I)  является  точно  таким  же
целым, как  2 и I.  /Не все функции выдают целое значение; мы
займемся этим вопросом в главе 4/.
    Аргументы функции    POWER    должны     быть     описаны
соответствующим образом,    так  как  их  типы известны.  Это
сделано в строке
 
    INT X,N;
 
которая следует за именем функции.
    Описания аргументов помещаются между списком аргументов и
открывающейся левой     фигурной   скобкой;  каждое  описание
заканчивается точкой с запятой.  Имена,   использованные  для
аргументов функции    POWER,   являются  чисто  локальными  и
недоступны никаким другим функциям:  другие  процедуры  могут
использовать те   же самые имена без возникновения конфликта.
Это верно и для переменных I и P; I в функции POWER никак  не
связано с I в функции MAIN.
    Значение, вычисленное функцией POWER, передаются в MAIN с
помощью оператора RETURN, точно такого же, как в PL/1. внутри
круглых скобок   можно  написать любое выражение.  Функция не
обязана возвращать какое-либо значение; оператор RETURN,   не
содержащий никакого  выражения,  приводит к такой же передаче
управления, как  "сваливание на конец" функции при достижении
конечной правой   фигурной  скобки,  но при этом в вызывающую
функцию не возвращается никакого полезного значения.
    Упражнение 1-13.
    ----------------
    Напишите программу преобразования прописных букв из файла
ввода в строчные, используя при этом функцию OWER(C), которая
возвращает значение 'C',  если  C'-  не  буква,   и  значение
соответствующей строчной буквы, если 'C'-буква.

     
     
     
     
     
     
                1.8. Аргументы - вызов по значению.
 
    Один аспект   в   "C"  может  оказаться  непривычным  для
программистов, которые    использовали   другие   языки,    в
частности, фортран  и PL/1. в языке "C" все аргументы функций
передаются "по значению". это означает, что вызванная функция
получает значения    своих  аргументов  с  помощью  временных
переменных /фактически через стек/,  а  не  их  адреса.   Это
приводит к   некоторым  особенностям,   отличным  от  тех,  с
которыми мы сталкивались  в  языках  типа  фортрана  и  PL/1,
использующих "вызов   по  ссылке  ",  где вызванная процедура
работает с адресом аргумента, а не с его значением.
    Главное отличие состоит  в  том,   что  в  "C"  вызванная
функция не   может изменить переменную из вызывающей функции;
она может менять только свою собственную временную копию.
    Вызов по  значению,  однако,  не помеха,  а весьма ценное
качество. Оно  обычно приводит к более компактным программам,
содержащим меньше   не относящихся к делу переменных,  потому
что с     аргументами   можно   обращаться   как   с   удобно
инициализированными локальными        перемнными    вызванной
процедуры. Вот,  например, вариант функции POWER использующей
это обстоятельство
 
     POWER(X,N)  /* RAISE  X  N-TH POWER; N > 0;
               VERSION 2 */
     INT X,N;
     {
     INT P;
 
     FOR (P = 1; N > 0; --N)
          P = P * X;
     RETURN (P);
     }

    Аргумент N используется как временная переменная; из него
вычитается единица до тех пор,   пока  он  не  станет  нулем.
Переменная I здесь больше не нужна.  чтобы ни происходило с N
внутри POWER это никак не  влияет  на  аргумент,   с  которым
первоначально обратились к функции POWER.
    При необходимости все же можно добиться,   чтобы  функция
изменила переменную   из вызывающей программы.  Эта программа
должна обеспечить установление адреса переменной /технически,
через указатель  на переменную/,  а в вызываемой функции надо
описать соответствующий аргумент как указатель и ссылаться  к
фактической переменной косвенно через него. Мы рассмотрим это
подробно в главе 5.
    Когда в качестве аргумента  выступает  имя  массива,   то
фактическим значением,  передаваемым функции,  является адрес
начала массива.  /Здесь нет  никакого  копирования  элементов
массива/. С  помощью индексации и адреса начала функция может
найти и изменить любой элемент массива. Это - тема следующего
раздела.

     
     
     
                                          
     
     
                       1.9. Массивы символов.
 
    По-видимому самым общим  типом  массива  в  "C"  является
массив символов.      Чтобы  проиллюстрировать  использование
массивов символов   и  обрабатывающих  их  функций,   давайте
напишем программу,    которая  читает  набор строк и печатает
самую длинную из них.  Основная  схема  программы  достаточно
проста:
 
     WHILE (имеется еще строка)
       IF (эта строка длиннее самой длинной из предыдущих)
          запомнить эту строку и ее длину
      напечатать самую длинную строку
      
    По этой  схеме  ясно,  что программа естественным образом
распадается на несколько частей.   Одна  часть  читает  новую
строку, другая  проверяет ее,  третья запоминает, а остальные
части программы управляют этим процессом.
    Поскольку все  так  прекрасно  делится,  было бы хорошо и
написать программу соответсвующим образом.   Давайте  сначала
напишем отдельную   функцию GETLINE,  которая будет извлекать
следующую строку из файла  ввода;  это  -  обобщение  функции
GETCHAR. мы    попытаемся  сделать эту функцию по возможности
более гибкой,  чтобы она была полезной и в других  ситуациях.
Как минимум   GETLINE  должна  передавать  сигнал о возможном
появлении конца файла; более общий полезный  вариант  мог  бы
передавать длину   строки  или  нуль,   если встретится конец
файла. нуль  не может быть длиной  строки,   так  как  каждая
строка содержит   по  крайней  мере один символ; даже строка,
содержащая только символ новой строки, имеет длину 1.
    Когда мы находим строку, которая длиннее самой длинной из
предыдущих, то ее надо где-то запомнить. Это наводит на мысль
о другой функции,  COPY ,   которая  будет  копировать  новую
строку в место хранения.
    Наконец, нам  нужна  основная  программа  для  управления
функциями GETLINE и COPY . Вот результат :
 
    #DEFINE  MAXLINE  1000 /* MAXIMUM INPUT LINE SIZE */
     MAIN()  /* FIND LONGEST LINE */
     {
     INT LEN; /* CURRENT LINE LENGTH */
     INT MAX; /* MAXIMUM LENGTH SEEN SO FAR */
     CHAR LINE[MAXLINE]; /* CURRENT INPUT LINE */
     CHAR SAVE[MAXLINE]; /* LONGEST LINE, SAVED */
 
     MAX = 0;
     WHILE ((LEN = GETLINE(LINE, MAXLINE)) > 0)
         IF (LEN > MAX) {
        MAX = LEN;
        COPY(LINE, SAVE);
         }
         IF (MAX > 0)   /* THERE WAS A LINE */
        PRINTF("%S", SAVE);
     }
 
     GETLINE(S,LIM) /* GET LINE INTO S,RETURN LENGTH */
     CHAR S[];
     INT LIM;
     {
        INT C, I;
 
        FOR(I=0;I<LIM-1 && (C=GETCHAR())!=EOF && C!='\N';++I)
        S[I] = C;
        IF (C == '\N')  {
       S[I] = C;
      ++I;
        }
        S[I] = '\0';
        RETURN(I);
     }
 
     COPY(S1, S2)    /* COPY S1 TO S2;
                   ASSUME S2 BIG ENOUGH */
     CHAR S1[], S2[];
     {
     INT I;
 
     I = 0;
     WHILE ((S2[I] = S1[I] != '\0')
        ++I;
     }
     
    Функция MAIN   и   GETLINE   общаются   как   через  пару
аргументов, так  и через  возвращаемое  значение.   аргументы
GETLINE описаны в строках
 
     CHAR S[];
     INT LIM;
 
которые указывают,  что первый аргумент является массивом,  а
второй - целым.
    Длина массива S не указана, так как она определена в MAIN
. функция  GETLINE использует оператор  RETURN  для  передачи
значения назад  в вызывающую программу точно так же,  как это
делала функция  POWER.   Одни  функции  возвращают  некоторое
нужное значение; другие,  подобно COPY, используются из-за их
действия и не возвращают никакого значения.
    Чтобы пометить конец строки  символов,   функция  GETLINE
помещает в   конец создаваемого ей массива символ \0 /нулевой
символ, значение    которого  равно  нулю/.   Это  соглашение
используется также   компилятором с языка "C":  когда в "C" -
программе встречается строчная константа типа
 
    "HELLO\N"
 

то компилятор создает массив  символов,   содержащий  символы
этой строки,    и  заканчивает  его символом \0,  с тем чтобы
функции, подобные  PRINTF, могли зафиксировать конец массива:
 
         -------------------------------------------
          !  H !  E  !  L  !  L  !  O  ! \N  ! \0 !
         -------------------------------------------
 
    Спецификация формата %S указывает,   что  PRINTF  ожидает
строку, представленную в такой форме. Проанализировав функцию
COPY, вы  обнаружите, что и она опирается на тот факт, что ее
входной аргумент   оканчивается символом \0,  и копирует этот
символ в выходной аргумент S2.  /Все это подразумевает,   что
символ \0 не является частью нормального текста/.
    Между прочим,  стоит отметить, что даже в такой маленькой
программе, как      эта,    возникает   несколько  неприятных
организационных проблем.  Например,  что должна делать  MAIN,
если она     встретит  строку,   превышающую  ее  максимально
возможный размер?  Функция GETLINE  поступает  разумно:   при
заполнении массива    она  прекращает  дальнейшее  извлечение
символов, даже   если  не  встречает  символа  новой  строки.
Проверив полученную   длину и последний символ,  функция MAIN
может установить,  не была ли эта строка слишком длинной,   и
поступить затем,    как она сочтет нужным.  Ради краткости мы
опустили эту проблему.  Пользователь функции GETLINE никак не
может заранее   узнать,   насколько длинной окажется вводимая
строка. Поэтому в GETLINE включен контроль переполнения. в то
же время   пользователь  функции  COPY  уже  знает /или может
узнать/, каков размер строк, так что мы предпочли не включать
в эту функцию дополнительный контроль.
    Упражнение 1-14.
    -----------------
    Переделайте ведущую часть программы поиска самой  длинной
строки таким   образом,   чтобы  она правильно печатала длины
сколь угодно длинных вводимых строк и возможно больший текст.
    Упржнение 1-15.
    -----------------
  Напишите программу печати всех строк длиннее 80 символов.
    Упражнение 1-16.
    -----------------
  Напишите программу,  которая будет удалять из каждой строки
стоящие в конце пробелы и табуляции,  а также строки, целиком
состоящие из пробелов.
    Упражнение  1-17.
    -----------------
    Напишите функцию    REVERSE(S),     которая   распологает
символьную строку S в обратном порядке. С ее помощью напишите
программу, которая обратит каждую строку из файла ввода.

     
     
     
     
             1.10. Область действия: внешние переменные.
 
    Переменные в MAIN(LINE, SAVE и т.д.) являются внутренними
или локальными по отношению к функции MAIN,  потому  что  они
описаны внутри   MAIN и никакая другая функция не имеет к ним
прямого доступа.  Это же верно и  относительно  переменных  в
других функциях;   например,   переменная I в функции GETLINE
никак не связана с I в  COPY.   Каждая  локальная  переменная
существует только     тогда,   когда  произошло  обращение  к
соответствующей функции,  и исчезает,  как только  закончится
выполнение этой   функции.  По этой причине такие переменные,
следуя терминологии     других   языков,    обычно   называют
автоматическими. Мы      впредь   будем  использовать  термин
автоматические при   ссылке  на  эти  динамические  локальные
переменные. /в  главе 4 обсуждается класс статической памяти,
когда локальные переменные все  же  оказываются  в  состоянии
сохранить свои значения между обращениями к функциям/.
    Поскольку автоматические переменные появляются и исчезают
вместе с   обращением  к  функции,   они  не  сохраняют своих
значений в промежутке от одного вызова до  другого,   в  силу
чего им   при  каждом  входе нужно явно присваивать значения.
Если этого не сделать, то они будут содержать мусор.
    В качестве альтернативы к автоматическим переменным можно
определить переменные,    которые  будут  внешними  для  всех
функций, т.е.     Глобальными  переменными,   к которым может
обратиться по имени  любая  функция,   которая  пожелает  это
сделать. (этот механизм весьма сходен с "COMMON" в фортране и
"EXTERNAL" в PL/1).   Так  как  внешние  переменные  доступны
всюду, их    можно  использовать вместо списка аргументов для
передачи данных  между  функциями.   Кроме  того,   поскольку
внешние переменные   существуют постоянно,  а не появляются и
исчезают вместе с вызываемыми функциями,  они сохраняют  свои
значения и   после  того,   как  функции,  присвоившие им эти
значения, завершат свою работу.
    Внешняя переменная   должна   быть  определена  вне  всех
функций; при этом ей выделяется фактическое место  в  памяти.
Такая переменная  должна быть также описана в каждой функции,
которая собирается ее использовать; это  можно  сделать  либо
явным описанием   EXTERN,   либо неявным по контексту.  Чтобы
сделать обсуждение   более  конкретным,   давайте   перепишем
программу поиска  самой длинной строки,  сделав LINE,  SAVE и
MAX внешними переменными.  Это потребует изменения описаний и
тел всех трех функций, а также обращений к ним.
 
    #DEFINE MAXLINE 1000   /* MAX. INPUT LINE SIZE*/
 
    CHAR   LINE[MAXLINE];  /* INPUT LINE */
    CHAR   SAVE[MAXLINE];/* LONGEST LINE SAVED HERE*/
    INT   MAX;/*LENGTH OF LONGEST LINE SEEN SO FAR*/
 
    MAIN()  /*FIND LONGEST LINE; SPECIALIZED VERSION*/
    {
       INT     LEN;
       EXTERN  INT   MAX;
       EXTERN  CHAR   SAVE[];
       MAX = 0;
 
    WHILE ( (LEN = GETLINE()) > 0 )
       IF ( LEN > MAX )  {
               MAX = LEN;
               COPY();
       }
    IF ( MAX > 0 )  /* THERE WAS A LINE */
       PRINTF( "%S", SAVE );
    }
 
    GETLINE()       /* SPECIALIZED VERSION */
    {
       INT C, I;
       EXTERN CHAR LINE[];
 
       FOR (I = 0; I < MAXLINE-1
                && (C=GETCHAR()) !=EOF && C!='\N'; ++I)
                LINE[I] = C;
         ++I;
        }
        LINE[I] = '\0'
        RETURN(I)
     }
     COPY()  /* SPECIALIZED VERSION */
     {
        INT I;
        EXTERN CHAR LINE[], SAVE[];
 
        I = 0;
        WHILE ((SAVE[I] = LINE[I]) !='\0')
                ++I;
     }
     
    Внешние переменные  для  функций  MAIN,   GETLINE  и COPY
определены в   первых  строчках  приведенного  выше  примера,
которыми указывается   их  тип и вызывается отведение для них
памяти. синтаксически  внешние описания точно такие же,   как
описания, которые    мы  использовали  ранее,  но так как они
расположены вне функций,  соответствующие переменные являются
внешними. Чтобы функция могла использовать внешнюю переменую,
ей надо сообщить ее имя. Один способ сделать это - включить в
функцию описание     EXTERN;   это   описание  отличается  от
предыдущих только добавлением ключевого слова EXTERN.
    В определенных  ситуациях  описание  EXTERN  может   быть
опущено: если  внешнее определение переменной находится в том
же исходном  файле,   раньше  ее  использования  в  некоторой
конкретной функции,    то  не  обязательно  включать описание
EXTERN для этой переменной в саму функцию.  Описания EXTERN в
функциях MAIN,    GETLINE  и  COPY  являются,  таким образом,
излишними. Фактически,     обычная  практика  заключается   в
помещении определений    всех  внешних  переменных  в  начале
исходного файла и последующем опускании всех описаний EXTERN.
    Если программа находится в нескольких исходных файлах,  и
некоторая переменная   определена,   скажем  в  файле  1,   а
используется в файле 2,  то чтобы связать эти  два  вхождения
переменной, необходимо    в  файле  2  использовать  описание
EXTERN. Этот вопрос подробно обсуждается в главе 4.
    Вы должно быть заметили, что мы в этом разделе при ссылке
на внешние   переменные  очень  аккуратно  используем   слова
описание и определение. "Определение" относится к тому месту,
где переменная фактически заводится и ей  выделяется  память;
"описание" относится   к тем местам,  где указывается природа
переменной, но никакой памяти не отводится.
    Между прочим,  существует тенденция объявлять все, что ни
попадется, внешними  переменными,  поскольку кажется, что это
упрощает связи,  -  списки  аргументов  становятся  короче  и
переменные всегда     присутствуют,   когда  бы  вам  они  ни
понадобились. Но  внешние переменные  присутствуют  и  тогда,
когда вы   в них не нуждаетесь.  Такой стиль программирования
чреват опасностью,  так как он приводит к программам,   связи
данных внутри которых не вполне очевидны. Переменные при этом
могут изменяться неожиданным и даже неумышленным образом,   а
программы становится  трудно модифицировать,  когда возникает
такая необходимость.  Вторая версия  программы  поиска  самой
длинной строки   уступает первой отчасти по этим причинам,  а
отчасти потому,  что она лишила  универсальности  две  весьма
полезные функции,   введя в них имена переменных,  с которыми
они будут манипулировать.
    Упражнение 1-18.
    ---------------
    Проверка в   операторе   FOR   функции  GETLINE  довольно
неуклюжа. Перепишите  программу таким образом,  чтобы сделать
эту проверку  более ясной,  но сохраните при этом то же самое
поведение в конце файла и при переполнении буфера.   Является
ли это поведение самым разумным?

     
     
     
     
     
                                                                                            
     
     
                  1.11. Резюме
 
    На данном этапе мы обсудили то,   что  можно  бы  назвать
традиционным ядром   языка "C".  Имея эту горсть строительных
блоков, можно  писать полезные программы весьма значительного
размера, и    было  бы  вероятно  неплохой идеей,  если бы вы
задержались здесь   на  какое-то  время  и  поступили   таким
образом: следующие     ниже  упражнения  предлагают  вам  ряд
программ несколько большей сложности,  чем те,  которые  были
приведены в этой главе.
    После того как вы овладеете этой частью "C",  приступайте
к чтению следующих нескольких глав.  Усилия,  которые вы  при
этом затратите,  полностью окупятся, потому что в этих главах
обсуждаются именно те стороны "C", где мощь и выразительность
языка начинает становиться очевидной.
    Упражнение 1-19.
    ---------------
    Напишите программу DETAB,  которая заменяет табуляции  во
вводе на нужное число пробелов так, чтобы промежуток достигал
следующей табуляционной остановки. Предположите фиксированный
набор табуляционных   остановок,   например,   через каждые N
позиций.
    Упражнение 1-20.
    ----------------
    Напишите программу  ENTAB,    которая   заменяет   строки
пробелов минимальным   числом табуляций и пробелов,  достигая
при этом   тех  же  самых  промежутков.   Используйте  те  же
табуляционные остановки, как и в DETAB.
    Упражнение 1-21.
    ----------------
    Напишите программу  для "сгибания" длинных вводимых строк
после последнего отличного от пробела символа,   стоящего  до
столбца N   ввода,   где  N - параметр.  убедитесь,  что ваша
программа делает что-то разумное с очень длинными строками  и
в случае, когда перед указанным столбцом нет ни табуляций, ни
пробелов.
    Упражнение 1-22.
    ----------------
    Напишите программу   удаления   из   "C"-программы   всех
комментариев. Не       забывайте   аккуратно   обращаться   с
"закавыченными" строками и символьными константами.
    Упражнение 1-23.
    ----------------
    Напишите программу проверки "C"-программы на элементарные
синтаксические ошибки,   такие  как  несоответствие  круглых,
квадратных и   фигурных скобок.  Не забудьте о кавычках,  как
одиночных, так  и двойных,  и о комментариях.  (Эта программа
весьма сложна,    если  вы будете писать ее для самого общего
случая).
                                                                                                                                                                                                              



           2. Типы, операции и выражения.

    Переменные и  константы  являются основными объектами,  с
которыми оперирует     программа.     Описания    перечисляют
переменные, которые будут использоваться, указывают их тип и,
возможно, их  начальные значения.  Операции определяют, что с
ними будет    сделано.   выражения  объединяют  переменные  и
константы для получения  новых  значений.   Все  это  -  темы
настоящей главы.








             2.1. Имена переменных.

    Хотя мы  этого  сразу  прямо  не   сказали,    существуют
некоторые ограничения   на  имена  переменных и символических
констант. Имена  составляются из букв и цифр;  первый  символ
должен быть буквой.  Подчеркивание "_" тоже считается буквой;
это полезно  для  удобочитаемости  длинных  имен  переменных.
Прописные и строчные буквы различаются; традиционная практика
в "C" - использовать строчные буквы для имен  переменных,   а
прописные - для символических констант.
    Играют роль  только  первые  восемь  символов внутреннего
имени, хотя  использовать можно и больше.  Для внешних  имен,
таких как имена функций и внешних переменных, это число может
оказаться меньше восьми,  так как внешние имена  используются
различными ассемблерами  и загрузчиками.  Детали приводятся в
приложении а.  Кроме того, такие ключевые слова как IF, ELSE,
INT, FLOAT и т.д., зарезервированы: вы не можете использовать
их в   качестве  имен  переменных.   (Они  пишутся  строчными
буквами).
    Конечно, разумно выбирать имена переменных таким образом,
чтобы они     означали   нечто,    относящееся  к  назначению
переменных, и  чтобы  было  менее  вероятно  спутать  их  при
написании.

     
     
     
     
     
    
   
   
   
                                     
     
     
            2.2. Типы и размеры данных.
 
    Языке "C" имеется только несколько основных типов данных:
   CHAR один байт,  в котором может находиться один символ из
   внутрен
       него набора символов.
   INT Целое,   обычно  соответствующее естественному размеру
       целых в используемой машине.
   FLOAT С плавающей точкой одинарной точности.
   DOUBLE С плавающей точкой двойной точности.
    Кроме того  имеется  ряд  квалификаторов,   которые можно
использовать с типом INT:  SHORT (короткое), LONG (длинное) и
UNSIGNED (без знака). Квалификаторы SHORT и LONG указывают на
различные размеры целых.  Числа без знака подчиняются законам
арифметики по   модулю  2 в степени N,  где N - число битов в
INT; числа   без  знаков  всегда  положительны.   Описания  с
квалификаторами имеют вид:
 
    SHORT INT X;
    LONG INT Y;
    UNSIGNED INT Z;
 
    Cлово INT в таких  ситуациях  может  быть  опущено,   что
обычно и делается.
    Количество битов,  отводимых под эти объекты  зависит  от
имеющейся машины;     в   таблице  ниже  приведены  некоторые
характерные значения.
 
            Таблица 1
   ---------------------------------------------------------
   !      DEC PDP-11   HONEYWELL    IBM 370     INTERDATA  !
   !                                6000          8/32     !
   !                                                       !
   !          ASCII       ASCII       EBCDIC      ASCII    !
   !                                                       !
   ! CHAR     8-BITS      9-BITS      8-BITS      8-BITS   !
   ! INT      16          36           32         32       !
   ! SHORT    16          36           16         16       !
   ! LONG     32          36           32         32       !
   ! FLOAT    32          36           32         32       !
   ! DOUBLE   64          72           64         64       !
   !                                                       !
   ---------------------------------------------------------
 
    Цель состоит в том, чтобы SHORT и LONG давали возможность
в зависимости   от  практических  нужд использовать различные
длины целых; тип INT отражает наиболее "естественный"  размер
конкретной машины.  Как вы видите, каждый компилятор свободно
интерпретирует SHORT   и  LONG  в  соответствии   со   своими
аппаратными средствами.    Все,   на  что  вы  можете  твердо
полагаться, это то, что SHORT не длиннее, чем LONG.

     
     
     
     
     
                                                                      
     
     
     
               2.3. Константы.
 
    Константы типа  INT  и FLOAT мы уже рассмотрели.  Отметим
еще только, что как обычная
 
    123.456е-7,
 
    так и "научная" запись
 
    0.12е3
 
    для FLOAT является законной.
    Каждая константа с плавающей точкой считается имеющей тип
DOUBLE, так  что обозначение "E" служит как для FLOAT,  так и
для DOUBLE.
    Длинные константы записываются в виде 123L. Обычная целая
константа, которая      слишком   длинна   для   типа    INT,
рассматривается как LONG.
    Существует система   обозначений   для   восьмеричных   и
шестнадцатеричных констант:  лидирующий 0(нуль)  в  константе
типа INT   указывает  на  восьмеричную  константу,  а стоящие
впереди 0X     соответствуют   шестнадцатеричной   константе.
Например, десятичное    число  31  можно  записать  как 037 в
восьмеричной форме    и   как   0X1F   в   шестнадцатеричной.
Шестнадцатеричные и     восьмеричные  константы  могут  также
заканчиваться буквой L,  что делает их  относящимися  к  типу
LONG.

     
     
     
     
     
     
     
     
     
             2.3.1. Символьная константа.
 
    Символьная константа  -  это  один символ,  заключенный в
одинарные кавычки,  как,  например, 'х'. Значением символьной
константы является    численное  значение  этого  символа  во
внутреннем машинном наборе  символов.   Например,   в  наборе
символов ASCII символьный нуль, или '0', имеет значение 48, а
в коде EBCDIC - 240, и оба эти значения совершенно отличны от
числа 0. Написание '0' вместо численного значения, такого как
48 или 240,  делает программу  не  зависящей  от  конкретного
численного представления   этого  символа  в  данной  машине.
Символьные константы  точно  так  же  участвуют  в  численных
операциях, как  и любые другие числа, хотя наиболее часто они
используются в   сравнении  с  другими  символами.    Правила
преобразования будут изложены позднее.
    Некоторые неграфические символы могут  быть  представлены
как символьные         константы     с    помощью    условных
последовательностей, как,   например,  \N (новая строка),  \T
(табуляция), \0  (нулевой символ), \\ (обратная косая черта),
\' (одинарная кавычка)  и т.д.  Хотя  они  выглядят  как  два
символа, на    самом деле являются одним.  Кроме того,  можно
сгенерировать произвольную последовательность двоичных знаков
размером в байт, если написать
 
    '\DDD'
 
    где DDD - от одной до трех восьмеричных цифр, как в
 
    #DEFINE  FORMFEED  '\014'  /* FORM FEED */
 
    Символьная константа  '\0',    изображающая   символ   со
значением 0,    часто записывается вместо целой константы 0 ,
чтобы подчеркнуть символьную природу некоторого выражения.

     
     
     
     
     
     
     
     
           2.3.2. Константное выражение
 
    Константное выражение - это выражение, состоящее из одних
констант. Такие выражения обрабатываются во время компиляции,
а не при прогоне  программы,   и  соответственно  могут  быть
использованы в любом месте, где можно использовать константу,
как, например в
 
    #DEFINE MAXLINE 1000
    CHAR LINE[MAXLINE+1];
 
    или
 
    SECONDS = 60 * 60 * HOURS;
 
             2.3.3. Строчная константа
 
    Строчная константа - это последовательность, состоящая из
нуля или более символов,  заключенных в двойные кавычки, как,
например,
 
    "I AM A STRING" /* я - строка */
    
    или
    
    "" /* NULL STRING */ /* нуль-строка */
 
    Кавычки не являются частью строки, а служат только для ее
ограничения. те же самые условные последовательности, которые
использовались в   символьных  константах,   применяются  и в
строках; символ двойной кавычки изображается как \".
    С технической  точки  зрения  строка  представляет  собой
массив, элементами которого являются отдельные символы. Чтобы
программам было   удобно определять конец строки,  компилятор
автоматически помещает в конец каждой строки нуль-символ  \0.
Такое представление     означает,    что   не   накладывается
конкретного ограничения  на  то,   какую  длину  может  иметь
строка, и    чтобы  определить  эту  длину,  программы должны
просматривать строку полностью.   При  этом  для  физического
хранения строки  требуется на одну ячейку памяти больше,  чем
число заключенных  в  кавычки  символов.   Следующая  функция
STRLEN(S) вычисляет    длину  символьной  строки  S не считая
конечный символ \0.
 
    STRLEN(S) /* RETURN LENGTH OF S */
    CHAR S[];
     {
        INT I;
 
        I = 0;
        WHILE (S[I] != '\0')
                ++I;
        RETURN(I);
     }
 
    Будьте внимательны  и  не путайте символьную константу со
строкой, содержащей  один символ:  'X' - это не то же  самое,
что "X".    Первое  - это отдельный символ,  использованный с
целью получения численного значения, соответствующего букве х
в машинном   наборе  символов.   Второе  - символьная строка,
состоящая из одного символа (буква х) и \0.

     
     
     
     
      
     
                 2.4. Описания
 
    Все переменные  должны  быть описаны до их использования,
хотя некоторые   описания  делаются  неявно,   по  контексту.
Описание состоит   из  спецификатора типа и следующего за ним
списка переменных, имеющих этот тип, как, например,
 
    INT LOWER, UPPER, STEP;
    CHAR C, LINE[1000];
 
    Переменные можно распределять по описаниям любым образом;
приведенные выше списки можно с тем  же  успехом  записать  в
виде
 
    INT LOWER;
    INT UPPER;
    INT STEP;
    CHAR C;
    CHAR LINE[1000];
 
    Такая форма занимает больше места,   но  она  удобна  для
добавления комментария   к каждому описанию и для последующих
модификаций.
    Переменным могут быть присвоены начальные значения внутри
их описания,  хотя здесь имеются некоторые ограничения.  Если
за именем переменной следуют знак равенства и константа,   то
эта константа     служит  в  качестве  инициализатора,   как,
например, в
 
    CHAR BACKSLASH = '\\';
    INT I = 0;
    FLOAT EPS = 1.0E-5;
 
    Если рассматриваемая   переменная  является  внешней  или
статической, то  инициализация проводится  только  один  раз,
согласно концепции      до   начала   выполнения   программы.
Инициализируемым явно   автоматическим  переменным  начальные
значения присваиваются   при  каждом  обращении к функции,  в
которой они    описаны.    Автоматические   переменные,    не
инициализируемые явно,  имеют неопределенные значения,  (т.е.
мусор). Внешние    и  статические  переменные  по   умолчанию
инициализируются нулем,     но,   тем  не  менее,   их  явная
инициализация является признаком хорошего стиля.
    Мы продолжим  обсуждение  вопросов  инициализации,  когда
будем описывать новые типы данных.

     
     
     
     
     
                                                                                                                                                                                                                                                  
     
     
     
             2.5. Арифметические операции.
 
    Бинарными арифметическими операциями являются +,  -, *, /
и операция  деления по модулю %.  Имеется унарная операция -,
но не существует унарной операции +.
    При делении целых дробная часть отбрасывается. Выражение
 
    X % Y
    
даёт остаток от деления X на Y и,  следовательно, равно нулю,
когда х   делится  на  Y  точно.   Например,   год   является
високосным, если    он  делится  на 4,  но не делится на 100,
исключая то,    что  делящиеся  на  400  годы  тоже  являются
високосными. Поэтому
 
   IF(YEAR % 4 == 0 && YEAR % 100 != 0 \!\! YEAR % 400 == 0)
        год високосный
    ELSE
        год невисокосный
 
 
  Операцию % нельзя использовать с типами FLOAT или DOUBLE.
    Операции +  и  -  имеют  одинаковое старшинство,  которое
младше одинакового уровня старшинства операций  *,   /  и  %,
которые в свою очередь младше унарного минуса. Арифметические
операции группируются слева направо.  (Сведения о старшинстве
и ассоциативности   всех  операций  собраны в таблице в конце
этой главы). Порядок выполнения ассоциативных и коммутативных
операций типа    +  и  -  не  фиксируется;  компилятор  может
перегруппировывать даже    заключенные   в   круглые   скобки
выражения, связанные    такими  операциями.   таким  образом,
а+(B+C) может  быть вычислено как (A+B)+C. Это редко приводит
к какому-либо   расхождению,   но  если необходимо обеспечить
строго определенный порядок,   то  нужно  использовать  явные
промежуточные переменные.
    Действия, предпринимаемые     при     переполнении      и
антипереполнении (т.е.    При получении слишком маленького по
абсолютной величине числа), зависят от используемой машины.

     
     
     
     
      
     
     
        2.6. Операции отношения и логические операции
 
    Операциями отношения являются
 
                         =>   >       =<   <
 
все они имеют одинаковое старшинство. Непосредственно за ними
по уровню     старшинства   следуют   операции   равенства  и
неравенства:
 
                               ==   !=
 
которые тоже имеют одинаковое старшинство. операции отношения
младше арифметических операций, так что выражения типа I<LIM-
1 понимаются как I<(LIM-1), как и предполагается.
    Логические связки && и \!\!  более интересны.  Выражения,
связанные операциями   && и \!\!,  вычисляются слева направо,
причем их  рассмотрение  прекращается  сразу  же  как  только
становится ясно,  будет ли результат истиной или ложью.  учет
этих свойств   очень  существенен  для  написания   правильно
работающих программ.  Рассмотрим,  например, оператор цикла в
считывающей строку функции GETLINE,  которую  мы  написали  в
главе 1.
 
   FOR(I=0;I<LIM-1 && (C=GETCHAR()) != '\N' && C != EOF; ++I)
   S[I]=C;
 
    Ясно, что  перед  считыванием  нового  символа необходимо
проверить, имеется  ли еще место в массиве S, так что условие
I<LIM-1 должно   проверяться  первым.   И если это условие не
выполняется, мы не должны считывать следующий символ.
    Так же неудачным было бы сравнение 'C' с EOF до обращения
к функции GETCHAR :  прежде чем проверять символ,  его  нужно
считать.
    Старшинство операции  &&  выше,   чем  у \!\!,  и обе они
младше операций   отношения  и  равенства.    Поэтому   такие
выражения, как
 
    I<LIM-1 && (C = GETCHAR()) != '\N' && C != EOF
 
не нуждаются в дополнительных круглых скобках.   Но  так  как
операция !=  старше операции присваивания,  то для достижения
правильного результата в выражении
 
    (C = GETCHAR()) != '\N'
 
    скобки необходимы.
 
    Унарная операция отрицания !  преобразует  ненулевой  или
истинный операнд   в  0,   а  нулевой или ложный операнд в 1.
Обычное использование операции ! заключается в записи
 
    IF( ! INWORD )
 
    Вместо
 
    IF( INWORD == 0 )
 
    Трудно сказать,  какая форма лучше.  Конструкции  типа  !
INWORD читаются   довольно  удобно ("если не в слове").  Но в
более сложных   случаях  они  могут  оказаться  трудными  для
понимания.
    Упражнение 2-1.
    ---------------
    Напишите оператор цикла,  эквивалентный приведенному выше
оператору FOR, не используя операции &&.

     
     
     
     
     
     
              2.7. Преобразование типов
          
    Если в выражениях встречаются операнды  различных  типов,
то они преобразуются к общему типу в соответствии с небольшим
набором правил.  В общем,  автоматически производятся  только
преобразования, имеющие      смысл,   такие  как,   например,
преобразование целого в  плавающее  в  выражениях  типа  F+I.
Выражения же,    лишенные  смысла,   такие  как использование
переменной типа FLOAT в качестве индекса, запрещены.
    Во-первых, типы CHAR и INT могут свободно  смешиваться  в
арифметических выражениях:     каждая  переменная  типа  CHAR
автоматически преобразуется    в   INT.    Это   обеспечивает
значительную гибкость       при    проведении    определенных
преобразований символов. Примером может служить функция ATOI,
которая ставит   в  соответствие  строке  цифр  ее  численный
эквивалент.
 
    ATOI(S) /* CONVERT S TO INTEGER */
    CHAR S[];
     {
        INT I, N;
 
        N = 0;
        FOR ( I = 0; S[I]>='0' && S[I]<='9'; ++I)
                N = 10 * N + S[I] - '0';
        RETURN(N);
     }
 
    Как уже обсуждалось в главе 1, выражение
 
    S[I] - '0'
 
имеет численное значение находящегося в S[I] символа,  потому
что значение символов '0',  '1' и т.д.  образуют возрастающую
последовательность расположенных подряд  целых  положительных
чисел.
    Другой пример  преобразования  CHAR  в  INT  дает функция
LOWER, преобразующая  данную прописную букву в строчную. Если
выступающий в качестве аргумента символ не является прописной
буквой, то  LOWER возвращает его неизменным.  Приводимая ниже
программа справедлива только для набора символов ASCII.
 
    LOWER(C) /* CONVERT C TO LOWER CASE; ASCII ONLY */
    INT C;
    {
       IF ( C >= 'A' && C <= 'Z' )
               RETURN( C + '@' - 'A');
       ELSE   /*@ Записано вместо 'A' строчного*/
               RETURN(C);
    }
 
    Эта функция правильно работает при коде ASCII, потому что
численные значения,   соответствующие в этом коде прописным и
строчным буквам,  отличаются на постоянную величину, а каждый
алфавит является   сплошным  - между а и Z нет ничего,  кроме
букв. Это  последнее замечание  для  набора  символов  EBCDIC
систем IBM   360/370 оказывается несправедливым,  в силу чего
эта программа на таких системах работает  неправильно  -  она
преобразует не только буквы.
    При преобразовании    символьных   переменных   в   целые
возникает один тонкий момент.  Дело в том,  что сам  язык  не
указывает, должны    ли  переменным типа CHAR соответствовать
численные значения со знаком или без  знака.   Может  ли  при
преобразовании CHAR  в INT получиться отрицательное целое?  К
сожалению, ответ  на этот вопрос меняется от машины к машине,
отражая расхождения   в их архитектуре.  На некоторых машинах
(PDP-11, например)   переменная типа CHAR,  крайний левый бит
которой содержит   1,   преобразуется  в  отрицательное целое
("знаковое расширение").      На   других    машинах    такое
преобразование сопровождается   добавлением  нулей  с  левого
края, в   результате  чего  всегда  получается  положительное
число.
    Определение языка  "C"  гарантирует,  что любой символ из
стандартного набора   символов   машины   никогда   не   даст
отрицательного числа,    так  что  эти символы можно свободно
использовать в выражениях  как  положительные  величины.   Но
произвольные комбинации   двоичных  знаков,   хранящиеся  как
символьные переменные   на  некоторых  машинах,   могут  дать
отрицательные значения, а на других положительные.
    Наиболее типичным  примером  возникновения такой ситуации
является сучай, когда значение 1 используется в качестве EOF.
Рассмотрим программу
 
    CHAR C;
    C = GETCHAR();
    IF ( C == EOF )
       ...
     
    На машине,  которая не осуществляет знакового расширения,
переменная 'с' всегда положительна, поскольку она описана как
CHAR, а  так как EOF отрицательно,   то  условие  никогда  не
выполняется. Чтобы    избежать  такой  ситуации,   мы  всегда
предусмотрительно использовали  INT  вместо  CHAR  для  любой
переменной, получающей значение от GETCHAR.
    Основная же  причина  использования  INT  вместо  CHAR не
связана с    каким-либо   вопросом   о   возможном   знаковом
расширении. просто    функция  GETCHAR  должна передавать все
возможные символы  (чтобы  ее  можно  было  использовать  для
произвольного ввода)   и,  кроме того,  отличающееся значение
EOF. Следовательно  значение EOF не может  быть  представлено
как CHAR, а должно храниться как INT.
    Другой полезной   формой  автоматического  преобразования
типов является то,  что выражения отношения,  подобные I>J, и
логические выражения,    связанные  операциями && и \!\!,  по
определению имеют значение 1, если они истинны, и 0, если они
ложны. Таким образом, присваивание
 
    ISDIGIT = C >= '0' && C <= '9';
 
полагает ISDIGIT равным 1,  если с - цифра,   и  равным  0  в
противном случае.  (В проверочной части операторов IF, WHILE,
FOR и т.д. "Истинно" просто означает "не нуль").
    Неявные арифметические    преобразования    работают    в
основном, как и ожидается. В общих чертах, если операция типа
+ или *,  которая связывает два операнда (бинарная операция),
имеет операнды разных типов,  то перед  выполнением  операции
"низший" тип преобразуется к "высшему" и получается результат
"высшего" типа. Более точно, к каждой арифметической операции
применяется следующая           последовательность     правил
преобразования.
    - Типы CHAR и SHORT  преобразуются  в  INT,   а  FLOAT  в
    DOUBLE. - Затем, если один из операндов имеет тип DOUBLE,
    то
другой преобразуется в DOUBLE,  и результат имеет тип DOUBLE.
    - В  противном  случае,  если один из операндов имеет тип
LONG, то  другой преобразуется в LONG,  и результат имеет тип
LONG.
    - В  противном  случае,  если один из операндов имеет тип
UNSIGNED, то  другой преобразуется  в  UNSIGNED  и  результат
имеет тип UNSIGNED.
    - В  противном  случае  операнды должны быть типа INT,  и
результат имеет тип INT.
    Подчеркнем, что  все  переменные  типа FLOAT в выражениях
преобразуются в   DOUBLE;  в  "C"  вся  плавающая  арифметика
выполняется с двойной точностью.
    Преобразования возникают и  при  присваиваниях;  значение
правой части  преобразуется к типу левой,  который и является
типом результата. Символьные переменные преобразуются в целые
либо со   знаковым  расширением  ,либо без него,  как описано
выше. Обратное  преобразование INT в CHAR ведет себя хорошо -
лишние биты   высокого  порядка  просто отбрасываются.  Таким
образом
 
    INT I;
    CHAR C;
 
    I = C;
    C = I;
 
значение 'с'  не  изменяется.   Это верно независимо от того,
вовлекается ли знаковое расширение или нет.
    Если x типа FLOAT, а I типа INT, то как
 
    x = I;
    
    так и
    
    I = x;
 
приводят к  преобразованиям;  при  этом FLOAT преобразуется в
INT отбрасыванием дробной части.  Тип DOUBLE преобразуется во
FLOAT округлением.    Длинные  целые  преобразуются  в  более
короткие целые   и  в  переменные   типа   CHAR   посредством
отбрасывания лишних битов высокого порядка.
    Так как  аргумент  функции  является  выражением,  то при
передаче функциям аргументов также происходит  преобразование
типов: в    частности,  CHAR и SHORT становятся INT,  а FLOAT
становится DOUBLE.  Именно  поэтому  мы  описывали  аргументы
функций как INT и DOUBLE даже тогда, когда обращались к ним с
переменными типа CHAR и FLOAT.
    Наконец, в  любом  выражении  может   быть   осуществлено
("принуждено") явное      преобразование   типа   с   помощью
конструкции, называемой  перевод (CAST).  В этой конструкции,
имеющей вид
 
    (имя типа) выражение
     
    Выражение преобразуется к  указанному  типу  по  правилам
преобразования, изложенным    выше.   Фактически точный смысл
операции перевода можно описать следующим образом:  выражение
как бы   присваивается  некоторой переменной указанного типа,
которая затем используется вместо всей конструкции. Например,
библиотечная процедура   SQRT ожидает аргумента типа DOUBLE и
выдаст бессмысленный   ответ,   если  к  ней  по  небрежности
обратятся с чем-нибудь иным.  таким образом,  если N - целое,
то выражение
 
    SQRT((DOUBLE) N)
 
до передачи  аргумента  функции  SQRT  преобразует  N  к типу
DOUBLE. (Отметим, что операция перевод преобразует значение N
в надлежащий   тип;  фактическое  содержание переменной N при
этом не изменяется). Операция перевода имрация перевода имеет
тот же   уровень старшинства,  что и другие унарные операции,
как указывается в таблице в конце этой главы.
    Упражнение 2-2.
    ---------------
    Составьте программу   для   функции   HTOI(S),    которая
преобразует строку  шестнадцатеричных цифр в эквивалентное ей
целое значение.  При этом допустимыми цифрами являются  цифры
от 1 до 9 и буквы от а до F.

     
     
     
     
     
          2.8. Операции увеличения и уменьшения
 
    В языке "C"  предусмотрены  две  необычные  операции  для
увеличения и     уменьшения  значений  переменных.   Операция
увеличения ++ добавляет 1  к  своему  операнду,   а  операция
уменьшения --  вычитает 1.  Мы часто использовали операцию ++
для увеличения переменных, как, например, в
 
    IF(C == '\N')
        ++I;
 
    Необычный аспект заключается в том,  что ++  и  --  можно
использовать либо  как префиксные операции (перед переменной,
как в ++N),  либо как постфиксные (после  переменной:   N++).
Эффект в обоих случаях состоит в увеличении N. Но выражение +
+N увеличивает переменную N до использования ее значения,   в
то время как N++ увеличивает переменную N после того,  как ее
значение было использовано.  Это означает,  что в  контексте,
где используется   значение  переменной,   а не только эффект
увеличения, использование    ++N  и  N++  приводит  к  разным
результатам. Если N = 5, то
 
     х = N++;
 
    устанавливает х равным 5, а
 
    х = ++N;
 
полагает х  равным 6.  В обоих случаях N становится равным 6.
Операции увеличения и уменьшения  можно  применять  только  к
переменным; выражения типа х=(I+J)++ являются незаконными.
    В случаях,  где нужен только эффект увеличения,   а  само
значение не используется, как, например, в
 
    IF ( C == '\N' )
       NL++;
 
выбор префиксной  или  постфиксной  операции  является  делом
вкуса. но встречаются ситуации, где нужно использовать именно
ту или другую операцию. Рассмотрим, например, функцию SQUEEZE
(S,C), которая   удаляет символ 'с' из строки S,  каждый раз,
как он встречается.
 
    SQUEEZE(S,C)    /* DELETE ALL C FROM S */
    CHAR S[];
    INT C;
    {
       INT I, J;
 
       FOR ( I = J = 0; S[I] != '\0'; I++)
               IF ( S[I] != C )
        S[J++] = S[I];
       S[J] = '\0';
    }
 
    Каждый раз,  как встечается символ,  отличный от 'с',  он
копируется в текущую позицию  J,   и  только  после  этого  J
увеличивается на   1,   чтобы  быть  готовым  для поступления
следующего символа. Это в точности эквивалентно записи
 
    IF ( S[I] != C ) {
            S[J] = S[I];
            J++;
    }
 
    Другой пример  подобной конструкции дает функция GETLINE,
которую мы запрограммировали в главе 1, где можно заменить
 
    IF ( C == '\N' ) {
       S[I] = C;
       ++I;
    }
 
    более компактной записью
 
    IF ( C == '\N' )
       S[I++] = C;
 
    В качестве   третьего    примера    рассмотрим    функцию
STRCAT(S,T), которая   приписывает строку т в конец строки S,
образуя конкатенацию строк S и т.  При  этом  предполагается,
что в  S достаточно места для хранения полученной комбинации.
 
     STRCAT(S,T)     /* CONCATENATE T TO END OF S */
     CHAR S[], T[];  /* S MUST BE BIG ENOUGH */
     {
        INT I, J;
 
        I = J = 0;
        WHILE (S[I] != '\0') / *FIND END OF S */
                I++;
       WHILE((S[I++] = T[J++]) != '\0') /*COPY T*/
                ;
     }
 
    Так как  из  T  в  S  копируется  каждый  символ,  то для
подготовки к   следующему   прохождению   цикла   постфиксная
операция ++ применяется к обеим переменным I и J.
 
 
    Упражнение 2-3.
    ---------------
    Напишите другой вариант функции SQUEEZE(S1,S2),   который
удаляет из строки S1 каждый символ,  совпадающий с каким-либо
символом строки S2.
    Упражнение 2-4.
    ---------------
    Напишите программу  для  функции   ANY(S1,S2),    которая
находит место   первого  появления  в  строке  S1 какого-либо
символа из строки S2 и,  если строка S1 не содержит  символов
строки S2, возвращает значение -1.

     
     
     
     
    
     
     
          2.9. Побитовые логические операции
     
    В языке предусмотрен ряд операций для  работы  с  битами;
эти операции   нельзя  применять  к переменным типа FLOAT или
DOUBLE.
 
    & Побитовое AND
    \! Побитовое включающее OR
    ^ побитовое исключающее OR
    << сдвиг влево
    >> сдвиг вправо
    \^ дополнение (унарная операция)
    "\" иммитирует вертикальную черту.
 
    Побитовая операция    AND    часто    используется    для
маскирования некоторого множества битов; например, оператор
 
    C = N & 0177
 
передает в 'с' семь младших  битов  N  ,   полагая  остальные
равными нулю.    Операция  'э' побитового OR используется для
включения битов:
 
    C = X э MASK
 
устанавливает на единицу те биты в х ,  которые равны единице
    в MASK.  Следует быть внимательным и  отличать  побитовые
    операции &
и 'э' от логических связок && и \!\!  , Которые подразумевают
вычисление значения истинности слева направо.  Например, если
х=1, а    Y=2,   то значение х&Y равно нулю ,  в то время как
значение X&&Y равно единице./почему?/
    Операции сдвига << и >> осуществляют соответственно сдвиг
влево и   вправо  своего  левого  операнда  на  число битовых
позиций, задаваемых  правым операндом.  Таким образом ,  х<<2
сдвигает х   влево  на две позиции,  заполняя освобождающиеся
биты нулями,  что эквивалентно умножению на 4.  Сдвиг  вправо
величины без     знака   заполняет  освобождающиеся  биты  на
некоторых машинах,  таких как PDP-11, заполняются содержанием
знакового бита /"арифметический сдвиг"/,  а на других - нулем
/"логический сдвиг"/.
    Унарная операция  \^  дает  дополнение  к   целому;   это
означает ,  что каждый бит со значением 1 получает значение 0
и наоборот.   Эта  операция  обычно  оказывается  полезной  в
выражениях типа
 
    X & \^077
 
где последние шесть битов х маскируются  нулем.   Подчеркнем,
что выражение   X&\^077  не  зависит от длины слова и поэтому
предпочтительнее, чем,       например,     X&0177700,     где
предполагается, что   х занимает 16 битов.  Такая переносимая
форма не требует никаких  дополнительных  затрат,   поскольку
\^077 является   константным  выражением  и,   следовательно,
обрабатывается во время компиляции.
    Чтобы проиллюстрировать использование некоторых  операций
с битами,      рассмотрим  функцию  GETBITS(X,P,N),   которая
возвращает /сдвинутыми к правому краю/ начинающиеся с позиции
р поле   переменной х длиной N битов.  мы предполагаем ,  что
крайний правый бит имеет номер 0,  и что  N  и  р  -  разумно
заданные положительные    числа.   например,   GETBITS(х,4,3)
возвращает сдвинутыми к правому краю биты, занимающие позиции
4,3 и 2.
 
     GETBITS(X,P,N)  /* GET N BITS FROM POSITION P */
     UNSIGNED X, P, N;
      {
        RETURN((X >> (P+1-N)) & \^(\^0 << N));
      }
 
    Операция X  >>  (P+1-N)   сдвигает желаемое поле в правый
конец слова.  Описание аргумента X как UNSIGNED  гарантирует,
что при  сдвиге вправо освобождающиеся биты будут заполняться
нулями, а  не содержимым знакового бита,  независимо от того,
на какой машине пропускается программа. Все биты константного
выражения \^0 равны 1; сдвиг его на N позиций влево с помощью
операции \^0<<N   создает  маску  с нулями в N крайних правых
битах и единицами в остальных; дополнение \^ создает маску  с
единицами в N крайних правых битах.
    Упражнение 2-5.
    ---------------
    Переделайте GETBITS    таким    образом,     чтобы   биты
отсчитывались слева направо.
    Упражнение 2-6.
    ---------------
    Напишите программу для функции WORDLENGTH(),  вычисляющей
длину слова   используемой  машины,   т.е.   Число  битов   в
переменной типа  INT.  Функция должна быть переносимой,  т.е.
Одна и та же исходная программа должна правильно работать  на
любой машине.
    Упражнение 2-7.
    ---------------
    Напишите программу для функции RIGHTROT(N,B),  сдвигающей
циклически целое N вправо на B битовых позиций.
    Упражнение 2-8.
    ---------------
    Напишите программу  для  функции  INVERT(X,P,N),  которая
инвертирует (т.е.  Заменяет 1 на 0 и наоборот)   N  битов  X,
начинающихся с позиции P, оставляя другие биты неизмененными.

     
     
     
          
     
     
        2.10. Операции и выражения присваивания.
 
    Такие выражения, как
 
    I = I + 2
  
    в которых  левая  часть  повторяется в правой части могут
быть записаны в сжатой форме
 
    I += 2
 
используя операцию присваивания вида +=.
    Большинству бинарных   операций   (операций  подобных  +,
которые имеют левый и правый операнд)  соответствует операция
присваивания вида оп=, где оп - одна из операций
 
    + - * / % << >> & \^ \!
 
    Если е1 и е2 - выражения, то
 
    е1 оп= е2
     
    эквивалентно
 
    е1 = (е1) оп (е2)
 
за исключением того, что выражение е1 вычисляется только один
раз. Обратите внимание на круглые скобки.
    
    X *= Y + 1
 
    то
 
    X = X * (Y + 1)
 
    не
 
    X = X * Y + 1
 
 В качестве  примера  приведем  функцию  BITCOUNT,    которая
подсчитывает число равных 1 битов у целого аргумента.
 
 
     BITCOUNT(N)   /* COUNT 1 BITS IN N */
     UNSIGNED N;
     (
     INT B;
     FOR (B = 0; N != 0; N >>= 1)
        IF (N & 01)
                B++;
     RETURN(B);
    )
 
    Не говоря уже о краткости,  такие  операторы  приваивания
имеют то   преимущество,   что они лучше соответствуют образу
человеческого мышления.  Мы говорим:  "прибавить 2 к  I"  или
"увеличить I на 2",  но не "взять I,  прибавить 2 и поместить
результат опять в I".  Итак, I += 2. Кроме того, в громоздких
выражениях, подобных
 
     YYVAL[YYPV[P3+P4] + YYPV[P1+P2]] += 2
 
    Такая операция    присваивания    облегчает     понимание
программы, так  как читатель не должен скрупулезно проверять,
являются ли два длинных выражения действительно  одинаковыми,
или задумываться,    почему они не совпадают.  Такая операция
присваивания может даже  помочь  компилятору  получить  более
эффективную программу.
    Мы уже  использовали тот факт,  что операция присваивания
имеет некоторое значение и может входить в  выражения;  самый
типичный пример
 
      WHILE ((C = GETCHAR()) != EOF)
 
присваивания, использующие другие операции присваивания  (+=,
-= и   т.д.)   также  могут  входить  в  выражения,  хотя это
случается реже. Типом выражения присваивания является тип его
левого операнда.
    Упражнение 2-9.
    ---------------
    В двоичной  системе  счисления операция X&(X-1)  обнуляет
самый правый равный 1 бит переменной X.(почему?)  используйте
это замечание   для  написания  более  быстрой версии функции
BITCOUNT.

     
     
     
     
     
     
                                                 
     
     
     
            2.11. Условные выражения.
 
    Операторы
 
     IF (A > B)
        Z = A;
     ELSE
        Z = B;
 
конечно вычисляют в Z максимум из а и в.  Условное выражение,
записанное с  помощью тернарной операции "?:",  предоставляет
другую возможность для записи этой и аналогичных конструкций.
В выражении
 
     е1 ? Е2 : е3
 
сначала вычисляется выражение е1.  Если оно отлично  от  нуля
(истинно), то  вычисляется выражение е2, которое и становится
значением условного выражения. В противном случае вычисляется
е3, и   оно становится значением условного выражения.  Каждый
раз вычисляется только одно из  выражения  е2  и  е3.   Таким
образом, чтобы   положить Z равным максимуму из а и в,  можно
написать
 
      Z = (A > B) ? A : B;   /* Z = MAX(A,B) */
 
    Следует подчеркнуть, что условное выражение действительно
является выражением и может использоваться точно так же,  как
любое другое  выражение.  Если е2 и е3 имеют разные типы,  то
тип результата   определяется  по  правилам   преобразования,
рассмотренным ранее в этой главе.  например, если F имеет тип
FLOAT, а N - тип INT, то выражение
 
     (N > 0) ? F : N
 
имеет тип  DOUBLE  независимо от того,  положительно ли N или
    нет. Так как уровень старшинства операции ?: очень низок,
прямо над   присваиванием,   то  первое  выражение в условном
выражении можно не заключать в круглые скобки. Однако, мы все
же рекомендуем   это  делать,  так как скобки делают условную
часть выражения более заметной.
    Использование условных   выражений   часто   приводит   к
коротким программам.  Например, следующий ниже оператор цикла
печатает N элементов массива, по 10 в строке, разделяя каждый
столбец одним   пробелом  и заканчивая каждую строку (включая
последнюю) одним символом перевода строки.
 
   OR (I = 0; I < N; I++)
     PRINTF("%6D%C",A[I],(I%10==9 \!\! I==N-1) ? '\N' : ' ')
 
    Символ перевода   строки   записывается   после   каждого
десятого элемента и после N-го элемента.  За всеми остальными
элементами следует один пробел.  Хотя, возможно, это выглядит
мудреным, было  бы поучительным попытаться записать это,   не
используя условного выражения.
    Упражнение 2-10.
    ---------------
    Перепишите программу для функции LOWER, которая переводит
прописные буквы в  строчные,   используя  вместо  конструкции
IF-ELSE условное выражение.

     
     
     
     
     
                                                                                                           
     
     
     
          2.12. Старшинство и порядок вычисления.
 
    В приводимой  ниже  таблице сведены правила старшинства и
ассоциативности всех операций,  включая и те,  которые мы еще
не обсуждали.  Операции,  расположенные в одной строке, имеют
один и тот  же  уровень  старшинства;  строки  расположены  в
порядке убывания старшинства.  Так, например, операции *, / и
% имеют одинаковый уровень старшинства,  который  выше,   чем
уровень операций + и -.
 
      OPERATOR        ASSOCIATIVITY
 
      () [] -> .        LEFT TO RIGHT
 
      !  \^ ++  --  -  (TYPE)  * &  SIZEOF    RIGHT TO LEFT
 
      *  /  %        LEFT TO RIGHT
 
      +  -         LEFT TO RIGHT
 
      <<  >>         LEFT TO RIGHT
 
      <  <= >  >=        LEFT TO RIGHT
 
      ==  !=         LEFT TO RIGHT
 
      &         LEFT TO RIGHT
 
      ^         LEFT TO RIGHT
 
      \!         LEFT TO RIGHT
 
      &&         LEFT TO RIGHT
 
      \!\!         LEFT TO RIGHT
 
      ?:         RIGHT TO LEFT
 
      =  += -=  ETC.       RIGHT TO LEFT
 
      ,  (CHAPTER 3)       LEFT TO RIGHT
 
 
    Операции ->  и  .   Используются  для доступа к элементам
структур; они будут описаны в главе 6 вместе с SIZEOF (размер
объекта). В    главе  5  обсуждаются  операции  *  (косвенная
адресация) и & (адрес).
    Отметим, что  уровень  старшинства  побитовых  логических
операций &,  ^ и э ниже уровня операций == и !=. Это приводит
к тому,  что  осуществляющие  побитовую  проверку  выражения,
подобные
 
    IF ((X & MASK) == 0) ...
 
    Для получения правильных результатов должны заключаться в
круглые скобки.
    Как уже отмечалось ранее,  выражения,  в  которые  входит
одна из ассоциативных и коммутативных операций (*,  +,  &, ^,
э), могут  перегруппировываться,  даже если они  заключены  в
круглые скобки. В большинстве случаев это не приводит к каким
бы то   ни  было  расхождениям;  в  ситуациях,    где   такие
расхождения все же возможны,  для обеспечения нужного порядка
вычислений можно использовать явные промежуточные переменные.
    В языке "C",  как и в большинстве языков,  не фиксируется
порядок вычисления     операндов  в  операторе.   Например  в
операторе вида
 
    X = F() + G();
 
сначала может  быть  вычислено  F,   а  потом G,  и наоборот;
поэтому, если  либо F, либо G изменяют внешнюю переменную, от
которой зависит другой операнд,  то значение X может зависеть
от порядка       вычислений.     Для    обеспечения    нужной
последовательности промежуточные     результаты  можно  опять
запоминать во временных переменных.
    Подобным же образом  не  фиксируется  порядок  вычисления
аргументов функции, так что оператор
 
    PRINTF("%D %D\N",++N,POWER(2,N));
 
может давать (и действительно дает)  на разных машинах разные
результаты в зависимости от того,  увеличивается ли N до  или
после обращения    к  функции  POWER.   Правильным  решением,
конечно, является запись
 
    ++N;
    PRINTF("%D %D\N",N,POWER(2,N));
 
    Обращения к функциям,  вложенные  операции  присваивания,
операции увеличения   и  уменьшения приводят к так называемым
"побочным эффектам" -  некоторые  переменные  изменяются  как
побочный результат вычисления выражений. В любом выражении, в
котором возникают побочные эффекты,  могут существовать очень
тонкие зависимости    от  порядка,   в  котором  определяются
входящие в  него  переменные.   примером  типичной  неудачной
ситуации является оператор
 
    A[I] = I++;
 
    Возникает вопрос,  старое или новое значение I  служит  в
качестве индекса.      Компилятор   может  поступать  разными
способами и в зависимости  от  своей  интерпретации  выдавать
разные результаты.    Тот  случай,  когда происходят побочные
эффекты (присваивание фактическим переменным),  - оставляется
на усмотрение  компилятора,  так как наилучший порядок сильно
зависит от архитектуры машины.
    Из этих рассуждений  вытекает  такая  мораль:   написание
программ, зависящих   от порядка вычислений,  является плохим
методом программирования на любом языке.  Конечно, необходимо
знать, чего    следует избегать,  но если вы не в курсе,  как
некоторые вещи реализованы на разных машинах,  это  неведение
может предохранить     вас   от  неприятностей.   (Отладочная
программа LINT укажет большинство мест,  зависящих от порядка
вычислений.

     
     
     
     



               3. Поток управления

    Управляющие операторы    языка     определяют     порядок
вычислений. В приведенных ранее примерах мы уже встречались с
наиболее употребительными  управляющими  конструкциями  языка
"C"; здесь мы опишем остальные операторы управления и уточним
действия операторов, обсуждавшихся ранее.











             3.1. Операторы и блоки

    Такие выражения,  как X=0,  или  I++,   или  PRINTF(...),
становятся операторами, если за ними следует точка с запятой,
как, например,

     X = 0;
     I++;
     PRINTF(...);
 
    В языке  "C"  точка  с  запятой  является признаком конца
оператора, а  не разделителем операторов,  как в языках  типа
алгола.
    Фигурные скобки  /(  и  /)   используются для объединения
описаний и операторов в составной оператор или блок,  так что
они оказываются  синтаксически эквивалентны одному оператору.
Один явный пример такого типа дают фигурные скобки, в которые
заключаются операторы,     составляющие  функцию,   другой  -
фигурные скобки вокруг группы операторов в  конструкциях  IF,
ELSE, WHILE    и  FOR.(на  самом  деле  переменные могут быть
описаны внутри любого блока; мы поговорим об этом в главе 4).
Точка с   запятой  никогда  не ставится после первой фигурной
скобки, которая завершает блок.
     
     
     
     
     
     
   
   
   
   
   
   
      
     
     
                 3.2. IF - ELSE
 
    Оператор IF - ELSE используется при необходимости сделать
выбор. Формально синтаксис имеет вид
 
     IF  (выражение)
             оператор-1
     ELSE
             оператор-2,
 
    Где часть    ELSE   является   необязательной.    Сначала
вычисляется выражение; если  оно  "истинно"  /т.е.   значение
выражения отлично от нуля/,  то выполняется оператор-1.  Если
оно ложно /значение выражения равно нулю/,  и если есть часть
с ELSE, то вместо оператора-1 выполняется оператор-2.
    Так как IF просто проверяет численное значение выражения,
то возможно   некоторое  сокращение  записи.  Самой очевидной
возможностью является запись
 
       IF  (выражение)
    вместо
       IF  (выражение !=0)
 
иногда такая  запись  является  ясной  и  естественной,    но
временами она становится загадочной.
    То, что часть ELSE  в  конструкции  IF  -  ELSE  является
необязательной, приводит   к двусмысленности в случае,  когда
ELSE опускается во  вложенной  последовательности  операторов
IF. Эта    неоднозначность разрешается обычным образом - ELSE
связывается с ближайшим предыдущим IF,  не  содержащим  ELSE.
Например, в
 
    IF ( N > 0 )
       IF( A > B )
               Z = A;
       ELSE
               Z = B;
 
конструкция ELSE  относится  к  внутреннему  IF,   как  мы  и
показали, сдвинув   ELSE под соответствующий IF.  Если это не
то, что  вы хотите,  то для  получения  нужного  соответствия
необходимо использовать фигурные скобки:
 
    IF (N > 0)      {
       IF (A > B)
               Z = A;
    }
    ELSE
       Z = B;
       
  Такая двусмысленность особенно пагубна в ситуациях типа
 
    IF (N > 0)
       FOR (I = 0; I < N; I++)
               IF (S[I] > 0) {
        PRINTF("...");
        RETURN(I);
               }
    ELSE   /* WRONG */
       PRINTF("ERROR - N IS ZERO\N");
     
    Запись ELSE  под IF ясно показывает,  чего вы хотите,  но
компилятор не получит соответствующего указания и свяжет ELSE
с внутренним     IF.    Ошибки   такого   рода  очень  трудно
обнаруживаются.
    Между прочим, обратите внимание, что в
 
     IF (A > B)
        Z = A;
     ELSE
        Z = B;
 
после Z=A  стоит  точка с запятой.  Дело в том,  что согласно
грамматическим правилам за IF должен следовать  оператор,   а
выражение типа     Z=A,    являющееся   оператором,    всегда
заканчивается точкой с запятой.
     
     
     
     
                                                                 
     
     
               3.3. ELSE - IF
      
    Конструкция
 
     IF (выражение)
        оператор
     ELSE    IF (выражение)
                оператор
     ELSE    IF (выражение)
                оператор
     ELSE
        оператор
 
встречается настолько  часто,   что  заслуживает   отдельного
краткого рассмотрения. Такая последовательность операторов IF
является наиболее распространенным способом  программирования
выбора из     нескольких   возможных   вариантов.   выражения
просматриваются последовательно;   если  какое-то   выражение
оказывается истинным,то     выполняется  относящийся  к  нему
оператор, и  этим вся цепочка заканчивается.  Каждый оператор
может быть либо отдельным оператором, либо группой операторов
в фигурных скобках.
    Последняя часть с ELSE имеет дело со случаем,   когда  ни
одно из  проверяемых условий не выполняется.  Иногда при этом
не надо предпринимать никаких явных действий; в  этом  случае
хвост
 
     ELSE
        оператор
 
может быть  опущен,  или его можно использовать для контроля,
чтобы засечь "невозможное" условие.
    Для иллюстрации   выбора   из  трех  возможных  вариантов
приведем программу   функции,   которая  методом  половинного
деления определяет,     находится  ли  данное  значение  х  в
отсортированном массиве V.  Элементы массива  V  должны  быть
расположены в  порядке возрастания.  Функция возвращает номер
позиции (число между 0 и N-1), в которой значение х находится
в V, и -1, если х не содержится в V.
 
     BINARY(X, V, N) /* FIND X IN V[0]...V[N-1] */
     INT X, V[], N;
     {
         INT LOW, HIGH, MID;
 
        LOW = 0;
        HIGH = N - 1;
        WHILE (LOW <= HIGH) {
                MID = (LOW + HIGH) / 2;
                IF (X < V[MID])
         HIGH = MID - 1;
                ELSE IF (X > V[MID])
         LOW = MID + 1;
                ELSE   /* FOUND MATCH */
         RETURN(MID);
        }
        RETURN(-1);
     }
 
    Основной частью каждого шага алгоритма является проверка,
будет ли х меньше, больше или равен среднему элементу V[MID];
использование конструкции ELSE - IF здесь вполне естественно.
     
     
     
     
     
               3.4. Переключатель
 
    Оператор SWITCH  дает специальный способ выбора одного из
многих вариантов,  который заключается в проверке  совпадения
значения данного   выражения  с  одной из заданных констант и
соответствующем ветвлении.  В главе 1  мы  привели  программу
подсчета числа   вхождений  каждой  цифры,   символов  пустых
промежутков и    всех   остальных   символов,    использующую
последовательность IF...ELSE   IF...ELSE.   Вот  та  же самая
программа с переключателем.
 
    MAIN() /* COUNT DIGITS,WHITE SPACE, OTHERS */
    {
       INT C, I, NWHITE, NOTHER, NDIGIT[10];
 
       NWHITE = NOTHER = 0;
       FOR (I = 0; I < 10; I++)
               NDIGIT[I] = 0;
 
       WHILE ((C = GETCHAR()) != EOF)
                SWITCH (C) {
                CASE '0':
                CASE '1':
                CASE '2':
                CASE '3':
                CASE '4':
                CASE '5':
                CASE '6':
                CASE '7':
                CASE '8':
                CASE '9':
         NDIGIT[C-'0']++;
         BREAK;
                CASE ' ':
                CASE '\N':
                CASE '\T':
         NWHITE++;
         BREAK;
                DEFAULT :
         NOTHER++;
         BREAK;
                }
        PRINTF("DIGITS =");
        FOR (I = 0; I < 10; I++)
                PRINTF(" %D", NDIGIT[I]);
        PRINTF("\NWHITE SPACE = %D, OTHER = %D\N",
                NWHITE, NOTHER);
 
 
    Переключатель вычисляет целое выражение в круглых скобках
(в данной программе - значение символа с)  и  сравнивает  его
значение со всеми случаями (CASE).  Каждый случай должен быть
помечен либо   целым,   либо  символьной  константой,    либо
константным выражением. Если значение константного выражения,
стоящего после   вариантного  префикса  CASE,   совпадает  со
значением целого выражения,  то выполнение начинается с этого
случая. Если  ни один из случаев не подходит,  то выполняется
оператор после   префикса  DEFAULT.  Префикс DEFAULT является
необязательным ,если его  нет,   и  ни  один  из  случаев  не
подходит, то вообще никакие действия не выполняются. Случаи и
выбор по умолчанию могут располагаться в любом порядке.   Все
случаи должны быть различными.
    Оператор BREAK  приводит   к   немедленному   выходу   из
переключателя. Поскольку    случаи  служат  только в качестве
меток, то   если  вы  не  предпримите  явных  действий  после
выполнения операторов,    соответствующих  одному случаю,  вы
провалитесь на следующий случай.  Операторы  BREAK  и  RETURN
являются самым обычным способом выхода из переключателя.  Как
мы обсудим   позже  в  этой  главе,   оператор  BREAK   можно
использовать и   для  немедленного выхода из операторов цикла
WHILE, FOR и DO.
    Проваливание сквозь  случаи  имеет  как свои достоинства,
так и недостатки. К положительным качествам можно отнести то,
что оно     позволяет   связать  несколько  случаев  с  одним
действием, как  было с пробелом, табуляцией и новой строкой в
нашем примере.    Но  в  то  же  время  оно обычно приводит к
необходимости заканчивать  каждый  случай  оператором  BREAK,
чтобы избежать  перехода к следующему случаю.  Проваливание с
одного случая на другой обычно бывает неустойчивым,  так  как
оно склонно   к  расщеплению  при  модификации программы.  За
исключением, когда  одному вычислению соответствуют несколько
меток, проваливание следует использовать умеренно.
    Заведите привычку ставить оператор BREAK после последнего
случая (в данном примере после DEFAULT),  даже  если  это  не
является логически необходимым. В один прекрасный день, когда
вы добавите в конец еще  один  случай,   эта  маленькая  мера
предосторожности избавит вас от неприятностей.
    Упражнение 3-1.
    --------------
    Напишите программу для функции  EXPAND(S,   T),   которая
копирует строку  S в T,  заменяя при этом символы табуляции и
новой строки на видимые условные последовательности, как \N и
\T. используйте переключатель.
     
     
     
     
     
     
               3.5. Циклы - WHILE и FOR
 
    Мы уже сталкивались с операторами цикла WHILE и  FOR.
   В конструкции
 
    WHILE (выражение)
       оператор
 
вычисляется выражение.  Если его значение отлично от нуля, то
выполняется оператор и выражение вычисляется снова. Этот цикл
продолжается до   тех пор,  пока значение выражения не станет
нулем, после  чего выполнение программы продолжается с  места
после оператора.
 
    Оператор
 
    FOR (выражение 1; выражение 2; выражение 3)
       оператор
 
эквивалентен последовательности
 
    выражение 1;
    WHILE (выражение 2) {
       оператор
       выражение 3;
    }
 
    Грамматически все   три   компонента   в   FOR   являются
выражениями. наиболее распространенным является случай, когда
выражение 1    и  выражение  3  являются  присваиваниями  или
обращениями к функциям,  а выражение 2 - условным выражением.
любая из трех частей может быть опущена, хотя точки с запятой
при этом должны оставаться.  Если отсутствует выражение 1 или
выражение 3,   то оно просто выпадает из расширения.  Если же
отсутствует проверка,  выражение 2,  то считается,  как будто
оно всегда истинно, так что
 
     FOR (;;)        {
        ...
     }
 
является бесконечным циклом, о котором предполагается, что он
будет прерван   другими  средствами  (такими  как  BREAK  или
RETURN).
    Использовать ли WHILE или FOR -  это,   в  основном  дело
вкуса. Например в
 
    WHILE ((C = GETCHAR())
       == ' ' \!\! C == '\N' \!\! C == '\T')
     ;    /* SKIP WHITE SPACE CHARACTERS */
 
нет ни инициализации,  ни реинициализации, так что цикл WHILе
выглядит самым естественным.
    Цикл FOR,   очевидно,  предпочтительнее там,  где имеется
простая инициализация и реинициализация,  поскольку при  этом
управляющие циклом   операторы  наглядным образом оказываются
вместе в начале цикла. Это наиболее очевидно в конструкции
 
     FOR (I = 0; I < N; I++)
 
которая является идиомой языка "C"  для  обработки  первых  N
элементов массива,  аналогичной оператору цикла DO в фортране
и PL/1.  Аналогия,  однако,  не полная, так как границы цикла
могут быть   изменены внутри цикла,  а управляющая переменная
сохраняет свое значение после выхода из цикла,  какова бы  ни
была причина  этого выхода.  Поскольку компонентами FOR могут
быть произвольные выражения,  они  не  ограничиваются  только
арифметическими прогрессиями.    Тем не менее является плохим
стилем включать в FOR вычисления,   которые  не  относятся  к
управлению циклом,    лучше поместить их в управляемые циклом
операторы.
    В качестве  большего  по  размеру примера приведем другой
вариант функции ATOI,  преобразующей строку  в  ее  численный
эквивалент. Этот   вариант является более общим; он допускает
присутствие в начале символов пустых промежутков  и  знака  +
или -.  (В главе 4 приведена функция ATOF,  которая выполняет
то же самое преобразование для чисел с плавающей точкой).
    Общая схема программы отражает форму поступающих данных:
 
  - пропустить пустой промежуток, если он имеется
  - извлечь знак, если он имеется
  - извлечь целую часть и преобразовать ее
 
    Каждый шаг  выполняет свою часть работы и оставляет все в
подготовленном состоянии для следующей части.   Весь  процесс
заканчивается на первом символе, который не может быть частью
числа.
 
    ATOI(S) /* CONVERT S TO INTEGER */
    CHAR S[];
    {
    INT I, N, SIGN;
    FOR(I=0;S[I]==' ' \!\!
             S[I]=='\N' \!\! S[I]=='\T';I++)
       ; /* SKIP WHITE SPACE */
    SIGN = 1;
    IF(S[I] == '+' \!\! S[I] == '-')  /* SIGN */
       SIGN = (S[I++]=='+') ? 1 : - 1;
    FOR( N = 0; S[I] >= '0' && S[I] <= '9'; I++)
       N = 10 * N + S[I] - '0';
    RETURN(SIGN * N);
    }
 
    Преимущества централизации управления  циклом  становятся
еще более   очевидными,   когда  имеется  несколько вложенных
циклов. Следующая  функция сортирует массив  целых  чисел  по
методу шелла. основная идея сортировки по шеллу заключается в
том, что  сначала  сравниваются  удаленные  элементы,   а  не
смежные, как    в  обычном методе сортировки.  Это приводит к
быстрому устранению   большой   части   неупорядоченности   и
сокращает последующую   работу.   Интервал  между  элементами
постепенно сокращается    до   единицы,    когда   сортировка
фактически превращается     в   метод  перестановки  соседних
элементов.
 
    SHELL(V, N)   /* SORT V[0]...V[N-1]
                   INTO INCREASING ORDER */
    INT V[], N;
    {
      INT GAP, I, J, TEMP;
 
      FOR (GAP = N/2; GAP > 0; GAP /= 2)
         FOR (I = GAP; I < N; I++)
      FOR (J=I-GAP; J>=0 && V[J]>V[J+GAP]; J-=GAP) {
       TEMP = V[J];
       V[J] = V[J+GAP];
       V[J+GAP] = TEMP;
      }
    }
          
    Здесь имеются  три  вложенных  цикла.  Самый внешний цикл
управляет интервалом между сравниваемыми элементами, уменьшая
его от N/2 вдвое при каждом проходе, пока он не станет равным
нулю. Средний    цикл  сравнивает  каждую   пару   элементов,
разделенных на   величину  интервала;  самый  внутренний цикл
переставляет любую неупорядоченную пару.  Так как интервал  в
конце концов   сводится к единице,  все элементы в результате
упорядочиваются правильно.  Отметим,   что  в  силу  общности
конструкции FOR   внешний  цикл  укладывается  в  ту же самую
форму, что  и остальные, хотя он и не является арифметической
прогрессией.
    Последней операцией  языка  "C"  является  запятая   ",",
которая чаще    всего  используется  в  операторе  FOR.   Два
выражения, разделенные  запятой,  вычисляются слева  направо,
причем типом   и значением результата являются тип и значение
правого операнда.  Таким образом, в различные части оператора
FOR можно   включить  несколько  выражений,   например,   для
параллельного изменения двух  индексов.   Это  иллюстрируется
функцией REVERSE(S),  которая располагает строку S в обратном
порядке на том же месте.
 
     REVERSE(S)    /* REVERSE STRING S IN PLACE */
     CHAR S[];
     {
     INT C, I, J;
 
     FOR(I = 0, J = STRLEN(S) - 1; I < J; I++, J--)  {
        C = S[I];
        S[I] = S[J];
        S[J] = C;
     }
     }
 
    Запятые, которые разделяют аргументы функций,  переменные
в описаниях и т.д.,  не имеют отношения к операции запятая  и
не обеспечивают вычислений слева направо.
 
    Упражнение 3-2.
    ---------------
    Составьте программу  для  функции EXPAND(S1,S2),  которая
расширяет сокращенные обозначения вида а-Z  из  строки  S1  в
эквивалентный полный   список  авс...XYZ  в  S2.  Допускаются
сокращения для строчных и  прописных  букв  и  цифр.   Будьте
готовы иметь   дело  со  случаями типа а-в-с,  а-Z0-9 и -а-Z.
(Полезное соглашение состоит в том,  что символ -,  стоящий в
начале или конце, воспринимается буквально).

     
     
     
      
     
     
               3.6. Цикл DO - WHILE
 
    Как уже отмечалось в главе 1,  циклы WHILE и FOR обладают
тем приятным   свойством,   что  в  них  проверка   окончания
осуществляется в начале,  а не в конце цикла. Третий оператор
цикла языка "C",  DO-WHILE,  проверяет  условие  окончания  в
конце, после    каждого  прохода через тело цикла; тело цикла
всегда выполняется по крайней мере один раз.  Синтаксис этого
оператора имеет вид:
 
 DO
    оператор
 WHILE (выражение)
 
    Сначала выполняется    оператор,     затем    вычисляется
выражение. Если  оно истинно, то оператор выполняется снова и
т.д. Если выражение становится ложным, цикл заканчивается.
    Как и можно было  ожидать,   цикл  DO-WHILE  используется
значительно реже,   чем WHILE и FOR,  составляя примерно пять
процентов от всех циклов. Тем не менее, иногда он оказывается
полезным, как,   например,  в следующей функции ITOA, которая
преобразует число   в  символьную  строку  (обратная  функции
ATOI). Эта   задача оказывается несколько более сложной,  чем
может показаться сначала.  Дело в том,   что  простые  методы
выделения цифр   генерируют  их  в  неправильном порядке.  Мы
предпочли получить   строку  в  обратном  порядке,   а  затем
обратить ее.
 
    ITOA(N,S)   /*CONVERT N TO CHARACTERS IN S */
    CHAR S[];
    INT N;
    {
    INT I, SIGN;
 
    IF ((SIGN = N) < 0)   /* RECORD SIGN */
       N = -N;     /* MAKE N POSITIVE */
    I = 0;
    DO {    /* GENERATE DIGITS IN REVERSE ORDER */
       S[I++] = N % 10 + '0';/* GET NEXT DIGIT */
    }   WHILE ((N /=10) > 0); /* DELETE IT */
    IF (SIGN < 0)
       S[I++] = '-'
    S[I] = '\0';
    REVERSE(S);
    }
 
    Цикл DO-WHILE  здесь  необходим,   или  по  крайней  мере
удобен, поскольку,   каково бы ни было значение N,  массив  S
должен содержать хотя бы один символ. Мы заключили в фигурные
скобки один оператор,  составляющий тело DO-WHILе, хотя это и
не обязательно, для того, чтобы торопливый читатель не принял
часть WHILE за начало оператора цикла WHILE.
    Упражнение 3-3.
    --------------
    При представлении  чисел  в  двоичном дополнительном коде
наш вариант ITOA не справляется  с  наибольшим  отрицательным
числом, т.е.  Со значением N рAвным -2 в степени м-1, где м -
размер слова. объясните почему. Измените программу так, чтобы
она правильно печатала это значение на любой машине.
    Упражнение 3-4.
    --------------
    Напишите аналогичную    функцию    ITOB(N,S),     которая
преобразует целое   без  знака  N  в  его двоичное символьное
представление в S.  Запрограммируйте функцию  ITOH,   которая
преобразует целое в шестнадцатеричное представление.
    Упражнение 3-5.
    ---------------
    Напишите вариант ITOA,  который  имеет  три,   а  не  два
аргумента. Третий     аргумент  -  минимальная  ширина  поля;
преобразованное число     должно,    если   это   необходимо,
дополняться слева пробелами,  так чтобы оно имело достаточную
ширину.
     
     
     
     
     
                        
     
     
             3.7. Оператор BREAK
 
    Иногда бывает удобным иметь возможность управлять выходом
из цикла  иначе,  чем проверкой условия в начале или в конце.
Оператор BRеак позволяет выйти из операторов FOR,  WHILE и DO
до окончания   цикла  точно  так же,  как и из переключателя.
Оператор BREAK  приводит  к  немедленному  выходу  из  самого
внутреннего охватывающего его цикла (или переключателя).
    Следующая программа удаляет хвостовые пробелы и табуляции
из конца  каждой строки файла ввода.  Она использует оператор
BREAK для выхода  из  цикла,   когда  найден  крайний  правый
отличный от пробела и табуляции символ.
 
     #DEFINE MAXLINE 1000
     MAIN()    /* REMOVE TRAILING BLANKS AND TABS */
     {
     INT N;
     CHAR LINE[MAXLINE];
 
     WHILE ((N = GETLINE(LINE,MAXLINE)) > 0) {
      WHILE (--N >= 0)
            IF (LINE[N] != ' ' && LINE[N] != '\T'
            && LINE[N] != '\N')
                  BREAK;
      LINE[N+1] = '\0';
      PRINTF("%S\N",LINE);
     }
     }
 
    Функция GETLINE возвращает длину строки.  Внутренний цикл
начинается с последнего  символа  LINE  (напомним,   что  --N
уменьшает N   до  использования  его  значения)  и движется в
обратном направлении в  поиске  первого  символа  ,   который
отличен от   пробела,   табуляции  или  новой  строки.   Цикл
прерывается, когда    либо  найден  такой  символ,   либо   N
становится отрицательным     (т.е.,   когда  просмотрена  вся
строка). Советуем    вам  убедиться,   что  такое   поведение
правильно и   в  том  случае,  когда строка состоит только из
символов пустых промежутков.
    В качестве  альтернативы  к BREAK можно ввести проверку в
 сам цикл:
 
    WHILE ((N = GETLINE(LINE,MAXLINE)) > 0) {
     WHILE (--N >= 0
         && (LINE[N] == ' ' \!\! LINE[N] == '\T'
         \!\! LINE[N] == '\N'))
               ;
       ...
    }
 
    Это уступает  предыдущему  варианту,   так  как  проверка
становится труднее для понимания.  Проверок,  которые требуют
переплетения &&,  \!\!,  !  И круглых скобок,  по возможности
следует избегать.
     
     
     
    
     
             3.8. Оператор CONTINUE
 
    Оператор CONTINUE   родственен   оператору   BRеак,    но
используется реже;   он  приводит к началу следующей итерации
охватывающего цикла (FOR,  WHILE,  DO ).  В циклах WHILE и DO
это означает      непосредственный   переход   к   выполнению
проверочной части; в цикле FOR управление передается  на  шаг
реинициализации. (Оператор    CONTINUE  применяется  только в
циклах, но  не в переключателях.   Оператор  CONTINUE  внутри
переключателя внутри   цикла  вызывает  выполнение  следующей
итерации цикла).
    В качестве    примера    приведем    фрагмент,    который
обрабатывает только    положительные   элементы   массива   а
отрицательные значения пропускаются.
 
    FOR (I = 0; I < N; I++) {
     IF (A[I] < 0) /* SKIP NEGATIVE ELEMENTS */
           CONTINUE;
         ...  /* DO POSITIVE ELEMENTS */
    }
 
    Оператор CONTINUE часто используется,  когда  последующая
часть цикла оказывается слишком сложной, так что рассмотрение
условия, обратного проверяемому, приводит к слишком глубокому
уровню вложенности программы.
 
    Упражнение 3-6.
    --------------
    Напишите программу  копирования  ввода  на  вывод,  с тем
исключением, что из каждой группы последовательных одинаковых
строк выводится   только  одна.  (Это простой вариант утилиты
UNIQ систем UNIX).
     
     
     
     
     
      
     
             3.9. Оператор GOTO и метки
 
    В языке   "C"  предусмотрен  и  оператор  GOTO,   которым
бесконечно злоупотребляют,    и  метки  для   ветвления.    С
формальной точки   зрения  оператор  GOTO никогда не является
необходимым, и  на практике почти всегда можно  обойтись  без
него. Мы не использовали GOTO в этой книге.
    Тем не менее,  мы укажем несколько ситуаций, где оператор
GOTO может найти свое место.  Наиболее  характерным  является
его использование   тогда,  когда нужно прервать выполнение в
некоторой глубоко вложенной структуре,  например, выйти сразу
из двух   циклов.   Здесь нельзя непосредственно использовать
оператор BREAK,  так как он прерывает только самый внутренний
цикл. Поэтому:
 
      FOR ( ... )
         FOR ( ... )    {
                 ...
                 IF (DISASTER)
          GOTO ERROR;
         }
      ...
 
    ERROR:
       CLEAN UP THE MESS
     
    Если программа  обработки  ошибок  нетривиальна  и ошибки
могут возникать в нескольких местах,   то  такая  организация
оказывается удобной.   Метка имеет такую же форму,  что и имя
переменной, и  за ней всегда следует двоеточие.  Метка  может
быть приписана  к любому оператору той же функции,  в которой
находится оператор GOTO.
    В качестве другого примера рассмотрим  задачу  нахождения
первого отрицательного     элемента   в   двумерном  массиве.
(Многомерные массивы рассматриваются в главе 5).  Вот одна из
возможностей:
 
      FOR (I = 0; I < N; I++)
         FOR (J = 0; J < M; J++)
                 IF (V[I][J] < 0)
          GOTO FOUND;
         /* DIDN'T FIND */
      ...
    FOUND:
      /* FOUND ONE AT POSITION I, J */
      ...
 
    Программа, использующая оператор GOTO,  всегда может быть
написана без   него,   хотя,   возможно,   за счет повторения
некоторых проверок   и  введения  дополнительных  переменных.
Например, программа поиска в массиве примет вид:
 
    FOUND = 0;
    FOR (I = 0; I < N && !FOUND; I++)
       FOR (J = 0; J < M && !FOUND; J++)
               FOUND = V[I][J] < 0;
    IF (FOUND)
       /* IT WAS AT I-1, J-1 */
       ...
    ELSE
       /* NOT FOUND */
       ...
 
    Хотя мы не являемся в этом вопросе догматиками,  нам  все
же кажется,  что если и нужно использовать оператор GOTO,  то
весьма умеренно.
     
     
     
     
     
 

         4. Функции и структура программ.

    Функции разбивают  большие   вычислительные   задачи   на
маленькие подзадачи и позволяют использовать в работе то, что
уже сделано другими,  а не  начинать  каждый  раз  с  пустого
места. Соответствующие    функции часто могут скрывать в себе
детали проводимых в разных частях программы операций,   знать
которые нет необходимости,  проясняя тем самым всю программу,
как целое, и облегчая мучения при внесении изменений.
    Язык "C" разрабатывался со  стремлением  сделать  функции
эффективными и   удобными  для  использования;  "C"-программы
обычно состоят из большого числа маленьких функций,  а не  из
нескольких больших.   Программа может размещаться в одном или
нескольких исходных файлах любым  удобным  образом;  исходные
файлы могут   компилироваться  отдельно  и загружаться вместе
наряду со скомпилированными ранее функциями из библиотек.  Мы
здесь не  будем вдаваться в детали этого процесса,  поскольку
они зависят от используемой системы.
    Большинство программистов      хорошо      знакомы      с
"библиотечными" функциями   для  ввода  и  вывода  /GETCHAR ,
PUTCHAR/ и для численных расчетов /SIN,  COS,  SQRT/.  В этой
главе мы сообщим больше о написании новых функций.









             4.1. Основные сведения.

    Для начала   давайте  разработаем  и  составим  программу
печати каждой строки ввода,   которая  содержит  определенную
комбинацию символов.   /Это - специальный случай утилиты GREP
системы "UNIX"/.  Например,  при поиске  комбинации  "THE"  в
наборе строк

         NOW IS THE TIME
         FOR ALL GOOD
         MEN TO COME TO THE AID
         OF THEIR PARTY
    в качестве выхода получим
 
         NOW IS THE TIME
         MEN TO COME TO THE AID
         OF THEIR PARTY
 
 
    основная схема  выполнения  задания  четко разделяется на
 три части:
 
       WHILE (имеется еще строка)
       IF (строка содержит нужную комбинацию)
             вывод этой строки
         
    Конечно, возможно  запрограммировать  все действия в виде
одной основной процедуры,  но лучше использовать естественную
структуру задачи  и представить каждую часть в виде отдельной
функции. С  тремя маленькими кусками легче иметь дело,  чем с
одним большим, потому что отдельные не относящиеся к существу
дела детали можно включить в функции и уменьшить  возможность
нежелательных взаимодействий.    Кроме того,  эти куски могут
оказаться полезными сами по себе.
    "Пока имеется еще строка" - это GETLINE, функция, которую
мы запрограммировали  в главе 1,  а "вывод этой строки" - это
функция PRINTF,  которую уже кто-то подготовил для нас.   Это
значит, что    нам  осталось  только  написать  процедуру для
определения, содержит  ли строка данную  комбинацию  символов
или нет.    Мы  можем  решить  эту  проблему,   позаимствовав
разработку из PL/1:  функция INDEX(S,т)  возвращает  позицию,
или индекс,  строки S,  где начинается строка T, и -1, если S
не содержит т . В качестве начальной позиции мы используем 0,
а не  1,  потому что в языке "C" массивы начинаются с позиции
нуль. Когда    нам  в  дальнейшем  понадобится  проверять  на
совпадение более  сложные конструкции,  нам придется заменить
только функцию INDEX; остальная часть программы останется той
же самой.
    После того,   как  мы   потратили   столько   усилий   на
разработку, написание    программы  в деталях не представляет
затруднений. ниже  приводится целиком вся программа,  так что
вы можете   видеть,   как соединяются вместе отдельные части.
Комбинация символов, по которой производится поиск, выступает
пока в  качестве символьной строки в аргументе функции INDEX,
что не является самым общим механизмом.  Мы скоро вернемся  к
обсуждению вопроса   об инициализации символьных массивов и в
главе 5 покажем,  как сделать комбинацию символов параметром,
которому присваивается  значение в ходе выполнения программы.
Программа также содержит новый вариант функции  GETLINE;  вам
может оказаться полезным сравнить его с вариантом из главы 1.
 
     #DEFINE  MAXLINE  1000
     MAIN()  /* FIND ALL LINES MATCHING A PATTERN */
     {
          CHAR LINE[MAXLINE];
 
          WHILE (GETLINE(LINE, MAXLINE) > 0)
        IF (INDEX(LINE, "THE") >= 0)
           PRINTF("%S", LINE);
      }
 
     GETLINE(S, LIM) /* GET LINE INTO S, RETURN LENGTH *
      CHAR S[];
      INT LIM;
      {
      INT C, I;
 
      I = 0;
     WHILE(--LIM>0 && (C=GETCHAR()) != EOF && C != '\N')
      S[I++] = C;
      IF (C == '\N')
      S[I++] = C;
      S[I] = '\0';
      RETURN(I);
      }
 
      INDEX(S,T) /* RETURN INDEX OF T IN S,-1 IF NONE */
      CHAR S[], T[];
      {
            INT I, J, K;
 
       FOR (I = 0; S[I] != '\0'; I++) {
       FOR(J=I, K=0; T[K] !='\0' && S[J] == T[K]; J++; K++)
         ;
         IF (T[K] == '\0')
           RETURN(I);
          }
      RETURN(-1);
      }
     
    Каждая функция имеет вид имя (список аргументов, если они
имеются) описания аргументов, если они имеются
 
      {
          описания и операторы , если они имеются
      }
 
 
    Как и  указывается,  некоторые части могут отсутствовать;
минимальной функцией является
 
 
         DUMMY ()  { }
 
    которая не совершает никаких действий.
 
    /Такая ничего  не  делающая  функция  иногда  оказывается
удобной для   сохранения  места  для   дальнейшего   развития
программы/. если    функция  возвращает  что-либо отличное от
целого значения,  то перед ее именем может  стоять  указатель
типа; этот вопрос обсуждается в следующем разделе.
    Программой является просто  набор  определений  отдельных
функций. Связь между функциями осуществляется через аргументы
и возвращаемые функциями значения /в этом случае/;  ее  можно
также осуществлять   через внешние переменные.  Функции могут
располагаться в исходном  файле  в  любом  порядке,   а  сама
исходная программа может размещаться на нескольких файлах, но
так, чтобы ни одна функция не расщеплялась.
    Оператор RETURN   служит   механизмом   для   возвращения
значения из   вызванной  функции  в  функцию,   которая к ней
обратилась. За RETURN может следовать любое выражение:
 
        RETURN (выражение)
 
    Вызывающая функция   может   игнорировать    возвращаемое
значение, если  она этого пожелает.  Более того, после RETURN
может не быть вообще никакого  выражения;  в  этом  случае  в
вызывающую программу     не   передается  никакого  значения.
Управление также   возвращется  в  вызывающую  программу  без
передачи какого-либо   значения  и  в  том случае,  когда при
выполнении мы "проваливаемся"  на  конец  функции,   достигая
закрывающейся правой фигурной скобки. Если функция возвращает
значение из одного места и не возвращает никакого значения из
другого места,    это  не является незаконным,  но может быть
признаком каких-то неприятностей.  В любом случае "значением"
функции, которая    не возвращает значения,  несомненно будет
мусор. Отладочная программа LINT проверяет такие ошибки.
    Механика компиляции      и     загрузки     "C"-программ,
расположенных в  нескольких  исходных  файлах,   меняется  от
системы к  системе.  В системе "UNIX",  например,  эту работу
выполняет команда 'CC',  упомянутая в главе 1.   Предположим,
что три   функции находятся в трех различных файлах с именами
MAIN.с, GETLINE.C и INDEX.с . Тогда команда
       
        CC MAIN.C GETLINE.C INDEX.C
 
компилирует эти три файла,  помещает полученный настраиваемый
объектный код в файлы MAIN.O, GETLINE.O и INDEX.O и загружает
их всех в выполняемый файл, называемый A.OUT .
    Если имеется какая-то ошибка,  скажем в MAIN.C,  то  этот
файл можно   перекомпилировать  отдельно и загрузить вместе с
предыдущими объектными файлами по команде
 
        CC MAIN.C GETLIN.O INDEX.O
 
    Команда 'CC' использует соглашение о наименовании с  ".с"
и ".о" для того,  чтобы отличить исходные файлы от объектных.
    Упражнение 4-1.
    ----------------
    Составьте программу  для  функции  RINDEX(S,T),   которая
возвращает позицию самого правого вхождения т в S и -1,  если
S не содержит T.

     
     
     
     
     
     
     
 

     
     
     
     
     
     
     
    
   
     
      4.2. Функции, возвращающие нецелые значения.
 
    До сих пор ни одна из наших программ не содержала какого-
либо описания типа функции.  Дело в том,   что  по  умолчанию
функция неявно   описывается своим появлением в выражении или
операторе, как, например, в
 
      WHILE (GETLINE(LINE, MAXLINE) > 0)
 
    Если некоторое  имя,   которое  не  было  описано  ранее,
появляется в выражении и за ним следует левая круглая скобка,
то оно по контексту считается именем некоторой функции. Кроме
того, по умолчанию предполагается, что эта функция возвращает
значение типа INT.  Так как в выражениях CHAR преобразуется в
INT, то  нет необходимости описывать  функции,   возвращающие
CHAR. Эти     предположения  покрывают  большинство  случаев,
включая все приведенные до сих пор примеры.
    Но что  происходит,   если  функция   должна   возвратить
значение какого-то  другого типа ?  Многие численные функции,
такие как   SQRT,   SIN  и  COS  возвращают  DOUBLE;   другие
специальные функции  возвращают значения других типов.  Чтобы
показать, как  поступать в этом случае,   давайте  напишем  и
используем функцию   ATOF(S),  которая преобразует строку S в
эквивалентное ей плавающее число двойной  точности.   Функция
ATOF является расширением атоI,  варианты которой мы написали
в главах  2  и  3;  она  обрабатывает  необязательно  знак  и
десятичную точку,   а также целую и дробную часть,  каждая из
которых может как присутствовать,  так  и  отсутствовать./эта
процедура преобразования   ввода  не очень высокого качества;
иначе она бы заняла больше места, чем нам хотелось бы/.
    Во-первых, сама  ATOF  должна описывать тип возвращаемого
ею значения,   поскольку  он  отличен  от  INT.   Так  как  в
выражениях тип FLOAT преобразуется в DOUBLE,  то нет никакого
смысла в том,  чтобы ATOF возвращала FLOAT; мы можем с равным
успехом воспользоваться дополнительной точностью,  так что мы
полагаем, что  возвращаемое значение типа DOUBLE.   Имя  типа
должно стоять перед именем функции, как показывается ниже:

     DOUBLE ATOF(S) /* CONVERT STRING S TO DOUBLE */
     CHAR S[];
     {
       DOUBLE VAL, POWER;
       INT  I, SIGN;
 
   FOR(I=0; S[I]==' ' \!\! S[I]=='\N' \!\! S[I]=='\T'; I++)
        ;       /* SKIP WHITE SPACE */
       SIGN = 1;
       IF (S[I] == '+' \!\! S[I] == '-')   /* SIGN */
          SIGN = (S[I++] == '+') ? 1 : -1;
       FOR (VAL = 0; S[I] >= '0' && S[I] <= '9'; I++)
          VAL = 10 * VAL + S[I] - '0';
       IF (S[I] == '.')
          I++;
     FOR (POWER = 1; S[I] >= '0' && S[I] <= '9'; I++) {
          VAL = 10 * VAL + S[I] - '0';
          POWER *= 10;
        }
        RETURN(SIGN * VAL / POWER);
     }
     
    Вторым, но столь же важным,  является то,  что вызывающая
функция должна объявить о том,  что ATOF возвращает значение,
отличное от INT типа.  Такое  объявление  демонстрируется  на
примере следующего    примитивного  настольного  калькулятора
/едва пригодного для подведения баланса  в  чековой  книжке/,
который считывает по одному числу на строку, причем это число
может иметь знак, и складывает все числа, печатая сумму после
каждого ввода.
 
     #DEFINE   MAXLINE   100
     MAIN()  /* RUDIMENTARY DESK CALKULATOR */
     {
          DOUBLE SUM, ATOF();
          CHAR LINE[MAXLINE];
 
          SUM = 0;
          WHILE (GETLINE(LINE, MAXLINE) > 0)
        PRINTF("\T%.2F\N",SUM+=ATOF(LINE));
 
 
    Описание
 
          DOUBLE  SUM, ATOF();
    
говорит, что SUM является переменной типа DOUBLE , и что ATOF
является функцией,  возвращающей значение типа DOUBLE .   Эта
мнемоника означает,  что значениями как SUM,  так и ATOF(...)
являются плавающие числа двойной точности.
    Если функция  ATOF  не будет описана явно в обоих местах,
то в "C" предполагается, что она возвращает целое значение, и
вы получите бессмысленный ответ. Если сама ATOF и обращение к
ней в MAIN имеют несовместимые типы и находятся в одном и том
же файле,  то это будет обнаружено компилятором. Но если ATOF
была скомпилирована отдельно /что более  вероятно/,   то  это
несоответствие не   будет  зафиксировано,  так что ATOF будет
возвращать значения   типа  DOUBLE,   с  которым  MAIN  будет
обращаться, как    с  INT  ,   что  приведет  к бессмысленным
результатам. /Программа LINT вылавливает эту ошибку/.
    Имея ATOF, мы, в принципе, могли бы с ее помощью написать
ATOI (преобразование строки в INT):
 
      ATOI(S)   /* CONVERT STRING S TO INTEGER */
      CH AR S[];
      {
         DOUBLE ATOF();
 
         RETURN(ATOF(S));
      }
       
    Обратите внимание   на   структуру  описаний  и  оператор
RETURN. Значение выражения в
 
     RETURN (выражение)
 
всегда преобразуется к типу функции перед выполнением  самого
возвращения. Поэтому     при  появлении  в  операторе  RETURN
значение функции атоF,  имеющее  тип  DOUBLE,   автоматически
преобразуется в  INT,  поскольку функция ATOI возвращает INT.
(Как обсуждалось   в  главе  2,   преобразование  значения  с
плавающей точкой    к  типу  INT  осуществляется  посредством
отбрасывания дробной части).
    Упражнение 4-2.
    ----------------
    Расширьте ATOF таким образом,  чтобы она могла работать с
числами вида
 
     123.45е-6
 
где за  числом  с  плавающей  точкой  может  следовать  'E' и
показатель экспоненты, возможно со знаком.
  
     
     
     
     
     
     
     
      
     
            4.3. Еще об аргументах функций.
 
    В главе 1 мы уже обсуждали  тот  факт  ,   что  аргументы
функций передаются   по  значению,   т.е.   вызванная функция
получает свою временную копию каждого аргумента,   а  не  его
адрес. это     означает,   что  вызванная  функция  не  может
воздействовать на исходный  аргумент  в  вызывающей  функции.
Внутри функции каждый аргумент по существу является локальной
переменной, которая инициализируется тем значением, с которым
к этой функции обратились.
    Если в  качестве аргумента функции выступает имя массива,
то передается адрес начала этого массива;  сами  элементы  не
копируются. Функция      может   изменять  элементы  массива,
используя индексацию и адрес начала.  Таким образом,   массив
передается по ссылке. В главе 5 мы обсудим, как использование
указателей позволяет функциям воздействовать на  отличные  от
массивов переменные в вызывающих функциях.
    Между прочим,  несуществует полностью удовлетворительного
способа написания переносимой  функции  с  переменным  числом
аргументов. Дело    в  том,  что нет переносимого способа,  с
помощью которого   вызванная  функция  могла  бы  определить,
сколько аргументов   было  фактически  передано  ей  в данном
обращении. Таким  образом,  вы,  например, не можете написать
действительно переносимую   функцию,  которая будет вычислять
максимум от   произвольного  числа  аргументов,   как  делают
встроенные функции MAX в фортране и PL/1.
    Обычно со  случаем переменного числа аргументов безопасно
иметь дело,  если вызванная функция не использует аргументов,
которые ей   на  самом  деле  не  были переданы,  и если типы
согласуются. Самая  распространенная в языке  "C"  функция  с
переменным числом   -  PRINTF  .   Она  получает  из  первого
аргумента информацию,    позволяющую  определить   количество
остальных аргументов   и  их  типы.   Функция PRINTF работает
совершенно неправильно,  если вызывающая функция передает  ей
недостаточное количество   аргументов,   или  если их типы не
согласуются с типами,  указанными в  первом  аргументе.   Эта
функция не является переносимой и должна модифицироваться при
использовании в различных условиях.
    Если же   типы  аргументов  известны,   то  конец  списка
аргументов можно отметить,   используя  какое-то  соглашение;
например, считая,       что  некоторое  специальное  значение
аргумента (часто нуль) является признаком конца аргументов.

     
     
     
     
     
    
             4.4. Внешние переменные.
 
    Программа на  языке  "C"  состоит   из   набора   внешних
объектов, которые  являются либо переменными, либо функциями.
Термин "внешний"      используется    главным    образом    в
противопоставление термину "внутренний",  которым описываются
аргументы и автоматические переменные,   определенные  внурти
функций. Внешние переменные определены вне какой-либо функции
и, таким  образом,  потенциально доступны для многих функций.
Сами функции   всегда  являются внешними,  потому что правила
языка "C" не разрешают определять одни функции внутри других.
По умолчанию      внешние   переменные   являются   также   и
"глобальными", так   что  все  ссылки  на  такую  переменную,
использующие одно     и   то   же   имя   (даже  из  функций,
скомпилированных независимо), будут ссылками на одно и то же.
В этом смысле внешние переменные аналогичны переменным COмMON
в фортране и EXTERNAL  в  PL/1.   Позднее  мы  покажем,   как
определить внешние переменные и функции таким образом,  чтобы
они были доступны не глобально,  а только в  пределах  одного
исходного файла.
    В силу  своей  глобальной  доступности внешние переменные
предоставляют другую,  отличную от аргументов и  возвращаемых
значений, возможность    для  обмена данными между функциями.
Если имя внешней переменной каким-либо образом  описано,   то
любая функция имеет доступ к этой переменной,  ссылаясь к ней
по этому имени.
    В случаях,  когда связь между функциями осуществляется  с
помощью большого     числа  переменных,   внешние  переменные
оказываются более удобными и эффективными,  чем использование
длинных списков аргументов.  Как,  однако, отмечалось в главе
1, это    соображение  следует  использовать  с  определенной
осторожностью, так     как  оно  может  плохо  отразиться  на
структуре программ и приводить к программам с большим  числом
связей по данным между функциями.
    Вторая причина использования внешних переменных связана с
инициализацией. В  частности,   внешние  массивы  могут  быть
инициализированы а  автоматические нет.  Мы рассмотрим вопрос
об инициализации в конце этой главы.
    Третья причина     использования    внешних    переменных
обусловлена их областью действия  и  временем  существования.
Автоматические переменные являются внутренними по отношению к
функциям; они возникают при входе в функцию  и  исчезают  при
выходе из   нее.   Внешние переменные,  напротив,  существуют
постоянно. Они  не появляютя и не исчезают,   так  что  могут
сохранять свои   значения  в  период  от  одного  обращения к
функции до другого. В силу этого, если две функции используют
некоторые общие данные, причем ни одна из них не обращается к
другой ,  то часто наиболее удобным оказывается  хранить  эти
общие данные в виде внешних переменных,  а не передавать их в
функцию и обратно с помощью аргументов.
    Давайте продолжим  обсуждение  этого  вопроса  на большом
примере. Задача  будет состоять в написании другой  программы
для калькулятора,   лучшей,чем предыдущая.  Здесь допускаются
операции +,-,*,/   и  знак  =  (для   выдачи   ответа).вместо
инфиксного представления     калькулятор  будет  использовать
обратную польскую   нотацию,поскольку  ее   несколько   легче
реализовать.в обратной   польской  нотации  знак  следует  за
операндами; инфиксное выражение типа
 
        (1-2)*(4+5)=
     
    записывается в виде
    
        12-45+*=
    
    круглые скобки при этом не нужны
 
    Реализация оказывается   весьма   простой.каждый  операнд
помещается в стек; когда поступает знак операции,нужное число
операндов (два   для  бинарных  операций)   вынимается,к  ним
применяется операция и результат направляется обратно в стек.
так в   приведенном  выше  примере  1 и 2 помещаются в стек и
затем заменяются их разностью,  -1.после этого 4 и 5 вводятся
в стек   и затем заменяются своей суммой,9.далее числа -1 и 9
заменяются в стеке на их  произведение,равное  -9.операция  =
печатает верхний   элемент  стека,   не  удаляя  его (так что
промежуточные вычисления могут быть проверены).
    Сами операции помещения чисел  в  стек  и  их  извлечения
очень просты,но,   в связи с включением в настоящую программу
обнаружения ошибок     и    восстановления,они    оказываются
достаточно длинными.    Поэтому  лучше  оформить  их  в  виде
отдельных функций,чем повторять соответствующий текст повсюду
в программе.  Кроме того, нужна отдельная функция для выборки
из ввода следующей операции  или  операнда.   Таким  образом,
структура программы имеет вид:
 
     WHILE( поступает операция или операнд, а не конец
        IF ( число )
              поместить его в стек
        ELSE IF ( операция )
             вынуть операнды из стека
             выполнить операцию
             поместить результат в стек
        ELSE
             ошибка
 
    Основной вопрос, который еще не был обсужден, заключается
в том,где   поместить  стек,   т.  Е.  Какие процедуры смогут
обращаться к нему непосредственно. Одна из таких возможностей
состоит в   помещении  стека в MAIN и передачи самого стека и
текущей позиции в стеке функциям,  работающим со стеком.   Но
функции MAIN   нет  необходимости  иметь  дело с переменными,
управляющими стеком; ей  естественно  рассуждать  в  терминах
помещения чисел  в стек и извлечения их оттуда.  В силу этого
мы решили сделать стек и связанную с ним информацию  внешними
переменными ,  доступными функциям PUSH (помещение в стек)  и
POP (извлечение из стека), но не MAIN.
    Перевод этой схемы в программу достаточно прост.  Ведущая
программа является по существу большим переключателем по типу
операции или операнду; это,  по-видимому,  более  характерное
применеие переключателя,        чем    то,     которое   было
продемонстрировано в главе 3.
     
     #DEFINE MAXOP   20  /* MAX SIZE OF OPERAND, OPERАTOR *
     #DEFINE NUMBER '0'  /* SIGNAL THAT NUMBER FOUND */
     #DEFINE TOOBIG '9'  /* SIGNAL THAT STRING IS TOO BIG *
         
        MAIN()  /* REVERSE POLISH DESK CALCULATOR */
        /(
         INT TUPE;
         CHAR S[MAXOP];
         DOUBLE OP2,ATOF(),POP(),PUSH();
 
         WHILE ((TUPE=GETOP(S,MAXOP)) !=EOF);
           SWITCH(TUPE) /(
           CASE NUMBER:
                PUSH(ATOF(S));
                BREAK;
           CASE '+':
                PUSH(POP()+POP());
                BREAK;
           CASE '*':
                PUSH(POP()*POP());
                BREAK;
           CASE '-':
                OP2=POP();
                PUSH(POP()-OP2);
                BREAK;
           CASE '/':
                OP2=POP();
                IF (OP2 != 0.0)
        PUSH(POP()/OP2);
                ELSE
                   PRINTF("ZERO DIVISOR POPPED\N");
                BREAK;
           CASE '=':
                PRINTF("\T%F\N",PUSH(POP()));
                BREAK;
           CASE 'C':
                CLEAR();
                BREAK;
           CASE TOOBIG:
                PRINTF("%.20S ... IS TOO LONG\N",S)
                BREAK;
           /)
        /)
        #DEFINE MAXVAL 100 /* MAXIMUM DEPTH OF VAL STACK */
 
        INT SP = 0;        /* STACK POINTER */
        DOUBLE VAL[MAXVAL]; /*VALUE STACK */
        DOUBLE PUSH(F)    /* PUSH F ONTO VALUE STACK */
        DOUBLE F;
        /(
         IF (SP < MAXVAL)
                 RETURN(VAL[SP++] =F);
         ELSE    /(
                 PRINTF("ERROR: STACK FULL\N");
                 CLEAR();
                 RETUR N(0);
         /)
         /)
 
        DOUBLE POP()   /* POP TOP VALUE FROM STEACK */
        /(
         IF (SP > 0)
                  RETURN(VAL[--SP]);
          ELSE    /(
                 PRINTF("ERROR: STACK EMPTY\N");
                 CLEAR();
                 RETURN(0);
         /)
         /)
 
        CLEAR()       /* CLEAR STACK */
        /(
           SP=0;
        /)
 
    Команда C очищает стек с помощью функции CLEAR,   которая
также используется   в случае ошибки функциями PUSH и POP.  к
функции GETOP мы очень скоро вернемся.
    Как уже   говорилось  в  главе  1,   переменная  является
внешней, если  она определена вне тела какой бы  то  ни  было
функции. Поэтому    стек  и  указатель стека,  которые должны
использоваться функциями PUSH,  POP и CLEAR,  определены  вне
этих трех   функций.   Но сама функция MAIN не ссылается ни к
стеку, ни    к  указателю  стека  -  их   участие   тщательно
замаскировано. В  силу этого часть программы, соответствующая
операции = , использует конструкцию
  
        PUSH(POP());
    
для того,   чтобы проанализировать верхний элемент стека,  не
изменяя его.
    Отметим также,   что так как операции + и * коммутативны,
порядок, в    котором  объединяются   извлеченные   операнды,
несущественен, но    в  случае  операций  -  и  /  необходимо
различать левый и правый операнды.
    Упражнение 4-3.
    ---------------
    Приведенная основная  схема  допускает   непосредственное
расширение возможностей    калькулятора.   Включите  операцию
деления по модулю /%/  и  унарный  минус.   Включите  команду
"стереть", которая    удаляет верхний элемент стека.  Введите
команды для работы с переменными.  /Это просто,   если  имена
переменных будут    состоять  из  одной  буквы  из  имеющихся
двадцати шести букв/.

     
     
     
      
     
         4.5. Правила, определяющие область действия.
 
    Функции и   внешние   переменные,    входящие   в  состав
"C"-программы, не    обязаны  компилироваться   одновременно;
программа на  исходном языке может располагаться в нескольких
файлах, и  ранее скомпилированные процедуры могут загружаться
из библиотек. Два вопроса представляют интерес:
    Как следует   составлять   описания,    чтобы  переменные
правильно воспринимались во время компиляции ?
    Как следует   составлять   описания,    чтобы  обеспечить
правильную связь частей программы при загрузке ?
 
           4.5.1. Область действия.
 
    Областью действия имени является та часть  программы,   в
которой это   имя определено.  Для автоматической переменной,
описанной в начале функции,  областью  действия  является  та
функция, в  которой описано имя этой переменной, а переменные
из разных функций,  имеющие  одинаковое  имя,   считаются  не
относящимися друг    к  другу.   Это  же  справедливо  и  для
аргументов функций.
    Область действия  внешней  переменной   простирается   от
точки, в    которой она объявлена в исходном файле,  до конца
этого файла.  Например,  если VAL,  SP,  PUSH,  POP  и  CLEAR
определены в одном файле в порядке, указанном выше, а именно:
 
          INT  SP = 0;
          DOUBLE  VAL[MAXVAL];
 
          DOUBLE  PUSH(F) {...}
 
          DOUBLE  POP()  {...}
 
          CLEAR()  {...}
 
то переменные VAL и SP можно использовать в PUSH, POP и CLEAR
прямо по имени; никакие дополнительные описания не нужны.
    С другой  стороны,   если  нужно  сослаться  на   внешнюю
переменную до   ее  определения,   или  если такая переменная
определена в   файле,   отличном  от  того,   в  котором  она
используется, то необходимо описание EXTERN.
    Важно различать   описание   внешней   переменной   и  ее
определение. описание  указывает свойства переменной /ее тип,
размер и   т.д./;  определение  же  вызывает  еще и отведение
памяти. Если  вне какой бы  то  ни  было  функции  появляются
строчки
 
        INT  SP;
        DOUBLE  VAL[MAXVAL];
 
то они  определяют  внешние  переменные  SP  и VAL,  вызывают
отведение памяти для них и служат  в  качестве  описания  для
остальной части этого исходного файла.  В то же время строчки
 
        EXTERN  INT  SP;
        EXTERN  DOUBLE  VAL[];
 
описывают в остальной части этого исходного файла  переменную
SP как   INT,   а VAL как массив типа DOUBLE /размер которого
указан в другом месте/, но не создают переменных и не отводят
им места в памяти.
    Во всех файлах,  составляющих исходную программу,  должно
содержаться только   одно  определение  внешней   переменной;
другие файлы   могут  содержать описания EXTERN для доступа к
ней. /Описание  EXTERN может иметься  и  в  том  файле,   где
находится определение/.       Любая   инициализация   внешней
переменной проводится только в  определении.   В  определении
должны указываться   размеры  массивов,   а в описании EXTERN
этого можно не делать.
    Хотя подобная организация приведенной  выше  программы  и
маловероятна, но    VAL  и  SP  могли  бы  быть  определены и
инициализированы в одном файле,  а функция PUSH,  POP и CLEAR
определены в   другом.   В  этом  случае  для  связи  были бы
необходимы следующие определения и описания:
 
   в файле 1:
   ----------
 
         INT SP = 0;  /* STACK POINTER */
         DOUBLE VAL[MAXVAL]; /* VALUE STACK */
 
   в файле 2:
   ----------
 
         EXTERN INT SP;
         EXTERN DOUBLE VAL[];
 
         DOUBLE PUSH(F)  {...}
 
         DOUBLE POP()   {...}
 
         CLEAR()   {...}
 
 
так как описания EXTERN 'в файле 1' находятся выше и вне трех
указанных функций,   они относятся ко всем ним; одного набора
описаний достаточно для всего 'файла 2'.
    Для программ  большого  размера  обсуждаемая позже в этой
главе возможность включения файлов, #INCLUDE, позволяет иметь
во всей   программе  только  одну  копию  описаний  EXTERN  и
вставлять ее в каждый исходный файл во время его  компиляции.
    Обратимся теперь  к  функции  GETOP,  выбирающей из файла
ввода следующую операцию или операнд. Основная задача проста:
пропустить пробелы,    знаки  табуляции и новые строки.  Если
следующий символ отличен от цифры  и  десятичной  точки,   то
возвратить его.   В противном случае собрать строку цифр /она
может включать десятичную  точку/  и  возвратить  NUMBER  как
сигнал о том, что выбрано число.
    Процедура существенно   усложняется,    если   стремиться
правильно обрабатывать   ситуацию,   когда   вводимое   число
оказывается слишком   длинным.  Функция GETOP считывает цифры
подряд /возможно с десятичной точкой/ и запоминает их,   пока
последовательность не     прерывается.    Если  при  этом  не
происходит переполнения,   то  функция  возвращает  NUMBER  и
строку цифр.   Если же число оказывается слишком длинным,  то
GETOP отбрасывает остальную часть строки из файла ввода,  так
что пользователь может просто перепечатать эту строку с места
ошибки; функция возвращает TOOBIG как сигнал о  переполнении.
 
          GETOP(S, LIM) /* GET NEXT OPRERATOR OR OPERAND */
          CHAR S[];
          INT LIM;
          {
            INT I, C;
 
           WHILE((C=GETCH())==' '\!\! C=='\T' \!\! C=='\N')
             ;
            IF (C != '.' && (C < '0' \!\! C > '9'))
             RETURN(C);
            S[0] = C;
             FOR(I=1; (C=GETCHAR()) >='0' && C <= '9'; I++)
             IF (I < LIM)
     
                S[I] = C;
           IF (C == '.') {   /* COLLECT FRACTION */
           IF (I < LIM)
               S[I] = C;
           FOR(I++;(C=GETCHAR()) >='0' && C<='9';I++)
               IF (I < LIM)
                   S[I] =C;
           }
           IF (I < LIM)  { /* NUMBER IS OK */
           UNGETCH(C);
           S[I] = '\0';
           RETURN (NUMBER);
 
          } ELSE { /* IT'S TOO BIG; SKIP REST OF LINE */
            WHILE (C != '\N' && C != EOF)
                   C = GETCHAR();
             S[LIM-1] = '\0';
            RETURN (TOOBIG);
          }
              }
   
    Что же представляют из себя функции 'GETCH' и  'UNGETCH'?
Часто так бывает,  что программа, считывающая входные данные,
не может определить,  что она прочла уже достаточно, пока она
не прочтет   слишком много.  Одним из примеров является выбор
символов, составляющих   число:   пока  не  появится  символ,
отличный от цифры,  число не закончено. Но при этом программа
считывает один лишний символ, символ, для которого она еще не
подготовлена.
    Эта проблема  была  бы  решена,  если бы было бы возможно
"прочесть обратно" нежелательный символ.  Тогда  каждый  раз,
прочитав лишний   символ,   программа  могла бы поместить его
обратно в файл ввода  таким  образом,   что  остальная  часть
программы могла бы вести себя так, словно этот символ никогда
не считывался.  к счастью,  такое неполучение  символа  легко
иммитировать, написав    пару  действующих совместно функций.
Функция GETCH доставляет следующий символ ввода,   подлежащий
рассмотрению; функция  UNGETCH помещает символ назад во ввод,
так что при следующем обращении к GETCH он будет возвращен.
    То, как эти функции совместно работают,   весьма  просто.
Функция UNGETCH     помещает  возвращаемые  назад  символы  в
совместно используемый буфер, являющийся символьным массивом.
Функция GETCH   читает  из этого буфера,  если в нем что-либо
имеется; если же буфер пуст,  она обращается к GETCHAR.   При
этом также   нужна  индексирующая  переменная,  которая будет
фиксировать позицию текущего символа в буфере.
    Так как  буфер  и  его  индекс   совместно   используются
функциями GETCH  и UNGETCH и должны сохранять свои значения в
период между обращениями,  они должны быть внешними для обеих
функций. Таким  образом,  мы можем написать GETCH,  UNGETCH и
эти переменные как:
 
       #DEFINE  BUFSIZE  100
       CHAR BUF[BUFSIZE]; /* BUFFER FOR UNGETCH */
       INT BUFP = 0; /* NEXT FREE POSITION IN BUF */
 
       GETCH() /* GET A (POSSIBLY PUSHED BACK) CHARACTER */
       {
          RETURN((BUFP > 0) ? BUF[--BUFP] : GETCHAR());
       }
 
           UNGETCH(C)  /* PUSH CHARACTER BACK ON INPUT */
       INT C;
       {
          IF (BUFP > BUFSIZE)
        PRINTF("UNGETCH: TOO MANY CHARACTERS\N");
          ELSE
        BUF [BUFP++] = C;
       }
 
    Мы использовали   для   хранения   возвращаемых  символов
массив, а  не отдельный символ,  потому  что  такая  общность
может пригодиться в дальнейшем.
    Упражнение  4-4.
    ----------------
    Напишите функцию UNGETS(S)  , которая будет возвращать во
ввод целую  строку.  Должна ли UNGETS иметь дело с BUF и BUFP
или она может просто использовать UNGETCH ?
    Упражнение  4-5.
    ----------------
    Предположите, что  может возвращаться только один символ.
Измените GETCH и UNGETCH соответствующим образом.
    Упражнение  4-6.
    ----------------
    Наши функции  GETCH  и  UNGETCH не обеспечивают обработку
возвращенного символа EOF переносимым образом.  Решите, каким
свойством должны обладать эти функции, если возвращается EOF,
и реализуйте ваши выводы.

     
     
     
     
  
     
            4.6. Статические переменные.
 
    Статические переменные  представляют  собой  третий класс
памяти, в  дополнении к автоматическим переменным и EXTERN, с
которыми мы уже встречались.
    Статические переменные могут быть либо внутренними,  либо
внешними. Внутренние статические переменные точно так же, как
и автоматические,  являются локальными для некоторой функции,
но, в отличие от автоматических, они остаются существовать, а
не появляются и исчезают вместе с обращением к этой  функции.
это означает,      что   внутренние   статические  переменные
обеспечивают постоянное,  недоступное извне  хранение  внутри
функции. Символьные строки, появляющиеся внутри функции, как,
например, аргументы      PRINTF   ,    являются   внутренними
статическими.
    Внешние статические  переменные  определены  в  остальной
части того  исходного файла,  в котором они описаны,  но не в
каком-либо другом файле.  Таким  образом,   они  дают  способ
скрывать имена,      подобные   BUF   и   BUFP  в  комбинации
GETCH-UNGETCH, которые  в силу их  совместного  использования
должны быть     внешними,    но  все  же  не  доступными  для
пользователей GETCH и UNGETCH , чтобы исключалась возможность
конфликта. Если эти две функции и две переменные объеденить в
одном файле следующим образом
 
      STATIC CHAR BUF[BUFSIZE]; /* BUFFER FOR UNGETCH */
      STATIC INT BUFP=0; /*NEXT FREE POSITION IN BUF */
      
      GETCH()  {...}
 
      UNGETCH()  {...}
 
то никакая другая функция не будет в состоянии  обратиться  к
BUF и   BUFP; фактически,  они не будут вступать в конфликт с
такими же именами из других файлов той же самой программы.
    Статическая память,   как  внутренняя,   так  и  внешняя,
специфицируется словом   STATIC  ,   стоящим  перед   обычным
описанием. Переменная  является внешней, если она описана вне
какой бы то ни было функции,  и внутренней,  если она описана
внутри некоторой функции.
    Нормально функции  являются  внешними объектами; их имена
известны глобально.  возможно,  однако,  объявить функцию как
STATIC ;   тогда  ее имя становится неизвестным вне файла,  в
котором оно описано.
    В языке "C" "STATIC" отражает не только постоянство, но и
степень того,   что можно назвать "приватностью".  Внутренние
статические объекты определены только внутри  одной  функции;
внешние статические     объекты   /переменные   или  функции/
определены только  внутри  того  исходного  файла,   где  они
появляются, и    их  имена не вступают в конфликт с такими же
именами переменных и функций из других файлов.
    Внешние статические переменные  и  функции  предоставляют
способ организовывать   данные и работающие с ними внутренние
процедуры таким образом,  что другие процедуры  и  данные  не
могут прийти   с  ними  в  конфликт  даже  по  недоразумению.
Например, функции GETCH и UNGETCH образуют "модуль" для ввода
и возвращения  символов; BUF и BUFP должны быть статическими,
чтобы они не были доступны извне.  Точно так же функции PUSH,
POP и   CLEAR формируют модуль обработки стека; VAR и SP тоже
должны быть внешними статическими.

     
     
     
     
     
    
     
     
     
            4.7. Регистровые переменные.
 
    Четвертый и    последний    класс    памяти    называется
регистровым. Описание  REGISTER указывает  компилятору,   что
данная переменная   будет  часто  использоваться.   Когда это
возможно, переменные, описанные как REGISTER, располагаются в
машинных регистрах, что может привести к меньшим по размеру и
более быстрым программам. Описание REGISTER выглядит как
 
       REGISTER INT X;
       REGISTER CHAR C;
 
и т.д.; часть INT может быть опущена. Описание REGISTER можно
использовать только     для   автоматических   переменных   и
формальных параметров   функций.   В  этом  последнем  случае
описания выглядят следующим образом:
 
       F(C,N)
       REGISTER INT C,N;
       {
          REGISTER INT I;
          ...
       }
 
 
    На практике    возникают    некоторые    ограничения   на
регистровые переменные,    отражающие  реальные   возможности
имеющихся аппаратных   средств.   В  регистры можно поместить
только несколько переменных в каждой функции,  причем  только
определенных типов.  В случае превышения возможного числа или
использования неразрешенных       типов    слово     REGISTER
игнорируется. Кроме того невозможно извлечь адрес регистровой
переменной (этот   вопрос  обсуждается  в  главе   5).    Эти
специфические ограничения   варьируются  от  машины к машине.
Так, например,  на PDP-11 эффективными являются только первые
три описания    REGISTER  в  функции,   а  в  качестве  типов
допускаются INT, CHAR или указатель.

     
     
     
     
     
     
              4.8. Блочная структура.
 
    Язык "C" не является языком с блочной структурой в смысле
PL/1 или   алгола; в нем нельзя описывать одни функции внутри
других.
    Переменные же,  с другой стороны,  могут определяться  по
методу блочного     структурирования.    Описания  переменных
(включая инициализацию)  могут следовать  за  левой  фигурной
скобкой,открывающей любой   оператор,  а не только за той,  с
которой начинается тело функции.  Переменные, описанные таким
образом, вытесняют    любые  переменные  из  внешних  блоков,
имеющие такие   же  имена,   и  остаются   определенными   до
соответствующей правой фигурной скобки. Например в
 
      IF (N > 0)  {
         INT I;  /* DECLARE A NEW I */
         FOR (I = 0; I < N; I++)
                 ...
      }
 
    Областью действия переменной I является "истинная"  ветвь
IF; это I никак не связано ни с какими другими I в программе.
    Блочная структура влияет и на  область  действия  внешних
переменных. Если даны описания
 
      INT X;
 
      F()
      {
         DOUBLE X;
         ...
      }
 
то появление  X  внутри  функции  F  относится  к  внутренней
переменной типа DOUBLE, а вне F - к внешней целой переменной.
это же справедливо в отношении имен формальных параметров:
 
      INT X;
      F(X)
      DOUBLE X;
      {
         ...
      }
 
внутри функции F имя X относится к формальному параметру,   а
не к внешней переменной.
 
     
     
     
     
     
     
     
                4.9. Инициализация.
 
    Мы до  сих пор уже много раз упоминали инициализацию,  но
всегда мимоходом ,  среди других вопросов. Теперь, после того
как мы   обсудили различные классы памяти,  мы в этом разделе
просуммируем некоторые правила,  относящиеся к инициализации.
    Если явная   инициализация  отсутствует,   то  внешним  и
статическим переменным     присваивается    значение    нуль;
автоматические и   регистровые переменные имеют в этом случае
неопределенные значения (мусор).
    Простые переменные  (не  массивы  или  структуры)   можно
инициализировать при   их описании,  добавляя вслед за именем
знак равенства и константное выражение:
 
       INT X = 1;
       CHAR SQUOTE = '\'';
       LONG DAY = 60 * 24;    /* MINUTES IN A DAY */
 
    Для внешних  и   статических   переменных   инициализация
выполняется только     один   раз,    на   этапе  компиляции.
Автоматические и   регистровые  переменные   инициализируются
каждый раз при входе в функцию или блок.
    В случае    автоматических   и   регистровых   переменных
инициализатор не обязан быть константой:  на  самом  деле  он
может быть любым значимым выражением,  которое может включать
определенные ранее величины  и  даже  обращения  к  функциям.
Например, инициализация в программе бинарного поиска из главы
3 могла бы быть записана в виде
 
 
        BINARY(X, V, N)
        INT X, V[], N;
        {
           INT LOW = 0;
           INT HIGH = N - 1;
           INT MID;
           ...
        }
 
    вместо
 
        BINARY(X, V, N)
        INT X, V[], N;
        {
           INT LOW, HIGH, MID;
 
           LOW = 0;
          HIGH = N - 1;
          ...
        }
 
    По своему   результату,    инициализации   автоматических
переменных являются      сокращенной    записью    операторов
присваивания. Какую    форму  предпочесть  -  в основном дело
вкуса. мы  обычно используем явные присваивания,  потому  что
инициализация в описаниях менее заметна.
    Автоматические массивы  не  могут  быть инициализированы.
Внешние и статические массивы можно инициализировать, помещая
вслед за   описанием  заключенный  в  фигурные  скобки список
начальных значений,  разделенных запятыми. Например программа
подсчета символов из главы 1, которая начиналась с
 
       MAIN()     /* COUNT DIGITS, WHITE SPACE, OTHERS */
        (
         INT C, I, NWHITE, NOTHER;
         INT NDIGIT[10];
   
         NWHITE = NOTHER = 0;
         FOR (I = 0; I < 10; I++)
            NDIGIT[I] = 0;
         ...
        )
 
 может быть переписана в виде
 
        INT NWHITE = 0;
        INT NOTHER = 0;
        INT NDIGIT[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
        MAIN()     /* COUNT DIGITS, WHITE SPACE, OTHERS */
         (
          INT C, I;
          ...
         )
 
    Эти инициализации  фактически  не  нужны,   так  как  все
присваиваемые значения равны нулю, но хороший стиль - сделать
их явными.  Если количество начальных значений  меньше,   чем
указанный размер  массива,  то остальные элементы заполняются
нулями. Перечисление    слишком  большого   числа   начальных
значений является   ошибкой.   К сожалению,  не предусмотрена
возможность указания,    что  некоторое  начальное   значение
повторяется, и    нельзя  инициализировать элемент в середине
массива без перечисления всех предыдущих.
    Для символьных  массивов  существует  специальный  способ
инициализации; вместо     фигурных  скобок  и  запятых  можно
использовать строку:
 
           CHAR PATTERN[] = "THE";
 
    Это сокращение более длинной, но эквивалентной записи:
 
          CHAR PATTERN[] = { 'T', 'H', 'E', '\0' };
 
    Если размер  массива  любого  типа опущен,  то компилятор
определяет его длину, подсчитывая число начальных значений. В
этом конкретном случае размер равен четырем (три символа плюс
конечное \0).

     
     
     
     
     
                4.10. Рекурсия.
 
    В языке  "C" функции могут использоваться рекурсивно; это
означает, что  функция может прямо или косвенно обращаться  к
себе самой.    Традиционным  примером является печать числа в
виде строки символов.  как  мы  уже  ранее  отмечали,   цифры
генерируются не   в  том  порядке:   цифры  младших  разрядов
появляются раньше цифр из старших разрядов, но печататься они
должны в обратном порядке.
    Эту проблему можно решить двумя способами. Первый способ,
которым мы   воспользовались  в  главе  3  в  функции   ITOA,
заключается в запоминании цифр в некотором массиве по мере их
поступления и последующем их печатании  в  обратном  порядке.
Первый вариант функции PRINTD следует этой схеме.
 
        PRINTD(N)    /* PRINT N IN DECIMAL */
        INT N;
        {
          CHAR S[10];
          INT I;
    
          IF (N < 0) {
             PUTCHAR('-');
             N = -N;
          }
          I = 0;
          DO {
             S[I++] = N % 10 + '0'; /* GET NEXT CHAR */
          } WHILE ((N /= 10) > 0); /* DISCARD IT */
          WHILE (--I >= 0)
             PUTCHAR(S[I]);
        }
 
    Альтернативой этому способу является рекурсивное решение,
когда при   каждом  вызове  функция  PRINTD   сначала   снова
обращается к   себе,   чтобы скопировать лидирующие цифры,  а
затем печатает последнюю цифру.
 
       PRINTD(N)   /* PRINT N IN DECIMAL (RECURSIVE)*/
       INT N;
       (
         INT I;
    
         IF (N < 0) {
            PUTCHAR('-');
            N = -N;
         }
         IF ((I = N/10) != 0)
            PRINTD(I);
         PUTCHAR(N % 10 + '0');
        )
 
    Когда функция   вызывает  себя  рекурсивно,   при  каждом
обращении образуется    новый   набор   всех   автоматических
переменных, совершенно    не зависящий от предыдущего набора.
Таким образом,  в PRINTD(123) первая функция PRINTD имеет N =
123. Она    передает 12 второй PRINTD,  а когда та возвращает
управление ей,  печатает  3.   Точно  так  же  вторая  PRINTD
передает 1   третьей (которая эту единицу печатает),  а затем
печатает 2.
    Рекурсия обычно   не   дает   никакой  экономиии  памяти,
поскольку приходится где-то создавать стек для обрабатываемых
значений. Не    приводит  она  и  к  созданию  более  быстрых
программ. Но  рекурсивные программы более компактны,   и  они
зачастую становятся  более легкими для понимания и написания.
Рекурсия особенно     удобна   при   работе   с    рекурсивно
определяемыми структурами   данных,   например,  с деревьями;
хороший пример будет приведен в главе 6.
    Упражнение 4-7.
    --------------
    Приспособьте идеи,    использованные   в    PRINTD    для
рекурсивного написания ITOA; т.е. Преобразуйте целое в строку
с помощью рекурсивной процедуры.
    Упражнение 4-8.
    --------------
    Напишите рекурсивный вариант функции REVERSE(S),  которая
располагает в обратном порядке строку S.
 
     
     
     
     
     
     
             4.11. Препроцессор языка "C".
 
    В языке "с" предусмотрены определенные расширения языка с
помощью простого     макропредпроцессора.    одним  из  самых
распространенных таких     расширений,    которое   мы    уже
использовали, является        конструкция   #DEFINE;   другим
расширением является возможность включать во время компиляции
содержимое других файлов.
      
     
          4.11.1. Включение файлов
 
    Для облегчения работы с наборами  конструкций  #DEFINE  и
описаний (среди   прочих  средств)  в языке "с" предусмотрена
возможность включения файлов. Любая строка вида
 
        #INCLUDE "FILENAME"
 
заменяется содержимым  файла  с  именем  FILENAME.   (Кавычки
обязательны). Часто      одна  или  две  строки  такого  вида
появляются в начале каждого исходного файла,  для того  чтобы
включить общие   конструкции  #DEFINE  и  описания EXTERN для
глобальных переменных.  Допускается  вложенность  конструкций
#INCLUDE.
    Конструкция #INCLUDE  является  предпочтительным способом
связи описаний в больших программах. Этот способ гарантирует,
что все     исходные   файлы   будут   снабжены   одинаковыми
определениями и описаниями  переменных,   и,   следовательно,
исключает особенно неприятный сорт ошибок. Естественно, когда
какой-TO включаемый файл изменяется,  все зависящие  от  него
файлы должны быть перекомпилированы.
      
     
              4.11.2. Макроподстановка
 
    Определение вида
 
        #DEFINE TES     1
 
приводит к макроподстановке самого  простого  вида  -  замене
имени на  строку символов.  Имена в #DEFINE имеют ту же самую
форму, что    и  идентификаторы  в  "с";   заменяющий   текст
совершенно произволен.  Нормально заменяющим текстом является
остальная часть строки; длинное определение можно продолжить,
поместив \   в конец продолжаемой строки.  "Область действия"
имени, определенного    в  #DEFINE,   простирается  от  точки
определения до   конца  исходного  файла.   имена  могут быть
переопределены, и определения могут использовать определения,
сделанные ранее.      Внутри   заключенных  в  кавычки  строк
подстановки не производятся,  так что если,  например,  YES -
определенное имя, то в PRINTF("YES") не будет сделано никакой
подстановки.
    Так как   реализация   #DEFINE   является  частью  работы
маKропредпроцессора, а  не собственно  компилятора,   имеется
очень мало  грамматических ограничений на то,  что может быть
определено. Так, например, любители алгола могут объявить
 
        #DEFINE THEN
        #DEFINE BEGIN {
        #DEFINE END   ;}
 
    и затем написать
 
        IF (I > 0) THEN
           BEGIN
                   A = 1;
                   B = 2
           END
 
    Имеется также   возможность   определения    макроса    с
аргументами, так  что заменяющий текст будет зависеть от вида
обращения к макросу. Определим, например, макрос с именем MAX
следующим образом:
 
       #DEFINE MAX(A, B)  ((A) > (B) ? (A) : (B))
 
    когда строка
 
       X = MAX(P+Q, R+S);
 
    будет заменена строкой
 
       X = ((P+Q) > (R+S) ? (P+Q) : (R+S));
 
    Такая возможность   обеспечивает   "функцию   максимума",
которая расширяется в последовательный код,  а не в обращение
к функции.  При  правильном  обращении  с  аргументами  такой
макрос будет   работать  с  любыми  типами  данных; здесь нет
необходимости в различных видах MAX для данных разных  типов,
как это было бы с функциями.
    Конечно, если  вы  тщательно рассмотрите приведенное выше
расширение MAX,    вы   заметите   определенные   недостатки.
Выражения вычисляются  дважды; это плохо,  если они влекут за
собой побочные эффекты,  вызванные,  например,  обращениями к
функциям или    использованием  операций  увеличения.   Нужно
позаботиться о правильном использовании круглых скобок, чтобы
гарантировать сохранение     требуемого  порядка  вычислений.
(Рассмотрите макрос
 
         #DEFINE SQUARE(X)  X * X
 
при обращении к ней,  как SQUARE(Z+1)).  Здесь возникают даже
некоторые чисто лексические проблемы:  между именем  макро  и
левой круглой скобкой,  открывающей список ее аргументов,  не
должно быть никаких пробелов.
    Тем не  менее  аппарат  макросов  является весьма ценным.
Один практический   пример  дает  описываемая   в   главе   7
стандартная библиотека   ввода-вывода,   в  которой GETCHAR и
PUTCHAR определены как макросы (очевидно PUTCHAR должна иметь
аргумент), что    позволяет  избежать  затрат  на обращение к
функции при обработке каждого символа.
  Другие возможности макропроцессора описаны в приложении А.
    Упражнение 4-9.
    ---------------
    Определите макрос   SWAP(X,    Y),    который  обменивает
значениями два своих аргумента  типа  INT.   (В  этом  случае
поможет блочная структура).
     
     
     
     
     
     
  


     
     
               5.Указатели и массивы
 
    Указатель -  это  переменная,   содержащая  адрес  другой
переменной. указатели  очень широко используются в языке "C".
Это происходит     отчасти   потому,   что  иногда  они  дают
единственную возможность выразить нужное действие,  а отчасти
потому, что они обычно ведут к более компактным и эффективным
программам, чем  те,  которые  могут  быть  получены  другими
способами.
    Указатели обычно  смешивают  в  одну  кучу  с операторами
GOTO, характеризуя их как чудесный способ написания программ,
которые невозможно понять.  Это безусловно спрAведливо,  если
указатели используются   беззаботно;  очень   просто   ввести
указатели, которые       указывают   на   что-то   совершенно
неожиданное. Однако,       при    определенной    дисциплине,
использование указателей помогает достичь ясности и простоты.
Именно этот аспект мы попытаемся здесь проиллюстрировать.









            5.1. Указатели и адреса

    Так как  указатель  содержит  адрес  объекта,   это  дает
возможность "косвенного"   доступа  к  этому  объекту   через
указатель. Предположим,   что х - переменная,  например, типа
INT, а  рх - указатель,  созданный  неким  еще  не  указанным
способом. Унарная   операция & выдает адрес объекта,  так что
оператор

                              рх = &х;

присваивает адрес   х   переменной   рх;   говорят,   что  рх
"указывает" на х.  Операция & применима только к переменным и
элементам массива,    конструкции  вида &(х-1)  и &3 являются
незаконными. Нельзя    также   получить   адрес   регистровой
переменной.
    Унарная операция  *  рассматривает свой операнд как адрес
конечной цели и обращается по этому  адресу,   чтобы  извлечь
содержимое. Следовательно, если Y тоже имеет тип INT, то

                              Y = *рх;
 
присваивает Y  содержимое  того,   на  что указывает рх.  Так
последовательность
 
                              рх = &х;
                              Y = *рх;
 
присваивает Y то же самое значение, что и оператор
 
                               Y = X;
 
    Переменные, участвующие  во всем этом необходимо описать:
 
                              INT X, Y;
                              INT *PX;
 
с описанием для X и Y мы уже  неодонократно  встречались.
    Описание указателя
 
                              INT *PX;
 
является новым  и  должно  рассматриваться как мнемоническое;
оно говорит,  что комбинация *PX имеет тип INT. Это означает,
что если  PX появляется в контексте *PX,  то это эквивалентно
переменной типа INT. Фактически синтаксис описания переменной
имитирует синтаксис выражений, в которых эта переменная может
появляться. Это  замечание полезно во всех случаях, связанных
со сложными описаниями. Например,
 
                         DOUBLE ATOF(), *DP;
 
говорит, что ATOF()  и *DP имеют в выражениях  значения  типа
    DOUBLE. Вы  должны также заметить,  что из этого описания
    следует,
что указатель может  указывать  только  на  определенный  вид
объектов.
    Указатели могут  входить в выражения.  Например,  если PX
указывает на целое  X,   то  *PX  может  появляться  в  любом
контексте, где может встретиться X. Так оператор
 
                             Y = *PX + 1
 
присваивает Y значение, на 1 большее значения X;
 
                         PRINTF("%D\N", *PX)
 
печатает текущее значение X;
 
                       D = SQRT((DOUBLE) *PX)
 
получает в  D  квадратный  корень  из  X,  причем до передачи
функции SQRT значение X преобразуется к типу DOUBLE.  (Смотри
главу 2).
    В выражениях вида
 
                             Y = *PX + 1
 
унарные операции  *  и  &  связаны  со  своим операндом более
крепко, чем  арифметические операции, так что такое выражение
берет то  значение,  на которое указывает PX,  прибавляет 1 и
присваивает результат переменной Y.   Мы  вскоре  вернемся  к
тому, что может означать выражение
 
                            Y = *(PX + 1)
 
    Ссылки на указатели могут  появляться  и  в  левой  части
присваиваний. Если PX указывает на X, то
 
                               *PX = 0
 
полагает X равным нулю, а
 
                              *PX += 1
 
увеличивает его на единицу, как и выражение
 
                               (*PX)++
 
    Круглые скобки  в  последнем  примере необходимы; если их
опустить, то  поскольку унарные операции,  подобные *  и  ++,
выполняются справа налево, это выражение увеличит PX, а не ту
переменную, на которую он указывает.
    И наконец,  так как указатели являются переменными,  то с
ними можно обращаться,  как и с остальными переменными.  Если
PY - другой указатель на переменную типа INT, то
 
                               PY = PX
 
копирует содержимое  PX в PY,  в результате чего PY указывает
на то же, что и PX.

     
     
     
     
     
     
     
          5.2. Указатели и аргументы функций
 
    Так как в "с" передача аргументов функциям осуществляется
"по значению",  вызванная процедура не имеет непосредственной
возможности изменить переменную из вызывающей программы.  Что
же делать,    если  вам действительно надо изменить аргумент?
например, программа   сортировки  захотела  бы  поменять  два
нарушающих порядок  элемента с помощью функции с именем SWAP.
Для этого недостаточно написать
 
                             SWAP(A, B);
 
определив функцию SWAP при этом следующим образом:
 
                     SWAP(X, Y)      /* WRONG */
                     INT X, Y;
                     {
                        INT TEMP;
 
                        TEMP = X;
                        X = Y;
                        Y = TEMP;
                      }
 
из-за вызова  по  значению  SWAP  не  может воздействовать на
агументы A и B в вызывающей функции.
    К счастью,   все же имеется возможность получить желаемый
эффект. Вызывающая  программа передает  указатели  подлежащих
изменению значений:
 
                            SWAP(&A, &B);
 
так как операция & выдает адрес переменной,  то  &A  является
указателем на   A.   В  самой  SWAP аргументы описываются как
указатели и доступ  к  фактическим  операндам  осуществляется
через них.
 
            SWAP(PX, PY)    /* INTERCHANGE *PX AND *PY */
            INT *PX, *PY;
            {
               INT TEMP;
 
               TEMP = *PX;
               *PX = *PY;
               *PY = TEMP;
            }
 
    Указатели в качестве  аргументов  обычно  используются  в
функциях, которые    должны возвращать более одного значения.
(Можно сказать,  что SWAP  вOзвращает  два  значения,   новые
значения ее   аргументов).   В  качестве  примера  рассмотрим
функцию GETINT,      которая   осуществляет    преобразование
поступающих в   своболном  формате  данных,   разделяя  поток
символов на   целые  значения,   по  одному  целому  за  одно
обращение. Функция    GETINT должна возвращать либо найденное
значение, либо  признак конца  файла,   если  входные  данные
полностью исчерпаны.    Эти  значения должны возвращаться как
отдельные объекты,  какое бы значение ни  использовалось  для
EOF, даже если это значение вводимого целого.
    Одно из решений,  основывающееся на описываемой в главе 7
функции ввода SCANF, состоит в том, чтобы при выходе на конец
файла GETINT возвращала  EOF  в  качестве  значения  функции;
любое другое   возвращенное  значение  говорит  о  нахождении
нормального целого.  Численное же значение найденного  целого
возвращается через  аргумент,  который должен быть указателем
целого. Эта   организация  разделяет  статус  конца  файла  и
численные значения.
    Следующий цикл   заполняет   массив   целыми   с  помощью
обращений к функции GETINT:
 
           INT N, V, ARRAY[SIZE];
 
           FOR (N = 0; N < SIZE && GETINT(&V) != EOF; N++)
              ARRAY[N] = V;
 
    В результате   каждого   обращения  V  становится  равным
следующему целому значению,  найденному  во  входных  данных.
Обратите внимание, что в качестве аргумента GETINT необходимо
указать &V а не  V.   Использование  просто  V  скорее  всего
приведет к ошибке адресации,  поскольку GETINT полагает,  что
она работает именно с указателем.
    Сама GETINT является  очевидной  модификацией  написанной
нами ранее функции ATOI:
 
        GETINT(PN)    /* GET NEXT INTEGER FROM INPUT */
        INT *PN;
        {
          INT C,SIGN;
    
          WHILE ((C = GETCH()) == ' ' \!\! C == '\N'
          \!\! C == '\T'); /* SKIP WHITE SPACE */
          SIGN = 1;
          IF (C == '+' \!\! C == '-') { /* RECORD
              SIGN */
             SIGN = (C == '+') ? 1 : -1;
             C = GETCH();
          }
          FOR (*PN = 0; C >= '0' && C <= '9'; C = GETCH())
             *PN = 10 * *PN + C - '0';
             *PN *= SIGN;
          IF (C != EOF)
             UNGETCH(C);
          RETURN(C);
        }
 
    Выражение *PN используется всюду  в  GETINT  как  обычная
переменная типа   INT.  Мы также использовали функции GETCH и
UNGETCH (описанные в главе 4)  ,  так что один лишний символ,
кототрый приходится считывать,  может быть помещен обратно во
ввод.
    Упражнение 5-1.
    ---------------
    Напишите функцию GETFLOAT,  аналог  GETINT  для  чисел  с
плавающей точкой.    Какой  тип  должна возвращать GETFLOAT в
качестве значения функции?

     
     
     
     
     
     
     
               5.3. Указатели и массивы
     
    В языке  "C"   существует   сильная   взаимосвязь   между
указателями и массивами ,  настолько сильная, что указатели и
массивы действительно   следует  рассматривать  одновременно.
Любую операцию,    которую можно выполнить с помощью индексов
массива, можно  сделать и с помощью  указателей.   вариант  с
указателями обычно оказывается более быстрым,  но и несколько
более трудным для непосредственного  понимания,   по  крайней
мере для начинающего. описание
 
                              INT A[10]
 
определяет массив   размера   10,    т.е.    Набор   из    10
последовательных объектов,  называемых A[0], A[1], ..., A[9].
Запись A[I] соответствует элементу массива через I позиций от
начала. Если PA - указатель целого, описанный как
 
                               INT *PA
 
то присваивание
 
                             PA = &A[0]
 
приводит к тому,  что PA указывает на нулевой элемент массива
A; это означает,  что PA содержит адрес элемента A[0]. Теперь
присваивание
 
                               X = *PA
 
будет копировать содержимое A[0] в X.
    Если PA   указывает  на  некоторый  определенный  элемент
массива A,  то по определению  PA+1  указывает  на  следующий
элемент, и    вообще PA-I указывает на элемент,  стоящий на I
позиций до элемента,  указываемого PA,  а  PA+I  на  элемент,
стоящий на I позиций после.  Таким образом, если PA указывает
на A[0], то
 
                               *(PA+1)
 
ссылается на содержимое A[1],  PA+I - адрес A[I], а *(PA+I) -
содержимое A[I].
    Эти замечания справедливы независимо от типа переменных в
массиве A.  Суть определения "добавления 1 к  указателю",   а
также его   распространения  на  всю  арифметику  указателей,
состоит в том, что приращение масштабируется размером памяти,
занимаемой объектом,   на который указывает указатель.  Таким
образом, I  в PA+I перед прибавлением  умножается  на  размер
объектов, на которые указывает PA.
    Очевидно существует   очень   тесное  соответствие  между
индексацией и  арифметикой  указателей.   в  действительности
компилятор преобразует ссылку на массив в указатель на начало
массива. В результате этого имя массива является указательным
выражением. Отсюда      вытекает  несколько  весьма  полезных
следствий. Так     как   имя   массива   является   синонимом
местоположения его     нулевого  элемента,   то  присваивание
PA=&A[0] можно записать как
     
                               PA = A
 
    Еще более удивительным, по крайней мере на первый взгляд,
кажется тот факт,  что ссылку на A[I] можно записать  в  виде
*(A+I). При    анализировании  выражения A[I] в языке "C" оно
немедленно преобразуется   к  виду  *(A+I);  эти  две   формы
совершенно эквивалентны.    Если применить операцию & к обеим
частям такого соотношения эквивалентности, то мы получим, что
&A[I] и   A+I  тоже  идентичны:  A+I - адрес I-го элемента от
начала A. С другой стороны, если PA является указателем, то в
выражениях его можно использовать с индексом: PA[I] идентично
*(PA+I). Короче,   любое  выражение,   включающее  массивы  и
индексы, может    быть  записано через указатели и смещения и
наоборот, причем даже в одном и том же утверждении.
    Имеется одно различие между именем массива и  указателем,
которое необходимо     иметь   в  виду.   указатель  является
переменной, так  что операции PA=A и PA++ имеют смысл. Но имя
массива является   константой,  а не переменной:  конструкции
типа A=PA или A++,или P=&A будут незаконными.
    Когда имя массива передается функции, то на самом деле ей
передается местоположение    начала  этого  массива.   Внутри
вызванной функции такой  аргумент  является  точно  такой  же
переменной, как    и  любая  другая,   так  что имя массива в
качестве аргумента действительно является  указателем,   т.е.
Переменной, содержащей    адрес.   мы  можем использовать это
обстоятельство для написания нового варианта функции  STRLEN,
вычисляющей длину строки.
 
           STRLEN(S)       /* RETURN LENGTH OF STRING S */
           CHAR *S;
           {
              INT N;
 
              FOR (N = 0; *S != '\0'; S++)
                      N++;
              RETURN(N);
           }
 
    Операция увеличения S совершенно законна,  поскольку  эта
переменная является   указателем;  S++  никак  не  влияет  на
символьную строку в обратившейся к STRLEN функции,  а  только
увеличивает локальную    для  функции  STRLEN  копию  адреса.
Описания формальных параметров в определении функции в виде
 
                              CHAR S[];
                              CHAR *S;
 
совершенно эквивалентны;    какой    вид   описания   следует
предпочесть, определяется  в значительной степени тем,  какие
выражения будут   использованы  при  написании функции.  Если
функции передается имя массива, то в зависимости от того, что
удобнее, можно    полагать,   что  функция  оперирует  либо с
массивом, либо     с   указателем,    и   действовать   далее
соответвующим образом.    Можно  даже  использовать  оба вида
операций, если это кажется уместным и ясным.
    Можно передать функции  часть  массива,   если  задать  в
качестве аргумента   указатель  начала подмассива.  Например,
если A - массив, то как
 
                              F(&A[2])
 
как и
      
                               F(A+2)
 
передают функции F адрес элемента A[2], потому что и &A[2], и
A+2 являются   указательными  выражениями,   ссылающимися  на
третий элемент A.  внутри функции F описания аргументов могут
присутствовать в виде:
 
                             F(ARR)
                             INT ARR[];
                             {
                                ...
                             }
 
или
 
                              F(ARR)
                              INT *ARR;
                              {
                                 ...
                              }
 
    Что касается  функции F,  то тот факт,  что ее аргумент в
действительности ссылается к части большего массива,не  имеет
для нее никаких последствий.

     
     
      
     
     
              5.4. Адресная арифметика
 
    Если P  является  указателем,   то  каков  бы ни был сорт
объекта, на  который он указывает, операция P++ увеличивает P
так, что    он  указывает  на  следующий  элемент набора этих
объектов, а  операция P +=I  увеличивает  P  так,   чтобы  он
указывал на   элемент,   отстоящий на I элементов от текущего
элемента.эти и  аналогичные  конструкции  представляют  собой
самые простые   и  самые  распространенные  формы  арифметики
указателей или адресной арифметики.
    Язык "C" последователен и постоянен  в  своем  подходе  к
адресной арифметике;   объединение  в  одно целое указателей,
массивов и адресной арифметики  является  одной  из  наиболее
сильных сторон   языка.  Давайте проиллюстрируем некоторые из
соответствующих возможностей языка  на  примере  элементарной
(но полезной,      несмотря   на  свою  простоту)   программы
распределения памяти.  Имеются две функции:  функция ALLOC(N)
возвращает в   качестве своего значения указатель P,  который
указывает на первую из N последовательных символьных позиций,
которые могут   быть  использованы  вызывающей  функцию ALLOC
программой для хранения символов; функция FREE(P) освобождает
приобретенную таким  образом память,  так что ее в дальнейшем
можно снова использовать.  программа является "элементарной",
потому что   обращения к FREE должны производиться в порядке,
обратном тому,  в котором производились  обращения  к  ALLOC.
Таким образом,    управляемая  функциями  ALLOC и FREE память
является стеком или списком,  в  котором  последний  вводимый
элемент извлекается первым.  Стандартная библиотека языка "C"
содержит аналогичные функции,  не имеющие таких  ограничений,
и, кроме    того,  в главе 8 мы приведем улучшенные варианты.
Между тем,   однако,   для  многих  приложений  нужна  только
тривиальная функция     ALLOC   для  распределения  небольших
участков памяти       неизвестных    заранее    размеров    в
непредсказуемые моменты времени.
    Простейшая реализация  состоит  в  том,   чтобы   функция
раздавала отрезки  большого символьного массива,  которому мы
присвоили имя ALLOCBUF.  Этот массив является  собственностью
функций ALLOC и FREE.  Так как они работают с указателями,  а
не с индексами массива, никакой другой функции не нужно знать
имя этого    массива.   Он  может  быть  описан  как  внешний
статический, т.е. Он будет локальным по отношению к исходному
файлу, содержащему    ALLOC  и  FREE,   и  невидимым  за  его
пределами. При практической реализации этот массив может даже
не иметь   имени;  вместо  этого  он  может  быть  получен  в
результате запроса   к  операционной  системе  на   указатель
некоторого неименованного блока памяти.
    Другой необходимой информацией является то,  какая  часть
массива ALLOCBUF  уже использована.  Мы пользуемся указателем
первого свободного  элемента,   названным  ALLOCP.   Когда  к
функции ALLOC   обращаются  за выделением N символов,  то она
проверяет, достаточно ли осталось для этого места в ALLOCBUF.
Если достаточно,  то ALLOC возвращает текущее значение ALLOCP
(т.е. Начало свободного блока), затем увеличивает его на N, с
тем чтобы он указывал на следующую свободную область. Функция
FREE(P) просто  полагает ALLOCP равным P при условии,  что  P
указывает на позицию внутри ALLOCBUF.
 
       DEFINE NULL 0  /* POINTER VALUE FOR ERROR REPORT */
       DEFINE ALLOCSIZE 1000  /* SIZE OF AVAILABLE SPACE */
 
      TATIC CHAR ALLOCBUF[ALLOCSIZE];/* STORAGE FOR ALLOC */
     TATIC CHAR *ALLOCP = ALLOCBUF; /* NEXT FREE POSITION */
 
       HAR *ALLOC(N)  /* RETURN POINTER TO N CHARACTERS */
       INT N;
       (
        IF (ALLOCP + N <= ALLOCBUF + ALLOCSIZE) {
          ALLOCP += N;
          RETURN(ALLOCP - N); /* OLD P */
       } ELSE         /* NOT ENOUGH ROOM */
          RETURN(NULL);
       )
 
       REE(P)    /* FREE STORAGE POINTED BY P */
       HAR *P;
       (
        IF (P >= ALLOCBUF && P < ALLOCBUF + ALLOCSIZE)
          ALLOCP = P;
       )
  
    Дадим некоторые пояснения. Вообще говоря, указатель может
быть инициализирован  точно  так  же,   как  и  любая  другая
переменная, хотя обычно единственными осмысленными значениями
являются NULL   (это  обсуждается   ниже)    или   выражение,
включающее адреса  ранее определенных данных соответствующего
типа. Описание
 
                   STATIC CHAR *ALLOCP = ALLOCBUF;
 
определяет ALLOCP  как  указатель на символы и инициализирует
его так,  чтобы он указывал на  ALLOCBUF,   т.е.   На  первую
свободную позицию   при начале работы программы.  Так как имя
массива является адресом его нулевого элемента,  то это можно
было бы записать в виде
 
                 STATIC CHAR *ALLOCP = &ALLOCBUF[0];
 
используйте ту   запись,    которая   вам    кажется    более
естественной. С помощью проверки
 
               IF (ALLOCP + N <= ALLOCBUF + ALLOCSIZE)
 
выясняется, осталось ли достаточно места, чтобы удовлетворить
запрос на N символов.  Если достаточно,   то  новое  значение
ALLOCP не   будет указывать дальше,  чем на последнюю позицию
ALLOCBUF. Если  запрос может  быть  удовлетворен,   то  ALLOC
возвращает обычный   указатель (обратите внимание на описание
самой функции).   Если  же  нет,   то  ALLOC  должна  вернуть
некоторый признак,    говорящий  о  том,  что больше места не
осталось. В  языке "C" гарантируется,  что ни один правильный
указатель данных   не  может  иметь  значение  нуль,  так что
возвращение нуля   может  служить  в   качестве   сигнала   о
ненормальном событии,    в данном случае об отсутствии места.
Мы, однако,   вместо нуля пишем NULL,  с тем чтобы более ясно
показать, что    это  специальное значение указателя.  Вообще
говоря, целые не могут осмысленно присваиваться указателям, а
нуль - это особый случай.
    Проверки вида
 
               IF (ALLOCP + N <= ALLOCBUF + ALOOCSIZE)
    
и
    
           IF (P >= ALLOCBUF && P < ALLOCBUF + ALLOCSIZE)
 
демонстрируют несколько    важных     аспектов     арифметики
указателей. Во-первых  ,  при определенных условиях указатели
можно сравнивать.  Если P и Q указывают на элементы одного  и
того же   массива,   то  такие отношения,  как <,  >= и т.д.,
работают надлежащим образом. Например,
 
                                P < Q
 
истинно, если  P  указывает  на более ранний элемент массива,
чем Q. Отношения == и != тоже работают. Любой указатель можно
осмысленным образом   сравнить на равенство или неравенство с
NULL. Но  ни за что нельзя  ручаться,   если  вы  используете
сравнения при   работе с указателями,  указывающими на разные
массивы. Если  вам повезет,  то на всех машинах  вы  получите
очевидную бессмыслицу.  Если же нет,  то ваша программа будет
правильно работать на  одной  машине  и  давать  непостижимые
результаты на другой.
    Во-вторых, как  мы  уже  видели,  указатель и целое можно
складывать и вычитать. Конструкция
 
                                P + N
 
подразумевает N-ый объект за тем,  на который P  указывает  в
настоящий момент.    Это  справедливо независимо от того,  на
какой вид   объектов  P  должен  указывать;  компилятор   сам
масштабирует N   в  соответствии с определяемым из описания P
размером объектов, указываемых с помощью P. например, на PDP-
11 масштабирующий   множитель  равен 1 для CHAR,  2 для INT и
SHORT, 4 для LONG и FLOAT и 8 для DOUBLE.
    Вычитание указателей тоже возможно:  если P и Q указывают
на элементы   одного  и того же массива,  то P-Q - количество
элементов между P и Q.   Этот  факт  можно  использовать  для
написания еще одного варианта функции
 
          STRLEN:
           STRLEN(S)       /* RETURN LENGTH OF STRING S */
           CHAR *S;
           {
               CHAR *P = S;
   
               WHILE (*P != '\0')
                       P++;
               RETURN(P-S);
            }
    При описании  указатель  P в этой функции инициализирован
посредством строки S,  в  результате  чего  он  указывает  на
первый символ   строки.  В цикле WHILE по очереди проверяется
каждый символ до тех пор,   пока  не  появится  символ  конца
строки \0.    Так как значение \0 равно нулю,  а WHILE только
выясняет, имеет  ли выражение в нем значение 0,  то в  данном
случае явную   проверку  можно  опустить.   Такие циклы часто
записывают в виде
 
                             WHILE (*P)
                                P++;
 
    Так как  P  указывает  на  символы,   то   оператор   P++
передвигает P каждый раз так,  чтобы он указывал на следующий
символ. В  результате P-S дает число просмотренных  символов,
т.е. Длину    строки.  Арифметика указателей последовательна:
если бы мы имели дело  с  переменными  типа  FLOAT,   которые
занимают больше памяти, чем переменные типа CHAR, и если бы P
был указателем на FLOAT,  то оператор P++ передвинул бы P  на
следующее FLOAT.  таким образом,  мы могли бы написать другой
вариант функции  ALLOC,   распределяющей  память  для  FLOAT,
вместо CHAR,    просто заменив всюду в ALLOC и FREE описатель
CHAR на FLOAT.   Все  действия  с  указателями  автоматически
учитывают размер объектов,  на которые они указывают, так что
больше ничего менять не надо.
    За исключением   упомянутых  выше  операций  (сложение  и
вычитание указателя и целого,   вычитание  и  сравнение  двух
указателей), вся    остальная  арифметика указателей является
незаконной. Запрещено  складывать два  указателя,   умножать,
делить, сдвигать или маскировать их, а также прибавлять к ним
переменные типа FLOAT или DOUBLE.

     
     
     
     
       
     
           5.5. Указатели символов и функции
 
    Строчная константа, как, например,
 
                           "I AM A STRING"
 
является массивом  символов.  Компилятор завершает внутреннее
представление такого массива символом \0,  так что  программы
могут находить   его  конец.  Таким образом,  длина массива в
памяти оказывается на единицу  больше  числа  символов  между
двойными кавычками.
    По-видимому чаще  всего  строчные  константы появляются в
качестве аргументов функций, как, например, в
 
                     PRINTF ("HELLO, WORLD\N");
 
когда символьная  строка,   подобная  этой,    появляется   в
программе, то доступ к ней осуществляется с помощью указателя
символов; функция   PRINTF  фактически   получает   указатель
символьного массива.
    Конечно, символьные   массивы   не  обязаны  быть  только
аргументами функций. Если описать MESSAGE как
 
                           CHAR *MESSAGE;
 
то в результате оператора
 
                    MESSAGE = "NOW IS THE TIME";
 
переменная MESSAGE станет указателем  на  фактический  массив
символов. Это   не копирование строки; здесь участвуют только
указатели. в  языке "C" не предусмотрены какие-либо  операции
для обработки всей строки символов как целого.
    Мы проиллюстрируем другие аспекты указателей и  массивов,
разбирая две полезные функции из стандартной библиотеки ввода
-вывода, которая будет рассмотрена в главе 7.
    Первая функция - это STRCPY(S,T), которая копирует строку
т в строку S.  Аргументы написаны именно в  этом  порядке  по
аналогии с   операцией  присваивания,  когда для того,  чтобы
присвоить T к S обычно пишут
 
                                S = T
 
сначала приведем версию с массивами:
 
                  STRCPY(S, T)    /* COPY T TO S */
                  CHAR S[], T[];
                  {
                     INT I;
                     I = 0;
                     WHILE ((S[I] = T[I]) != '\0')
                     I++;
                  }
   
    Для сопоставления    ниже   дается   вариант   STRCPY   с
 указателями.
 
         STRCPY(S, T)  /* COPY T TO S; POINTER VERSION 1 */
         CHAR *S, *T;
         {
            WHILE ((*S = *T) != '\0') {
                    S++;
                    T++;
            }
         }
 
    Так как аргументы передаются по значению,  функция STRCPY
может использовать S и T так,  как она пожелает.  Здесь они с
удобством полагаются указателями, которые передвигаются вдоль
массивов, по  одному символу за шаг, пока не будет скопирован
в S завершающий в T символ \0.
    На практике функция STRCPY была бы записана не так,   как
мы показали выше. Вот вторая возможность:
 
         STRCPY(S, T)  /* COPY T TO S; POINTER VERSION 2 */
         CHAR *S, *T;
         {
            WHILE ((*S++ = *T++) != '\0')
                    ;
         }
 
    Здесь увеличение S  и  T  внесено  в  проверочную  часть.
Значением *T++   является  символ,   на который указывал T до
увеличения; постфиксная операция ++ не изменяет T,  пока этот
символ не будет извлечен. Точно так же этот символ помещается
в старую позицию S,  до того как S будет увеличено.  Конечный
результат заключается   в  том,   что  все  символы,  включая
завершающий \0, копируются из T в S.
    И как  последнее  сокращение  мы  опять   отметим,    что
сравнение с   \0  является  излишним,   так что функцию можно
записать в виде
 
         STRCPY(S, T)  /* COPY T TO S; POINTER VERSION 3 */
         CHAR *S, *T;
         {
            WHILE (*S++ = *T++)
                    ;
         }
 
хотя с  первого   взгляда   эта   запись   может   показаться
загадочной, она    дает  значительное удобство.  Этой идиомой
следует овладеть уже хотя бы потому,  что  вы  с  ней  будете
часто встречаться в "C"-программах.
    Вторая функция   -  STRCMP(S,   T),   которая  сравнивает
символьные строки S и т, возвращая отрицательное, нулевое или
положительное значение  в соответствии с тем,  меньше,  равно
или больше лексикографически S,  чем T. Возвращаемое значение
получается в результате вычитания символов из первой позиции,
в которой S и T не совпадают.
 
    STRCMP(S, T) /* RETURN <0 IF S<T, 0 IF S==T, >0 IF S>T */
      CHAR S[], T[];
      {
       INT I;
 
       I = 0;
       WHILE (S[I] == T[I])
          IF (S[I++] == '\0')
                  RETURN(0);
       RETURN(S[I]-T[I]);
      }
 
    Вот версия STRCMP с указателями:
 
    STRCMP(S, T) /* RETURN <0 IF S<T, 0 IF S==T, >0 IF S>T */
      CHAR *S, *T;
      {
       FOR ( ; *S == *T; S++, T++)
          IF (*S == '\0')
                  RETURN(0);
       RETURN(*S-*T);
      }
так как   ++  и  --  могут  быть  как  постфиксными,   так  и
префиксными операциями,  встречаются другие комбинации * и ++
и --, хотя и менее часто.
    Например
    *++P
увеличивает P до извлечения символа,  на который указывает P,
 а  *--P
 сначала уменьшает P.
    Упражнение 5-2.
    ---------------
    Напишите вариант с указателями функции STRCAT из главы 2:
STRCAT(S, T) копирует строку T в конец S.
    Упражнение 5-3.
    ---------------
    Напишите макрос для STRCPY.
    Упражнение 5-4.
    --------------
    Перепишите подходящие  программы  из  предыдущих  глав  и
упражнений, используя  указатели вместо индексации  массивов.
Хорошие возможности для этого предоставляют функции GETLINE /
главы 1 и 4/,  ATOI,  ITOA и их варианты /главы 2,  3  и  4/,
REVERSE /глава 3/, INDEX и GETOP /глава 4/.
  
     
     
     
     
     
     
               5.6. Указатели - не целые.
 
    Вы, возможно,     обратили    внимание    в    предыдущих
"с"-программах на     довольно   непринужденное  отношение  к
копированию указателей. В общем это верно, что на большинстве
машин указатель    можно  присвоить  целому  и  передать  его
обратно, не  изменив его; при  этом  не  происходит  никакого
масштабирования или преобразования и ни один бит не теряется.
к сожалению,  это ведет к  вольному  обращению  с  функциями,
возвращающими указатели,    которые  затем  просто передаются
другим функциям,  -  необходимые  описания  указателей  часто
опускаются. Рассмотрим, например, функцию STRSAVE(S), которая
копирует строку S в некоторое место для хранения,  выделяемое
посредством обращения к функции ALLOC, и возвращает указатель
на это место. Правильно она должна быть записана так:
 
           CHAR *STRSAVE(S) /* SAVE STRING S SOMEWHERE */
           CHAR *S;
           {
          CHAR *P, *ALLOC();
 
          IF ((P = ALLOC(STRLEN(S)+1)) != NULL)
                  STRCPY(P, S);
          RETURN(P);
           }
 
на практике существует сильное стремление опускать описания:
 
              *STRSAVE(S) /* SAVE STRING S SOMEWHERE */
              {
             CHAR *P;
 
             IF ((P = ALLOC(STRLEN(S)+1)) != NULL)
                     STRCPY(P, S);
             RETURN(P);
              }
 
    Эта программа будет правильно работать на многих машинах,
потому что по умолчанию функции и аргументы имеют тип INT,  а
указатель и   целое  обычно можно безопасно пересылать туда и
обратно. Однако такой стиль программирования в своем существе
является рискованным, поскольку зависит от деталей реализации
и архитектуры   машины  и  может  привести   к   неправильным
результатам на   конкретном  используемом  вами  компиляторе.
Разумнее всюду  использовать  полные  описания.   (Отладочная
программа LINT предупредит о таких конструкциях,  если они по
неосторожности все же появятся).

     
     
     
     
               5.7. Многомерные массивы.
 
    В языке   "C"   предусмотрены  прямоугольные  многомерные
массивы, хотя    на  практике  существует  тенденция   к   их
значительно более    редкому  использованию  по  сравнению  с
массивами указателей.  В этом разделе мы рассмотрим некоторые
их свойства.
    Рассмотрим задачу преобразования дня месяца в день года и
наоборот. Например,     1-ое   марта   является   60-м   днем
невисокосного года   и  61-м  днем високосного года.  Давайте
введем две функции для выполнения этих преобразований: DAY_OF
_YEAR преобразует   месяц  и  день  в день года,  а MONTH_DAY
преобразует день года в месяц и день.  Так как эта  последняя
функция возвращает   два значения,  то аргументы месяца и дня
должны быть указателями:
 
                     MONTH_DAY(1977, 60, &M, &D)
 
полагает M равным 3 и D равным 1 (1-ое марта).
    Обе эти функции нуждаются в одной и той же информационной
таблице, указывающей    число  дней в каждом месяце.  Так как
число дней в  месяце  в  високосном  и  в  невисокосном  году
отличается, то    проще  представить  их  в  виде  двух строк
двумерного массива,    чем  пытаться  прослеживать  во  время
вычислений, что  именно происходит в феврале. Вот этот массив
и выполняющие эти преобразования функции:
 
       STATIC INT DAY_TAB[2][13] = {
         (0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
         (0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
       };
 
     DAY_OF_YEAR(YEAR, MONTH, DAY)      /* SET DAY OF YEAR */
       INT YEAR, MONTH, DAY;        /* FROM MONTH & DAY */
       {
           INT I, LEAP;
      LEAP = YEAR%4 == 0 && YEAR%100 != 0 \!\! YEAR%400 == 0;
           FOR (I = 1; I < MONTH; I++)
        DAY += DAY_TAB[LEAP][I];
           RETURN(DAY);
      {
 
    MONTH_DAY(YEAR, YEARDAY, PMONTH, PDAY) /*SET MONTH,DAY */
    INT YEAR, YEARDAY, *PMONTH, *PDAY; /* FROM DAY OF YEAR */
      {
      LEAP = YEAR%4 == 0 && YEAR%100 != 0 \!\! YEAR%400 == 0;
          FOR (I = 1; YEARDAY > DAY_TAB[LEAP][I]; I++)
       YEARDAY -= DAY_TAB[LEAP][I];
          *PMONTH = I;
          *PDAY = YEARDAY;
      }
      
    Массив DAY_TAB должен быть внешним как  для  DAY_OF_YEAR,
так и  для MONTH_DAY,  поскольку он используется обеими этими
функциями.
    Массив DAY_TAB является  первым  двумерным  массивом,   с
которым мы имеем дело.  По определению в "C" двумерный массив
по существу является  одномерным  массивом,   каждый  элемент
которого является массивом.  Поэтому индексы записываются как
 
                            DAY_TAB[I][J]
    
а не
    
                           DAY_TAB [I, J]
 
как в большинстве языков.  В остальном с двумерными массивами
можно в основном обращаться таким же образом,  как  в  других
языках. Элементы  хранятся по строкам,  т.е.  При обращении к
элементам в порядке их  размещения  в  памяти  быстрее  всего
изменяется самый правый индекс.
    Массив инициализируется   с   помощью   списка  начальных
значений, заключенных    в  фигурные  скобки;  каждая  строка
двумерного массива        инициализируется    соответствующим
подсписком. Мы  поместили в начало массива DAY_TAB столбец из
нулей для того,  чтобы номера месяцев изменялись естественным
образом от 1 до 12,  а не от 0 до 11.  Так  как  за  экономию
памяти у   нас  пока не награждают,  такой способ проще,  чем
подгонка индексов.
    Если двумерный массив передается  функции,   то  описание
соответствующего аргумента       функции   должно   содержать
количество столбцов;     количество   строк    несущественно,
поскольку, как  и прежде,  фактически передается указатель. В
нашем конкретном случае это указатель  объектов,   являющихся
массивами из   13  чисел  типа  INT.  Таким образом,  если бы
требовалось передать массив DAY_TAB функции F,  то описание в
F имело бы вид:
 
                         F(DAY_TAB)
                         INT DAY_TAB[2][13];
                         {
                                 ...
                         }
 
    Так как  количество  строк  является  несущественным,  то
описание аргумента в F могло бы быть таким:
 
                         INT DAY_TAB[][13];
 
или таким
 
                         INT (*DAY_TAB)[13];
 
в котором говорится, что аргумент является указателем массива
из 13   целых.   Круглые скобки здесь необходимы,  потому что
квадратные скобки [] имеют более высокий уровень старшинства,
чем *; как мы увидим в следующем разделе,  без круглых скобок
      
                          INT *DAY_TAB[13];
 
является описанием массива из 13 указателей на целые.

     
     
     
 
     
     
         5.8. Массивы указателей; указатели указателей
    
    Так как указатели сами являются переменными, то вы вполне
могли бы   ожидать  использования  массива  указателей.   Это
действительно так.      Мы   проиллюстрируем  это  написанием
программы сортировки в алфавитном  порядке  набора  текстовых
строк, предельно      упрощенного   варианта   утилиты   SORT
операционной систем UNIX.
    В главе 3 мы привели функцию сортировки по Шеллу, которая
упорядочивала массив целых. Этот же алгоритм будет работать и
здесь, хотя  теперь мы будем иметь дело со  строчками  текста
различной длины,    которые,   в  отличие  от  целых,  нельзя
сравнивать или  перемещать  с  помощью  одной  операции.   Мы
нуждаемся в таком представлении данных,  которое бы позволяло
удобно и эффективно  обрабатывать  строки  текста  переменной
длины.
    Здесь и возникают массивы  указателей.   Если  подлежащие
сортировке сроки хранятся одна за другой в длинном символьном
массиве (управляемом,  например, функцией ALLOC), то к каждой
строке можно   обратиться  с  помощью  указателя на ее первый
символ. Сами  указатели можно хранить в массиве.  две  строки
можно сравнить, передав их указатели функции STRCMP. Если две
расположенные в   неправильном  порядке  строки  должны  быть
переставлены, то     фактически  переставляются  указатели  в
массиве указателей,  а не сами тексты строк. Этим исключаются
сразу две  связанные проблемы:  сложного управления памятью и
больших дополнительных  затрат  на  фактическую  перестановку
строк.
    Процесс сортировки включает три шага:
 
      чтение всех строк ввода
      их сортировка
      вывод их в правильном порядке
 
    Как обычно,   лучше  разделить  программу  на   несколько
функций в   соответствии  с  естественным  делением  задачи и
выделить ведущую функцию, управляющую работой всей программы.
    Давайте отложим  на  некоторое  время  рассмотрение  шага
сортировки и     сосредоточимся   на   структуре   данных   и
вводе-выводе. Функция,   осуществляющая ввод,  должна извлечь
символы каждой  строки,   запомнить  их  и  построить  массив
указателей строк.  Она должна также подсчитать число строк во
вводе, так  как эта информация необходима  при  сортировке  и
выводе. так как функция ввода в состоянии справиться только с
конечным числом вводимых строк,  в случае слишком большого их
числа она   может  возвращать  некоторое  число,  отличное от
возможного числа строк,  например -1.  Функция осуществляющая
вывод, должна    печатать  строки в том порядке,  в каком они
появляются в массиве указателей.
 
         #DEFINE NULL 0
         #DEFINE LINES 100 /* MAX LINES TO BE SORTED */
   
         MAIN()    /* SORT INPUT LINES */
         \(
          CHAR *LINEPTR[LINES]; /*POINTERS TO TEXT LINES */
          INT NLINES;     /* NUMBER OF INPUT LINES READ */
   
          IF ((NLINES = READLINES(LINEPTR, LINES)) >= 0) \(
             SORT(LINEPTR, NLINES);
             WRITELINES(LINEPTR, NLINES);
          \)
          ELSE
             PRINTF("INPUT TOO BIG TO SORT\N");
         \)
   
         #DEFINE MAXLEN 1000
   
         READLINES(LINEPTR, MAXLINES) /* READ INPUT LINES */
         CHAR *LINEPTR[];       /* FOR SORTING */
         INT MAXLINES;
         \(
          INT LEN, NLINES;
          CHAR *P, *ALLOC(), LINE[MAXLEN];
   
          NLINES = 0;
          WHILE ((LEN = GETLINE(LINE, MAXLEN)) > 0)
             IF (NLINES >= MAXLINES)
                     RETURN(-1);
             ELSE IF ((P = ALLOC(LEN)) == NULL)
                     RETURN (-1);
             ELSE \(
                  LINE[LEN-1] = '\0'; /* ZAP NEWLINE */
                  STRCPY(P,LINE);
                  LINEPTR[NLINES++] = P;
                  \)
           RETURN(NLINES);
          \)
 
    Символ новой строки в конце каждой строки удаляется,  так
что он   никак  не  будет  влиять  на  порядок,   в   котором
сортируются строки.
 
        WRITELINES(LINEPTR, NLINES) /* WRITE OUTPUT LINES */
        CHAR *LINEPTR[];
        INT NLINES;
        \(
         INT I;
 
         FOR (I = 0; I < NLINES; I++)
            PRINTF("%S\N", LINEPTR[I]);
        \)
 
    Существенно новым в этой программе является описание
 
                        CHAR *LINEPTR[LINES];
 
которое сообщает,  что LINEPTR  является  массивом  из  LINES
элементов, каждый   из которых - указатель на переменные типа
CHAR. Это  означает, что LINEPTR[I] - указатель на символы, а
*LINEPTR[I] извлекает символ.
    Так как сам LINEPTR является массивом, который передается
функции WRITELINES,  с ним можно обращаться как с  указателем
точно таким   же образом,  как в наших более ранних примерах.
Тогда последнюю функцию можно переписать в виде:
 
        WRITELINES(LINEPTR, NLINES) /* WRITE OUTPUT LINES */
        CHAR *LINEPTR[];
        INT NLINES;
        \(
         INT I;
 
         WHILE (--NLINES >= 0)
              PRINTF("%S\N", *LINEPTR++);
        \)
 
 
здесь *LINEPTR  сначала  указывает  на  первую строку; каждое
увеличение передвигает указатель на следующую строку,   в  то
время как NLINES убывает до нуля.
    Справившись с вводом  и  выводом,   мы  можем  перейти  к
сортировке. программа  сортировки по шеллу из главы 3 требует
очень небольших   изменений:   должны   быть   модифицированы
описания, а  операция сравнения выделена в отдельную функцию.
Основной алгоритм остается тем же  самым,   и  это  дает  нам
определенную уверенность,  что он по-прежнему будет работать.
 
           SORT(V, N)   /* SORT STRINGS V[0] ... V[N-1] */
           CHAR *V[];   /* INTO INCREASING ORDER */
           INT N;
           \(
            INT GAP, I, J;
            CHAR *TEMP;
   
            FOR (GAP = N/2; GAP > 0; GAP /= 2)
                FOR (I = GAP; I < N; I++)
               FOR (J = I - GAP; J >= 0; J -= GAP) \(
                   IF (STRCMP(V[J], V[J+GAP]) <= 0)
                      BREAK;
                  TEMP = V[J];
                  V[J] = V[J+GAP];
                  V[J+GAP] = TEMP;
                  \)
           \)
           
    Так как   каждый   отдельный   элемент   массива  V  (имя
формального параметра,  соответствующего  LINEPTR)   является
указателем на   символы,  то и TEMP должен быть указателем на
символы, чтобы их было можно копировать друг в друга.
    Мы написали  эту  программу по возможности более просто с
тем, чтобы побыстрее получить работающую программу. Она могла
бы работать    быстрее,   если,   например,   вводить  строки
непосредственно в массив,  управляемый функцией READLINES,  а
не копировать   их в LINE,  а затем в скрытое место с помощью
функции ALLOC.    но  мы   считаем,    что   будет   разумнее
первоначальный вариант сделать более простым для понимания, а
об "эффективности" позаботиться позднее. Все же, по-видимому,
способ, позволяющий    добиться  заметного  ускорения  работы
программы состоит   не  в  исключении   лишнего   копирования
вводимых строк.    Более  вероятно,  что существенной разницы
можно достичь за счет замены сортировки  по  шеллу  на  нечто
лучшее, например, на метод быстрой сортировки.
    В главе 1 мы отмечали, что поскольку в циклах WHILE и FOR
проверка осуществляется   до того,  как тело цикла выполнится
хотя бы   один  раз,   эти  циклы  оказываются  удобными  для
обеспечения правильной     работы   программы  при  граничных
значениях, в частности, когда ввода вообще нет. Очень полезно
просмотреть все функции программы сортировки, разбираясь, что
происходит, если вводимый текст отсутствует.
    Упражнение 5-5.
    --------------
    Перепишите функцию READLINES таким  образом,   чтобы  она
помещала строки в массив, предоставляемый функцией MAIN, а не
в память,  управляемую обращениями к функции ALLOC. Насколько
быстрее стала программа?

     
     
     
       
     
              5.9. Инициализация массивов указателей.
    
    Рассмотрим задачу    написания   функции   MONTH_NAME(N),
которая возвращает указатель на символьную строку, содержащую
имя N-го    месяца.   Это  идеальная  задача  для  применения
внутреннего статического массива. Функция MONTH_NAME содержит
локальный массив   символьных  строк  и  при  обращении к ней
возвращает указатель нужной строки. Тема настоящего раздела -
как инициализировать этот массив имен.
 
         CHAR *MONTH_NAME(N) /* RETURN NAME OF N-TH MONTH */
         INT N;
         \(
          STATIC CHAR *NAME[] = \(
             "ILLEGAL MONTH",
             "JANUARY",
             "FEBRUARY",
             "MARCH",
             "APRIL",
             "MAY",
             "JUN",
             "JULY",
             "AUGUST",
             "SEPTEMBER",
             "OCTOBER",
             "NOVEMBER",
             "DECEMBER"
           \);
            RETURN ((N < 1 \!\! N > 12) ? NAME[0] : NAME[N];
           \)
   Описание массива указателей на символы  NAME  точно  такое
же, как      и  аналогичное  описание  LINEPTR  в  примере  с
сортировкой. Инициализатором      является   просто    список
символьных строк; каждая строка присваивается соответствующей
позиции в   массиве.   Более  точно,   символы  I-той  строки
помещаются в  какое-то иное место,  а ее указатель хранится в
NAME[I]. Поскольку  размер массива NAME не указан, компилятор
сам подсчитывает  количество инициализаторов и соответственно
устанавливает правильное число.
     
      

     
 
      



           5.10 Указатели и многомерные массивы
     
     Начинающие изучать  язык  "c"  иногда становятся в тупик
перед вопросом о различии между двумерным массивом и массивом
указателей, таким  как NAME в приведенном выше примере.  Если
имеются описания
 
                           INT A[10][10];
                           INT *B[10];
 
то A и B можно использовать сходным образом в том смысле, что
как A[5][5],  так и B[5][5] являются  законными  ссылками  на
отдельное число типа INT.  Но A - настоящий массив:  под него
отводится 100 ячеек памяти и для нахождения любого указанного
элемента проводятся    обычные  вычисления  с  прямоугольными
индексами. Для  B,   однако,   описание  выделяет  только  10
указателей; каждый   указатель  должен  быть  установлен так,
чтобы он указывал на массив целых.  если  предположить,   что
каждый из  них указывает на массив из 10 элементов,  то тогда
где-то будет отведено 100 ячеек памяти плюс еще десять  ячеек
для указателей.  Таким образом,  массив указателей использует
несколько больший объем  памяти  и  может  требовать  наличие
явного шага    инициализации.   Но  при  этом  возникают  два
преимущества: доступ к элементу осуществляется косвенно через
указатель, а   не посредством умножения и сложения,  и строки
массива могут иметь различные длины. Это означает, что каждый
элемент B   не  должен  обязательно указывать на вектор из 10
элементов; некоторые   могут  указывать  на  вектор  из  двух
элементов, другие  - из двадцати, а третьи могут вообще ни на
что не указывать.
    Хотя мы вели это обсуждение в терминах целых, несомненно,
чаще всего   массивы  указателей  используются  так,   как мы
продемонстрировали на функции  MONTH_NAME,   -  для  хранения
символьных строк различной длины.
    Упражнение 5-6.
    --------------
    Перепишите функции DAY_OF_YEAR  и  MONTH_DAY,   используя
вместо индексации указатели.

     
     
     
     
     

     
     
     
           5.11. Командная строка аргументов
 
    Системные средства, на которые опирается реализация языка
"с", позволяют  передавать командную  строку  аргументов  или
параметров начинающей   выполняться программе.  Когда функция
MAIN вызывается   к  исполнению,   она  вызывается  с   двумя
аргументами. Первый     аргумент  (условно  называемый  ARGC)
указывает число аргументов в командной  строке,   с  которыми
происходит обращение   к  программе;  второй  аргумент (ARGV)
является указателем на массив символьных  строк,   содержащих
эти аргументы, по одному в строке. Работа с такими строками -
это обычное использование многоуровневых указателей.
    Самую простую иллюстрацию этой возможности и  необходимых
при этом   описаний  дает  программа  ECHO,   которая  просто
печатает в одну строку аргументы командной строки,   разделяя
их пробелами. Таким образом, если дана команда
 
                          ECHO HELLO, WORLD
 
то выходом будет
 
                            HELLO, WORLD
 
по соглашению ARGV[0] является именем, по которому вызывается
программа, так    что  ARGC  по  меньшей  мере  равен  1.   В
приведенном выше примере ARGC равен 3,  а ARGV[0],  ARGV[1] и
ARGV[2] равны соответственно  "ECHO",   "HELLO,"  и  "WORLD".
Первым фактическим агументом является ARGV[1],  а последним -
ARGV[ARGC-1]. Если  ARGC равен 1,  то за именем программы  не
следует никакой командной строки аргументов. Все это показано
в ECHO:
 
         MAIN(ARGC, ARGV) /* ECHO ARGUMENTS; 1ST VERSION */
         INT ARGC;
         CHAR *ARGV[];
         \(
            INT I;
 
            FOR (I = 1; I < ARGC; I++)
          PRINTF("%S%C", ARGV[I], (I<ARGC-1) ? ' ' : '\N');
         \)
 
    Поскольку ARGV  является указателем на массив указателей,
то существует несколько способов  написания  этой  программы,
использующих работу с указателем, а не с индексацией массива.
Мы продемонстрируем два варианта.
 
         MAIN(ARGC, ARGV) /* ECHO ARGUMENTS; 2ND VERSION */
         INT ARGC;
         CHAR *ARGV[];
         \(
            WHILE (--ARGC > 0)
          PRINTF("%S%C",*++ARGV, (ARGC > 1) ? ' ' : '\N');
         \)
 
    Так как ARGV является указателем на начало массива строк-
аргументов, то,  увеличив его на 1 (++ARGV), мы вынуждаем его
указывать на подлинный аргумент ARGV[1],  а  не  на  ARGV[0].
Каждое последующее   увеличение  передвигает его на следующий
аргумент; при   этом  *ARGV  становится  указателем  на  этот
аргумент. одновременно   величина ARGC уменьшается; когда она
обратится в нуль, все аргументы будут уже напечатаны.
    Другой вариант:
 
         MAIN(ARGC, ARGV) /* ECHO ARGUMENTS; 3RD VERSION */
         INT ARGC;
         CHAR *ARGV[];
         \(
            WHILE (--ARGC > 0)
          PRINTF((ARGC > 1) ? "%S" : "%S\N", *++ARGV);
         \)
 
    Эта версия  показывает,   что  аргумент  формата  функции
PRINTF может   быть  выражением,   точно так же,  как и любой
другой. Такое  использование встречается не очень часто,   но
его все же стоит запомнить.
    Как второй     пример,     давайте    внесем    некоторые
усовершенствования в программу отыскания заданной  комбинации
символов из  главы 4.  Если вы помните,  мы поместили искомую
комбинацию глубоко внутрь программы,  что  очевидно  является
совершенно неудовлетворительным.  Следуя утилите GREP системы
UNIX, давайте  изменим программу так,  чтобы  эта  комбинация
указывалась в качестве первого аргумента строки.
 
       #DEFINE MAXLINE 1000
   
     MAIN(ARGC, ARGV) /* FIND PATTERN FROM FIRST ARGUMENT */
       INT ARGC;
       CHAR *ARGV[];
       \(
        CHAR LINE[MAXLINE];
   
        IF (ARGC != 2)
           PRINTF ("USAGE: FIND PATTERN\N");
        ELSE
         WHILE (GETLINE(LINE, MAXLINE) > 0)
               IF (INDEX(LINE, ARGV[1] >= 0)
                    PRINTF("%S", LINE);
       \)
 
    Теперь может быть развита основная модель, иллюстрирующая
дальнейшее использование   указателей.  Предположим,  что нам
надо предусмотреть   два  необязательных   аргумента.    Один
утверждает: "напечатать    все  строки  за  исключением  тех,
которые содержат данную комбинацию",  второй гласит:   "перед
каждой выводимой строкой должен печататься ее номер".
    Общепринятым соглашением в  "с"-программах  является  то,
что аргумент,      начинающийся   со   знака  минус,   вводит
необязательный признак или параметр. Если мы, для того, чтобы
сообщить об инверсии,  выберем -X, а для указания о нумерации
нужных строк выберем -N("номер"), то команда
 
                           FIND -X -N THE
 
при входных данных
 
                         NOW IS THE TIME
                         FOR ALL GOOD MEN
                         TO COME TO THE AID
                         OF THEIR PARTY.
 
должна выдать
 
                         2:FOR ALL GOOD MEN
 
    Нужно, чтобы необязательные аргументы могли располагаться
в произвольном порядке,  и чтобы остальная часть программы не
зависела от  количества фактически присутствующих аргументов.
в частности,  вызов функции INDEX не должен содержать  ссылку
на ARGV[2],  когда присутствует один необязательный аргумент,
и на ARGV[1],  когда его нет.  Более того,  для пользователей
удобно, чтобы  необязательные аргументы можно было объединить
в виде:
 
                            FIND -NX THE
 
вот сама программа:
 
 
       #DEFINE MAXLINE 1000
 
       MAIN(ARGC, ARGV) /* FIND PATTERN FROM FIRST ARGUMENT */
       INT ARGC;
       CHAR *ARGV[];
       \(
        CHAR LINE[MAXLINE], *S;
        LONG LINENO = 0;
        INT EXCEPT = 0, NUMBER = 0;
        WHILE (--ARGC > 0 && (*++ARGV)[0] == '-')
           FOR (S = ARGV[0]+1; *S != '\0'; S++)
                   SWITCH (*S) \(
                   CASE 'X':
            EXCEPT = 1;
            BREAK;
                   CASE 'N':
            NUMBER = 1;
            BREAK;
                  DEFAULT:
          PRINTF("FIND: ILLEGAL OPTION %C\N", *S);
          ARGC = 0;
          BREAK;
                  \)
       IF (ARGC != 1)
           PRINTF("USAGE: FIND -X -N PATTERN\N");
       ELSE
           WHILE (GETLINE(LINE, MAXLINE) > 0) \(
                LINENO++;
                IF ((INDEX(LINE, *ARGV) >= 0) != EXCEPT) \
              IF (NUMBER)
                  PRINTF("%LD: ", LINENO);
              PRINTF("%S", LINE);
          \)
           \)
      \)
   
    Аргумент ARGV увеличивается перед  каждым  необязательным
аргументом, в   то время как аргумент ARGC уменьшается.  если
нет ошибок,  то в конце цикла величина ARGC должна  равняться
1, а  *ARGV должно указывать на заданную комбинацию. Обратите
внимание на то,  что *++ARGV является указателем  аргументной
строки; (*++ARGV)[0] - ее первый символ. Круглые скобки здесь
необходимы, потому    что  без  них  выражение   бы   приняло
совершенно отличный (и неправильный) вид *++(ARGV[0]). Другой
правильной формой была бы **++ARGV.
    Упражнение 5-7.
    --------------
    Напишите программу ADD,   вычисляющую  обратное  польское
выражение из командной строки. Например,
 
                            ADD 2 3 4 + *
 
вычисляет 2*(3+4).
    Упражнение 5-8.
    --------------
    Модифицируйте программы  ENTAB  и  DETAB   (указанные   в
качестве упражнений в главе 1) так, чтобы они получали список
табуляционных остановок в качестве аргументов. Если аргументы
отсутствуют, используйте стандартную установку табуляций.
    Упражнение 5-9.
    --------------
    Расширьте ENTAB  и  DETAB  таким  образом,    чтобы   они
воспринимали сокращенную нотацию
     
                             ENTAB M +N
 
означающую табуляционные  остановки  через каждые N столбцов,
начиная со столбца M.  Выберите  удобное  (для  пользователя)
поведение функции по умолчанию.
    Упражнение 5-10.
    ---------------
    Напишите программу для функции TAIL, печатающей последние
N строк из своего файла ввода. Пусть по умолчанию N равно 10,
но это число может быть изменено  с  помощью  необязательного
аргумента, так что
 
                               TAIL -N
 
печатает последние N  строк.   программа  должна  действовать
рационально, какими    бы  неразумными  ни  были  бы ввод или
значение N.  Составьте программу так,  чтобы она  оптимальным
образом использовала     доступную   память:   строки  должны
храниться, как  в функции SORT,  а  не  в  двумерном  массиве
фиксированного размера.

     
     
     
     

     
     
            5.12. Указатели на функции
    
    В языке "с" сами функции  не  являются  переменными,   но
имеется возможность определить указатель на функцию,  который
можно обрабатывать,  передавать другим функциям,  помещать  в
массивы и  т.д.  Мы проиллюстрируем это,  проведя модификацию
написанной ранее программы сортировки так,  чтобы при задании
необязательного аргумента  -N она бы сортировала строки ввода
численно, а не лексикографически.
    Сортировка часто состоит  из  трех  частей  -  сравнения,
которое определяет     упорядочивание  любой  пары  объектов,
перестановки, изменяющей  их порядок, и алгоритма сортировки,
осуществляющего сравнения   и  перестановки до тех пор,  пока
объекты не расположатся в нужном порядке. Алгоритм сортировки
не зависит   от  операций сравнения и перестановки,  так что,
передавая в него различные функции сравнения и  перестановки,
мы можем   организовать  сортировку  по  различным критериям.
Именно такой подход  используется  в  нашей  новой  программе
сортировки.
    Как и прежде,  лексикографическое  сравнение  двух  строк
осуществляется функцией STRCMP, а перестановка функцией SWAP;
нам нужна еще функция NUMCMP,   сравнивающая  две  строки  на
основе численного   значения и возвращающая условное указание
того же вида,  что и STRCMP.  Эти три функции  описываются  в
MAIN и   указатели  на них передаются в SORT.  В свою очередь
функция SORT обращается к этим функциям через  их  указатели.
мы урезали   обработку  ошибок  в  аргументах  с  тем,  чтобы
сосредоточиться на главных вопросах.
 
        #DEFINE LINES 100 /* MAX NUMBER OF LINES
               TO BE SORTED */
   
        MAIN(ARGC, ARGV) /* SORT INPUT LINES */
        INT ARGC;
        CHAR *ARGV[];
        \(
         CHAR *LINEPTR[LINES]; /* POINTERS TO TEXT LINES */
         INT NLINES; /* NUMBER OF INPUT LINES READ */
         INT STRCMP(), NUMCMP(); /* COMPARSION FUNCTIONS */
         INT SWAP(); /* EXCHANGE FUNCTION */
         INT NUMERIC = 0; /* 1 IF NUMERIC SORT */
   
         IF(ARGC>1 && ARGV[1][0] == '-' && ARGV[1][1]=='N')
            NUMERIC = 1;
         IF(NLINES = READLINES(LINEPTR, LINES)) >= 0) \(
            IF (NUMERIC)
                  SORT(LINEPTR, NLINES, NUMCMP, SWAP);
            ELSE
                  SORT(LINEPTR, NLINES, STRCMP, SWAP);
            WRITELINES(LINEPTR, NLINES);
         \) ELSE
            PRINTF("INPUT TOO BIG TO SORT\N");
        \)
        
    Здесь STRCMP,  NIMCMP и SWAP - адреса  функций;  так  как
известно, что    это  функции,   операция  &  здесь  не нужна
совершенно аналогично тому,  как она не нужна и перед  именем
массива. Передача  адресов функций организуется компилятором.
    Второй шаг состоит в модификации SORT:
 
    SORT(V, N, COMP, EXCH) /* SORT STRINGS V[0] ... V[N-1] */
      CHAR *V[];           /* INTO INCREASING ORDER */
      INT N;
      INT (*COMP)(), (*EXCH)();
      \(
       INT GAP, I, J;
   
       FOR(GAP = N/2; GAP > 0; GAP /= 2)
           FOR(I = GAP; I < N; I++)
          FOR(J = I-GAP; J >= 0; J -= GAP) \(
              IF((*COMP)(V[J], V[J+GAP]) <= 0)
                  BREAK;
              (*EXCH)(&V[J], &V[J+GAP]);
          \)
      \)
      
    Здесь следует обратить определенное внимание на описания.
 Описание
 
                            INT (*COMP)()
 
говорит, что COMP является указателем  на  функцию,   которая
возвращает значение   типа  INT.  Первые круглые скобки здесь
необходимы; без них описание
 
                             INT *COMP()
 
говорило бы,   что  COMP  является  функцией,    возвращающей
указатель на целые, что, конечно, совершенно другая вещь.
    Использование COMP в строке
 
                  IF (*COMP)(V[J], V[J+GAP]) <= 0)
 
полностью согласуется  с  описанием:   COMP  -  указатель  на
функцию, *COMP - сама функция, а
 
                       (*COMP)(V[J], V[J+GAP])
 
- обращение к ней.  Круглые скобки необходимы для правильного
объединения компонентов.
    Мы уже приводили функцию STRCMP,  сравнивающую две строки
по первому численному значению:
 
         NUMCMP(S1, S2) /* COMPARE S1 AND S2 NUMERICALLY */
         CHAR *S1, *S2;
         \(
           DOUBLE ATOF(), V1, V2;
 
           V1 = ATOF(S1);
           V2 = ATOF(S2);
           IF(V1 < V2)
              RETURN(-1);
           ELSE IF(V1 > V2)
              RETURN(1);
           ELSE
              RETURN (0);
         \)
         
    Заключительный шаг  состоит  в  добавлении  функции SWAP,
переставляющей два     указателя.    Это    легко    сделать,
непосредственно используя   то,  что мы изложили ранее в этой
главе.
 
             SWAP(PX, PY) /* INTERCHANGE *PX AND *PY */
             CHAR *PX[], *PY[];
             \(
              CHAR *TEMP;
 
              TEMP = *PX;
              *PX = *PY;
              *PY = TEMP;
             \)
    
    Имеется множество   других   необязятельных   аргументов,
которые могут быть включены в программу сортировки: некоторые
из них составляют интересные упражнения.
    Упражнение 5-11.
    ---------------
    Модифицируйте SORT таким образом,  чтобы она  работала  с
меткой -R,   указывающей на сортировку в обратном (убывающем)
порядке. Конечно, -R должна работать с -N.
    Упражнение 5-12.
    ---------------
    Добавьте необязательный аргумент -F,  объединяющий вместе
прописные и строчные буквы,  так чтобы различие регистров  не
учитывалось во время сортировки: данные из верхнего и нижнего
регистров сортируются вместе,  так что буква 'а' прописное  и
'а' строчное оказываются соседними ,  а не разделенными целым
алфавитом.
    Упражнение 5-13.
    ---------------
    Добавьте необязательный    аргумент    -D     ("словарное
упорядочивание"), при    наличии которого сравниваются только
буквы, числа и пробелы. Позаботьтесь о том, чтобы эта функция
работала и вместе с -F.
    Упражнение 5-14.
    ---------------
    Добавьте возможность  обработки  полей,   так чтобы можно
было сортировать  поля  внутри  строк.   Каждое  поле  должно
сортироваться в      соответствии   с   независимым   набором
необязательных аргументов.  (предметный указатель этой  книги
сортировался с помощью аргументов -DF для категории указателя
и с -N для номеров страниц).
     
     
     
     
     
     
     
 
 


                   6. Структуры.

    Структура -  это  набор  из  одной  или более переменных,
возможно различных типов,  сгруппированных под  одним  именем
для удобства обработки.  (В некоторых языках, самый известный
из которых паскаль, структуры называются "записями").
    Традиционным примером структуры является учетная карточка
работающего: "служащий"  описывается набором атрибутов таких,
как фамилия,  имя,  отчество (ф.и.о.), адрес, код социального
обеспечения, зарплата и т.д. Некоторые из этих атрибутов сами
могут оказаться     структурами:    ф.и.о.   Имеет  несколько
компонент, как и адрес, и даже зарплата.
    Структуры оказываются полезными при  организации  сложных
данных особенно   в  больших программах,  поскольку во многих
ситуациях они позволяют сгруппировать связанные данные  таким
образом, что с ними можно обращаться, как с одним целым, а не
как с отдельными объектами.   В  этой  главе  мы  постараемся
продемонстрировать то, как используются структуры. Программы,
которые мы для этого будем использовать,  больше,  чем многие
другие в этой книге, но все же достаточно умеренных размеров.









                6.1. Основные сведения.

    Давайте снова обратимся к процедурам преобразования  даты
из главы   5.   Дата состоит из нескольких частей таких,  как
день, месяц,  и год, и, возможно, день года и имя месяца. Эти
пять переменных можно объеденить в одну структуру вида:

                          STRUCT DATE \(
                          INT  DAY;
                          INT  MONTH;
                          INT  YEAR;
                          INT  YEARDAY;
                          CHAR MON_NAME[4];
                          \);
 
    Описание структуры,  состоящее из заключенного в фигурные
скобки списка описаний,  начинается с ключевого слова STRUCT.
За словом     STRUCT   может  следовать  необязательное  имя,
называемое ярлыком структуры (здесь это DATе).   Такой  ярлык
именует структуры    этого  вида  и  может  использоваться  в
дальнейшем как сокращенная запись подробного описания.
    Элементы или   переменные,    упомянутые   в   структуре,
называются членами. Ярлыки и члены структур могут иметь такие
же имена,  что и  обычные  переменные  (т.е.   Не  являющиеся
членами структур),  поскольку их имена всегда можно различить
по контексту.  Конечно,  обычно одинаковые имена  присваивают
только тесно связанным объектам.
    Точно так же, как в случае любого другого базисного типа,
за правой фигурной скобкой,  закрывающей список членов, может
следовать список переменных.
    Оператор
 
                      STRUCT   \( ...\) X,Y,Z;
 
синтаксически аналогичен
 
                             INT X,Y,Z;
 
в том смысле,  что каждый из операторов описывает X , Y и Z в
качестве переменных     соотвествующих  типов  и  приводит  к
выделению для них памяти.
    Описание структуры,   за  которым   не   следует   списка
переменных, не    приводит к выделению какой-либо памяти; оно
только определяет шаблон или форму структуры.  Однако,   если
такое описание   снабжено  ярлыком,  то этот ярлык может быть
использован позднее при определении  фактических  экземпляров
структур. Например, если дано приведенное выше описание DATE,
то
 
                           STRUCT  DATE D;
 
определяет переменную  D  в  качестве  структуры  типа  DATE.
Внешнюю или  статическую  структуру  можно  инициализировать,
поместив вслед  за ее определением список инициализаторов для
ее компонент:
 
             STRUCT DATE D=\( 4, 7, 1776, 186, "JUL"\);
 
    Член определенной структуры может быть указан в выражении
с помощью конструкции вида
 
                        имя структуры . Член
                        --------------------
    
    Операция указания   члена  структуры  "."  связывает  имя
структуры и имя члена.  В  качестве  примера  определим  LEAP
(признак високосности   года)  на основе даты,  находящейся в
структуре D,
 
             LEAP = D.YEAR % 4 == 0 && D.YEAR % 100 != 0
             \!\! D.YEAR % 400 == 0;
 
или проверим имя месяца
 
               IF (STRCMP(D.MON_NAME, "AUG") == 0) ...
 
    Или преобразуем первый символ имени месяца так, чтобы оно
начиналось со строчной буквы
 
                D.MON_NAME[0] = LOWER(D.MON_NAME[0]);
 
    Структуры могут   быть   вложенными;   учетная   карточка
служащего может фактически выглядеть так:
 
          STRUCT  PERSON  \(
             CHAR NAME[NAMESIZE];
             CHAR ADDRESS[ADRSIZE];
             LONG ZIPCODE;   /* почтовый индекс */
             LONG SS_NUMBER; /* код соц. Обеспечения */
             DOUBLE SALARY;  /* зарплата */
             STRUCT DATE BIRTHDATE; /* дата рождения */
             STRUCT DATE HIREDATE; /* дата поступления
                                                на работу */
          \);
          
    Структура PERSON содержит две структуры типа DATE .  Если
мы определим EMP как
 
                         STRUCT PERSON EMP;
 
то
 
                         EMP.BIRTHDATE.MONTH
 
будет ссылаться  на  месяц рождения.  Операция указания члена
структуры "." ассоциируется слева направо.

     
     
     
     

   
   
   

     
     
     
               6.2. Структуры и функции.
    
    В языке "C" существует ряд ограничений  на  использование
структур. Обязательные    правила  заключаются  в  том,   что
единственные операции,    которые  вы  можете  проводить   со
структурами, состоят    в  определении  ее  адреса  с помощью
операции & и доступе к одному из ее членов.   Это  влечет  за
собой то, что структуры нельзя присваивать или копировать как
целое, и   что  они  не  могут  быть  переданы  функциям  или
возвращены ими.  (В последующих версиях эти ограничения будут
сняты). На  указатели  структур  эти  ограничения  однако  не
накладываются, так    что  структуры и функции все же могут с
удобством работать  совместно.   И  наконец,   автоматические
структуры, как    и  автоматические  массивы,   не могут быть
инициализированы; инициализация   возможна  только  в  случае
внешних или статических структур.
    Давайте разберем некоторые из этих вопросов,  переписав с
этой целью   функции  перобразования даты из предыдущей главы
так, чтобы  они  использовали  структуры.   Так  как  правила
запрещают непосредственную передачу структуры функции,  то мы
должны либо передавать отдельно  компоненты,   либо  передать
указатель всей структуры.  Первая возможность демонстрируется
на примере функции DAY_OF_YEAR, как мы ее написали в главе 5:
     
          D.YEARDAY = DAY_OF_YEAR(D.YEAR, D.MONTH, D.DAY);
 
другой способ состоит в передаче указателя.  если  мы  опишем
HIREDATE как
 
                       STRUCT  DATE HIREDATE;
 
и перепишем  DAY_OF_YEAR  нужным  образом,   мы  сможем тогда
 написать
 
             HIREDATE YEARDAY = DAY_OF_YEAR(&HIREDATE);
 
передавая указатель на HIREDATE функции DAY_OF_YEAR . Функция
должна быть модифицирована,  потому что  ее  аргумент  теперь
является указателем, а не списком переменных.
 
    DAY_OF_YEAR(PD) /* SET DAY OF YEAR FROM MONTH, DAY */
       STRUCT DATE *PD;
       \(
    INT I, DAY, LEAP;
 
    DAY = PD->DAY;
    LEAP = PD->YEAR % 4 == 0 && PD->YEAR % 100 != 0
       \!\! PD->YEAR % 400 == 0;
    FOR (I =1;  I < PD->MONTH; I++)
       DAY += DAY_TAB[LEAP][I];
    RETURN(DAY);
        \)
       
    Описание
 
                          STRUCT DATE *PD;
 
говорит, что PD  является  указателем  структуры  типа  DATE.
Запись, показанная на примере
 
                              PD->YEAR
 
является новой. Если P - указатель на структуру, то
    
                P-> член структуры
                ------------------
    
обращается к конкретному члену.   (Операция  ->  -  это  знак
минус, за которым следует знак ">".)
    Так как PD указывает на структуру,  то к члену YEAR можно
обратиться и следующим образом
 
                             (*PD).YEAR
 
но указатели  структур  используются  настолько  часто,   что
запись -> оказывается удобным сокращением.  Круглые скобки  в
(*PD).YEAR необходимы,    потому  что операция указания члена
стуктуры старше ,  чем  *  .   Обе  операции,   "->"  и  ".",
ассоциируются слева   направо,   так  что конструкции слева и
справа зквивалентны
 
            P->Q->MEMB             (P->Q)->MEMB
            EMP.BIRTHDATE.MONTH    (EMP.BIRTHDATE).MONTH
 
    Для полноты ниже приводится другая  функция,   MONTH_DAY,
переписанная с использованием структур.
 
      MONTH_DAY(PD) /* SET MONTH AND DAY FROM DAY OF YEAR */
       STRUCT DATE *PD;
       \(
     INT I, LEAP;
 
     LEAP = PD->YEAR % 4 == 0 && PD->YEAR % 100 != 0
        \!\! PD->YEAR % 400 == 0;
     PD->DAY = PD->YEARDAY;
     FOR (I = 1; PD->DAY > DAY_TAB[LEAP][I]; I++)
        PD->DAY -= DAY_TAB[LEAP][I];
     PD->MONTH = I;
        \)
 
    Операции работы со структурами "->" и "."  наряду  со  ()
для списка   аргументов  и [] для индексов находятся на самом
верху иерархии   страшинства  операций   и,    следовательно,
связываются очень крепко. Если, например, имеется описание
 
                              STRUCT \(
                                 INT X;
                                 INT *Y;
                              \) *P;
 
то выражение
 
                               ++P->X
     
увеличивает х,  а не р,  так как оно  эквивалентно  выражению
++(P->х). Для    изменения  порядка выполнения операций можно
использовать круглые   скобки:   (++P)->х  увеличивает  P  до
доступа к х,  а (P++)->X увеличивает P после. (круглые скобки
в последнем случае необязательны. Почему ?)
    Совершенно аналогично   *P->Y   извлекает   то,   на  что
указывает Y; *P->Y++ увеличивает Y после обработки того,   на
что он   указывает  (точно  так  же,   как и *S++); (*P->Y)++
увеличивает то,  на что указывает Y;  *P++->Y  увеличивает  P
после выборки того, на что указывает Y.
  

     
 
     
     
              6.3. Массивы сруктур.
    
    Структуры особенно   подходят  для  управления  массивами
связанных переменных.    Рассмотрим,   например,    программу
подсчета числа   вхождений каждого ключевого слова языка "C".
Нам нужен массив символьных строк для хранения имен и  массив
целых для     подсчета.    одна  из  возможностей  состоит  в
использовании двух параллельных массивов KEYWORD и  KEYCOUNT:
 
                       CHAR *KEYWORD [NKEYS];
                       INT  KEYCOUNT [NKEYS];
 
    Но сам факт,   что  массивы  параллельны,   указывает  на
возможность другой  организации.  Каждое ключевое слово здесь
по существу является парой:
 
                           CHAR *KEYWORD;
                           INT  KEYCOUNT;
 
и, следовательно, имеется массив пар. Описание структуры
 
                           STRUCT KEY  \(
                              CHAR *KEYWORD;
                              INT  KEYCOUNT;
                           \) KEYTAB [NKEYS];
 
оперделяет массив KEYTAB структур такого типа и  отводит  для
них память.  Каждый элемент массива является структурой.  Это
можно было бы записать и так:
 
                   STRUCT KEY  \(
                      CHAR *KEYWORD;
                      INT  KEYCOUNT;
                   \);
                   STRUCT KEY KEYTAB [NKEYS];
 
    Так как структура KEYTAB фактически  содержит  постоянный
набор имен, то легче всего инициализировать ее один раз и для
всех членов при определении.  Инициализация  структур  вполне
аналогична предыдущим     инициализациям  -  за  определением
следует заключенный в фигурные скобки список инициализаторов:
 
                        STRUCT KEY  \(
                           CHAR *KEYWORD;
                           INT  KEYCOUNT;
                        \) KEYTAB[] =\(
                          "BREAK", 0,
                          "CASE", 0,
                          "CHAR", 0,
                          "CONTINUE", 0,
                          "DEFAULT", 0,
                          /* ... */
                          "UNSIGNED", 0,
                          "WHILE", 0
                        \);
 
    Инициализаторы перечисляются парами соответственно членам
структуры. Было    бы более точно заключать в фигурные скобки
инициализаторы для каждой "строки"  или  структуры  следующим
образом:
 
                          \( "BREAK", 0 \),
                          \( "CASE", 0 \),
                                . . .
 
    Но когда инициализаторы являются простыми переменными или
символьными строками и все они присутствуют, то во внутренних
фигурных скобках нет необходимости.  Как обычно,   компилятор
сам вычислит     число   элементов   массива   KEYTAB,   если
инициализаторы присутствуют, а скобки [] оставлены пустыми.
    Программа подсчета ключевых слов начинается с определения
массива KEYTAB.  ведущая программа читает  свой  файл  ввода,
последовательно обращаясь     к   функции  GETWORD,   которая
извлекает из ввода по одному слову за обращение. Каждое слово
ищется в  массиве KEYTAB с помощью варианта функции бинарного
поиска, написанной  нами в главе  3.   (Конечно,   чтобы  эта
функция работала, список ключевых слов должен быть расположен
в порядке возрастания).
 
      #DEFINE    MAXWORD   20
 
      MAIN()   /* COUNT "C" KEYWORDS */
      \(
      INT  N, T;
      CHAR WORD[MAXWORD];
 
      WHILE ((T = GETWORD(WORD,MAXWORD)) != EOF)
         IF (T == LETTER)
           IF((N = BINARY(WORD,KEYTAB,NKEYS)) >= 0)
              KEYTAB[N].KEYCOUNT++;
      FOR (N =0; N < NKEYS; N++)
         IF (KEYTAB[N].KEYCOUNT > 0)
          PRINTF("%4D %S\N",
            KEYTAB[N].KEYCOUNT, KEYTAB[N].KEYWORD);
      \)
      BINARY(WORD, TAB, N) /* FIND WORD
                                  IN TAB[0]...TAB[N-1] */
      CHAR *WORD;
      STRUCT KEY TAB[];
      INT N;
      \(
       INT LOW, HIGH, MID, COND;
       
       LOW = 0;
       HIGH = N - 1;
       WHILE (LOW <= HIGH) \(
         MID = (LOW+HIGH) / 2;
         IF((COND = STRCMP(WORD, TAB[MID].KEYWORD)) < 0)
          HIGH = MID - 1;
         ELSE IF (COND > 0)
          LOW = MID + 1;
         ELSE
          RETURN (MID);
       \)
       RETURN(-1);
      \)
    Мы вскоре   приведем  функцию  GETWORD;  пока  достаточно
сказать, что  она возвращает  LETTER  каждый  раз,   как  она
находит слово, и копирует это слово в свой первый аргумент.
    Величина NKEYS - это количество ключевых слов  в  массиве
KEYTAB .  Хотя мы можем сосчитать это число вручную,  гораздо
легче и надежнее поручить это машине,  особенно в том случае,
если список   ключевых  слов  подвержен изменениям.  Одной из
возможностей было   бы   закончить   список   инициализаторов
указанием на   нуль  и  затем  пройти  в  цикле сквозь массив
KEYTAB, пока не найдется конец.
    Но, поскольку размер этого массива полностью определен  к
моменту компиляции,  здесь имеется более простая возможность.
Число элементов просто есть
 
                 SIZE OF KEYTAB / SIZE OF STRUCT KEY
 
дело в том,  что в языке "C" предусмотрена  унарная  операция
SIZEOF, выполняемая   во время компиляции,  которая позволяет
вычислить размер любого объекта. Выражение
 
                           SIZEOF(OBJECT)
 
выдает целое,  равное размеру  указанного  объекта.   (Размер
определяется в    неспецифицированных  единицах,   называемых
"байтами", которые имеют тот же размер, что и переменные типа
CHAR). Объект  может быть фактической переменной,  массивом и
структурой, или  именем основного типа,  как INT или  DOUBLE,
или именем производного типа,  как структура.  В нашем случае
число ключевых слов  равно  размеру  массива,   деленному  на
размер одного элемента массива. Это вычисление используется в
утверждении #DEFINE для установления значения NKEYS:
 
         #DEFINE NKEYS (SIZEOF(KEYTAB) / SIZEOF(STRUCT KEY))
 
    Теперь перейдем к функции GETWORD. Мы фактически написали
более общий вариант функции GETWORD,  чем необходимо для этой
программы, но   он не на много более сложен.  Функция GETWORD
возвращает следующее "слово" из ввода,  где словом  считается
либо строка букв и цифр, начинающихся с буквы, либо отдельный
символ. Тип  объекта возвращается в качетве значения функции;
это - LETTER,  если найдено слово,  EOF для конца файла и сам
символ, если он не буквенный.
 
          GETWORD(W, LIM)   /* GET NEXT WORD FROM INPUT */
          CHAR *W;
          INT LIM;
          \(
           INT C, T;
           IF (TYPE(C=*W++=GETCH()) !=LETTER) \(
                *W='\0';
                RETURN(C);
           \)
          WHILE (--LIM > 0)  \(
           T = TYPE(C = *W++ = GETCH());
           IF (T ! = LETTER && T ! = DIGIT) \(
                UNGETCH(C);
                BREAK;
           \)
          \)
          *(W-1) - '\0';
          RETURN(LETTER);
          \)
 
    Функция GETWORD   использует  функции  GETCH  и  UNGETCH,
которые мы  написали  в  главе  4:   когда  набор  алфавитных
символов прерывается,    функция GETWORD получает один лишний
символ. В  результате вызова UNGETCH этот  символ  помещается
назад во ввод для следующего обращения.
    Функция GETWORD обращается к функции TYPE для определения
типа каждого отдельного символа из файла ввода.  Вот вариант,
справедливый только для алфавита ASCII.
 
           TYPE(C)  /* RETURN TYPE OF ASCII CHARACTER */
           INT C;
            \(
           IF (C>= 'A' && C<= 'Z' \!\! C>= 'A' && C<= 'Z')
                RETURN(LETTER);
           ELSE IF (C>= '0' && C<= '9')
                RETURN(DIGIT);
           ELSE
                RETURN(C);
           \)
 
    Символические константы LETTER и DIGIT могут иметь  любые
значения, лишь    бы  они не вступали в конфликт с символами,
отличными от буквенно-цифровых,  и с EOF;  очевидно  возможен
следующий выбор
 
                       #DEFINE   LETTER   'A'
                       #DEFINE   DIGIT   '0'
 
    Функция GETWORD  могла  бы  работать  быстрее,   если  бы
обращения к   функции  TYPE  были  заменены   обращениями   к
соответствующему массиву   TYPE[ ].  В стандартной библиотеке
языка "C"    предусмотрены   макросы   ISALPHA   и   ISDIGIT,
действующие необходимым образом.
    Упражнение 6-1.
    --------------
    Сделайте такую модификацию функции GETWORD и оцените, как
изменится скорость работы программы.
    Упражнение 6-2.
    --------------
    Напишите вариант   функции   TYPE,    не   зависящий   от
конкретного набора символов.
    Упражнение 6-3.
    --------------
    Напишите вариант   программы   подсчета   ключевых  слов,
который бы не учитывал появления этих слов  в  заключенных  в
кавычки строках.

     
     
     
     
     
 
      
     
             6.4. Указатели на структуры.
    
    Чтобы проиллюстрировать некоторые соображения,  связанные
с использованием   указателей  и  массивов структур,  давайте
снова составим программу подсчета ключевых строк,   используя
на этот раз указатели, а не индексы массивов.
    Внешнее описание массива KEYTAB не  нужно  изменять,   но
функции MAIN и BINARY требуют модификации.
 
           MAIN()   /* COUNT C KEYWORD; POINTER VERSION */
           \(
          INT  T;
          CHAR WORD[MAXWORD];
          STRUCT KEY *BINARY(), *P;
          WHILE ((T = GETWORD(WORD, MAXWORD;) !=EOF)
            IF (T==LETTER)
            IF ((P=BINARY(WORD,KEYTAB,NKEYS)) !=NULL)
                    P->KEYCOUNT++;
          FOR (P=KEYTAB; P>KEYTAB + NKEYS; P++)
            IF (P->KEYCOUNT > 0)
         PRINTF("%4D %S/N", P->KEYCOUNT, P->KEYWORD);
           \)
            STRUCT KEY *BINARY(WORD, TAB, N) /* FIND WORD */
           CHAR *WORD   /* IN TAB[0]...TAB[N-1] */
           STRUCT KEY TAB [];
           INT N;
           \(
          INT  COND;
          STRUCT KEY *LOW = &TAB[0];
          STRUCT KEY *HIGH = &TAB[N-1];
          STRUCT KEY *MID;
          WHILE (LOW <= HIGH) \(
         MID = LOW + (HIGH-LOW) / 2;
         IF ((COND = STRCMP(WORD, MID->KEYWORD)) < 0)
               HIGH = MID - 1;
         ELSE IF (COND > 0)
               LOW = MID + 1;
         ELSE
               RETURN(MID);
          \)
          RETURN(NULL);
           \)
 
    Здесь имеется несколько моментов, которые стоит отметить.
Во-первых, описание  функции BINARI должно указывать, что она
возвращает указатель   на структуру типа KEY,  а не на целое;
это объявляется как в функции MAIN,  так и  в  BINARY.   Если
функция BINARI находит слово,  то она возвращает указатель на
него; если же нет, она возвращает NULL.
    Во-вторых, все   обращения  к  элементам  массива  KEYTAB
осуществляются через указатели.  Это  влечет  за  собой  одно
существенное изменение   в  функции  BINARY:  средний элемент
больше нельзя вычислять просто по формуле
 
                       MID = (LOW + HIGH) / 2
 
потому что  сложение  двух  указателей  не дает какого-нибудь
полезного результата   (даже  после  деления  на  2)    и   в
действительности является    незаконным.   эту  формулу  надо
заменить на
 
                     MID = LOW + (HIGH-LOW) / 2
 
в результате  которой  MID  становится указателем на элемент,
расположенный посередине между LOW и HIGH.
    Вам также следует разобраться в инициализации LOW и HIGH.
указатель можно инициализировать адресом ранее  определенного
объекта; именно как мы здесь и поступили.
    В функции MAIN мы написали
 
               FOR (P=KEYTAB; P < KEYTAB + NKEYS; P++)
 
    Если P является указателем структуры, то любая арифметика
с P учитывает фактический размер данной структуры, так что P+
+ увеличивает P на нужную  величину,   в  результате  чего  P
указывает на   следующий  элемент  массива  структур.   Но не
считайте, что   размер  структуры  равен  сумме  размеров  ее
членов, -     из-за  требований  выравнивания  для  различных
объектов в структуре могут возникать "дыры".
    И, наконец,   несколько  второстепенный  вопрос  о  форме
записи программы.   Если возвращаемая функцией величина имеет
тип, как, например, в
 
                  STRUCT KEY *BINARY(WORD, TAB, N)
 
то может  оказаться,   что  имя функции трудно выделить среди
текста. В  связи с  этим  иногда  используется  другой  стиль
записи:
 
                            STRUCT KEY *
                        BINARY(WORD, TAB, N)
 
    Это главным   образом  дело  вкуса;  выберите  ту  форму,
которая вам нравится, и придерживайтесь её.
   
     
     
     
     
     
                                     
     
     
          6.5. Структуры, ссылающиеся на себя.
    
    Предположим, что  нам  надо  справиться  с  более   общей
задачей, состоящей    в  подсчете числа появлений всех слов в
некотором файле  ввода.   Так  как  список  слов  заранее  не
известен, мы    не  можем  их  упорядочить  удобным образом и
использовать бинарный поиск.  Мы даже не  можем  осуществлять
последовательный просмотр   при поступлении каждого слова,  с
тем чтобы установить,  не встречалось  ли  оно  ранее;  такая
программа будет работать вечно. (Более точно, ожидаемое время
работы растет как квадрат числа вводимых слов).  Как  же  нам
организовать программу,      чтобы   справиться   со  списком
произвольных слов?
    Одно из  решений  состоит в том,  чтобы все время хранить
массив поступающих до сих  пор  слов  в  упорядоченном  виде,
помещая каждое   слово в нужное место по мере их поступления.
Однако это не следует делать,   перемещая  слова  в  линейном
массиве, -  это также потребует слишком много времени. Вместо
этого мы используем  структуру  данных,   называемую  доичным
деревом.
    Каждому новому  слову  соответствует  один "узел" дерева;
каждый узел содержит:
                    указатель текста слова
                    ----------------------
                    счетчик числа появлений
                    -----------------------
                    указатель узла левого потомка
                    -----------------------------
                    указатель узла правого потомка
                    ------------------------------
    Никакой узел  не  может  иметь более двух детей; возможно
отсутсвие детей или наличие только одного потомка.
    Узлы создаются таким образом, что левое поддерево каждого
узла содержит только те слова,  которые меньше слова  в  этом
узле, а    правое поддерево только те слова,  которые больше.
Чтобы определить,  находится ли новое  слово  уже  в  дереве,
начинают с    корня  и  сравнивают  новое  слово  со  словом,
хранящимся в этом узле.  Если  слова  совпадают,   то  вопрос
решается утвердительно.    Если  новое  слово  меньше слова в
дереве, то    переходят  к  рассмотрению  левого  потомка;  в
противном случае   исследуется правый потомок.  Если в нужном
направлении потомок отсутствует,  то значит  новое  слово  не
находится в дереве и место этого недостающего потомка как раз
и является  местом,   куда  следует  поместить  новое  слово.
Поскольку поиск   из  любого узла приводит к поиску одного из
его потомков,  то сам процесс  поиска  по  существу  является
рекурсивным. В    соответствии  с  этим  наиболее естественно
использовать рекурсивные процедуры ввода и вывода.
    Возвращаясь назад  к описанию узла,  ясно,  что это будет
структура с четырьмя компонентами:
 
             STRUCT TNODE \( /* THE BASIC NODE */
                CHAR *WORD; /* POINTS TO THE TEXT */
                INT   COUNT; /* NUMBER OF OCCURRENCES */
                STRUCT TNODE *LEFT; /* LEFT CHILD */
                STRUCT TNODE *RIGHT; /* RIGHT CHILD */
             \);
 
    Это "рекурсивное"    описание   узла   может   показаться
рискованным, но на самом деле оно вполне корректно. Структура
не имеет права содержать ссылку на саму себя, но
 
                         STRUCT TNODE *LEFT;
 
описывает LEFT как указатель на узел, а не как сам узел.
    Текст самой программы оказывается удивительно  маленьким,
если, конечно,     иметь в распоряжении набор написанных нами
ранее процедур,  обеспечивающих нужные действия.  Мы имеем  в
виду функцию   GETWORD  для извлечения каждого слова из файла
ввода и функцию ALLOC для выделения места для хранения  слов.
    Ведущая программа   просто   считывает  слова  с  помощью
функции GETWORD и помещает их в  дерево,   используя  функцию
TREE.
 
          #DEFINE   MAXWORD   20
          MAIN()    /* WORD FREGUENCY COUNT */
          \(
              STRUCT TNODE *ROOT, *TREE();
              CHAR WORD[MAXWORD];
              INT   T;
              ROOT = NULL;
              WHILE ((T = GETWORD(WORD, MAXWORD)) \! = EOF)
                 IF (T == LETTER)
                      ROOT = TREE(ROOT, WORD);
              TREEPRINT(ROOT);
          \)
 
    Функция TREE  сама  по  себе  проста.   Слово  передается
функцией MAIN к верхнему уровню (корню)  дерева.   На  каждом
этапе это слово сравнивается со словом, уже хранящимся в этом
узле, и с помощью рекурсивного обращения к TREE просачивается
вниз либо к левому,  либо к правому поддереву. В конце концов
это слово либо совпадает с каким-то словом, уже находящимся в
дереве (в этом случае счетчик увеличивается на единицу), либо
программа натолкнется на нулевой указатель, свидетельствующий
о необходимости создания и добавления к дереву нового узла. В
случае создания нового узла функция TREE возвращает указатель
этого узла, который помещается в родительский узел.
 
          STRUCT TNODE *TREE(P, W)
                 /* INSTALL W AT OR BELOW P */
          STRUCT TNODE *P;
          CHAR *W;
          \(
             STRUCT TNODE *TALLOC();
             CHAR *STRSAVE();
             INT COND;
             IF (P == NULL) \( /* A NEW WORD
                HAS ARRIVED */
                  P == TALLOC(); /* MAKE A NEW NODE */
                  P->WORD = STRSAVE(W);
                  P->COUNT = 1;
                  P->LEFT = P->RIGHT = NULL;
          \) ELSE IF ((COND = STRCMP(W, P->WORD)) == 0)
                  P->COUNT++;     /* REPEATED WORD */
                  ELSE IF (COND < 0)/* LOWER GOES INTO
                                           LEFT SUBTREE */
                  P->LEFT = TREE(P->LEFT, W);
          ELSE            /* GREATER INTO RIGHT SUBTREE */
                  P->RIGHT = TREE(P->RIGHT, W);
          RETURN(P);
          \)
 
    Память для   нового   узла  выделяется  функцией  TALLOC,
являющейся адаптацией   для  данного  случая  функции  ALLOC,
написанной нами   ранее.  Она возвращает указатель свободного
пространства, пригодного для хранения нового узла дерева. (Мы
вскоре обсудим    это  подробнее).   Новое  слово  копируется
функцией STRSAVE в скрытое место,   счетчик  инициализируется
единицей, и указатели обоих потомков полагаются равными нулю.
Эта часть программы выполняется только при добавлении  нового
узла к   ребру  дерева.  Мы здесь опустили проверку на ошибки
возвращаемых функций STRSAVE и TALLOC значений (что неразумно
для практически работающей программы).
    Функция TREEPRINT  печатает  дерево,   начиная  с  левого
поддерева; в каждом узле сначала печатается  левое  поддерево
(все слова,  которые младше этого слова), затем само слово, а
затем правое поддерево (все слова,  которые старше).  Если вы
неуверенно оперируете   с рекурсией,  нарисуйте дерево сами и
напечатайте его с помощью функции TREEPRINT  ;  это  одна  из
наиболее ясных рекурсивных процедур, которую можно найти.
 
           TREEPRINT (P) /* PRINT TREE  P  RECURSIVELY */
           STRUCT TNODE *P;
           \(
              IF (P != NULL)    \(
                 TREEPRINT (P->LEFT);
                 PRINTF("%4D %S\N", P->COUNT, P->WORD);
                 TREEPRINT (P->RIGHT);
              \)
           \)
 
    Практическое замечание:     если    дерево     становится
"несбалансированным" из-за   того,   что слова поступают не в
случайном порядке,  то время  работы  программы  может  расти
слишком быстро.  В худшем случае, когда поступающие слова уже
упорядочены, настоящая  программа осуществляет  дорогостоящую
имитацию линейного   поиска.   Существуют различные обобщения
двоичного дерева, особенно 2-3 деревья и AVL деревья, которые
не ведут себя так "в худших случаях", но мы не будем здесь на
них останавливаться.
    Прежде чем расстаться с этим примером,   уместно  сделать
небольшое отступление   в  связи  с  вопросом о распределении
памяти. Ясно,   что в программе желательно иметь только  один
распределитель памяти,    даже  если ему приходится размещать
различные виды объектов.  Но если мы хотим использовать  один
распределитель памяти   для  обработки  запросов на выделение
памяти для   указателей  на  переменные  типа  CHAR   и   для
указателей на   STRUCT  TNODE,   то  при  этом  возникают два
вопроса. Первый: как выполнить то существующее на большинстве
реальных машин   ограничение,  что объекты определенных типов
должны удовлетворять   требованиям  выравнивания   (например,
часто целые должны размещаться в четных адресах)? Второй: как
организовать описания,  чтобы справиться с тем,  что  функция
ALLOC должна возвращать различные виды указателей ?
    Вообще говоря, требования выравнивания легко выполнить за
счет выделения    некоторого  лишнего  пространства,   просто
обеспечив то,  чтобы распределитель памяти  всегда  возвращал
указатель, удовлетворяющий    всем ограничениям выравнивания.
Например, на  PDP-11 достаточно,  чтобы функция ALLOC  всегда
возвращала четный  указатель,  поскольку в четный адрес можно
поместить любой тип объекта.  единственный расход при этом  -
лишний символ   при  запросе  на нечетную длину.  Аналогичные
действия предпринимаются на других машинах.   Таким  образом,
реализация ALLOC   может  не  оказаться  переносимой,   но ее
использование будет переносимым.  Функция ALLOC из главы 5 не
предусматривает никакого  определенного выравнивания; в главе
8 мы продемонстрируем, как правильно выполнить эту задачу.
    Вопрос описания типа функции ALLOC  является  мучительным
для любого   языка,   который  серьезно  относится к проверке
типов. Лучший  способ в языке  "C"  -  объявить,   что  ALLOC
возвращает указатель   на переменную типа CHAR,  а затем явно
преобразовать этот  указатель  к  желаемому  типу  с  помощью
операции перевода типов. Таким образом, если описать P в виде
 
                              CHAR *P;
то
                         (STRUCT TNODE *) P
 
преобразует его в выражениях в указатель  на  структуру  типа
TNODE .  Следовательно, функцию TALLOC можно записать в виде:
 
      STRUCT TNODE *TALLOC()
      \(
       CHAR *ALLOC();
      
       RETURN ((STRUCT TNODE *) ALLOC(SIZEOF(STRUCT TNODE)));
      \)
   
это более чем достаточно для  работающих  в  настоящее  время
компиляторов, но    это  и  самый  безопасный  путь  с учетом
будующего.
    Упражнение 6-4.
    ----------------
    Напишите программу,   которая  читает   "C"-программу   и
печатает в  алфавитном порядке каждую группу имен переменных,
которые совпадают в  первых  семи  символах,   но  отличаются
где-то дальше. (Сделайте так, чтобы 7 было параметром).
    Упражнение 6-5.
    ----------------
    Напишите программу  выдачи  перекрестных  ссылок,    т.е.
Программу, которая  печатает список всех слов документа и для
каждого из этих слов печатает список номеров строк, в которые
это слово входит.
    Упражнение 6-6.
    ----------------
    Напишите программу,   которая  печатает  слова  из своего
файла ввода,  расположенные в  порядке  убывания  частоты  их
появления. Перед      каждым  словом  напечатайте  число  его
появлений.

     
     
     

     
               6.6. Поиск в таблице.
    
    Для иллюстрации    дальнейших    аспектов   использования
структур в этом разделе мы напишем программу,  представляющую
собой содержимое   пакета  поиска  в  таблице.  Эта программа
является типичным   представителем   подпрограмм   управления
символьными таблицами     макропроцессора   или  компилятора.
Рассмотрим, например,   оператор #DEFINE  языка  "C".   Когда
встречается строка вида
 
                          #DEFINE YES    1
 
то имя  YES  и  заменяющий  текст  1  помещаются  в  таблицу.
Позднее, когда имя YES появляется в операторе вида
 
                            INWORD = YES;
 
оно должно быть замещено на 1.
    Имеются две основные процедуры, которые управляют именами
и заменяющими  их текстами.  Функция INSTALL(S,T)  записывает
имя S и заменяющий текст T в таблицу;  здесь  S  и  T  просто
символьные строки.  Функция LOOKUP(S)  ищет имя S в таблице и
возвращает либо указатель того места,  где это  имя  найдено,
либо NULL, если этого имени в таблице не оказалось.
    При этом используется поиск по  алгоритму  хеширования  -
поступающее имя    преобразуется  в  маленькое  положительное
число, которое  затем  используется  для  индексации  массива
указателей. Элемент    массива  указывает  на начало цепочных
блоков, описывающих    имена,   которые  имеют  это  значение
хеширования. Если   никакие имена при хешировании не получают
этого значения, то элементом массива будет NULL.
    Блоком цепи является структура,  содержащая указатели  на
соответствующее имя,  на заменяющий текст и на следующий блок
в цепи.  Нулевой указатель следующего блока служит  признаком
конца данной цепи.
 
           STRUCT NLIST  \(  /* BASIC TABLE ENTRY */
                CHAR *NAME;
                CHAR *DEF;
               STRUCT NLIST *NEXT; /* NEXT ENTRY IN CHAIN */
           \);
 
    Массив указателей это просто
 
      DEFINE    HASHSIZE     100
    TATIC STRUCT NLIST *HASHTAB[HASHSIZE] /* POINTER TABLE */
 
    Значение функции    хеширования,    используемой   обеими
функциями LOOKUP и INSTALL , получается просто как остаток от
деления суммы   символьных значений строки на размер массива.
(Это не самый лучший возможный алгоритм,  но его  достоинство
состоит в исключительной простоте).
 
             HASH(S)   /* FORM HASH VALUE FOR STRING */
             CHAR *S;
             \(
              INT HASHVAL;
            
              FOR (HASHVAL = 0; *S != '\0'; )
                  HASHVAL += *S++;
              RETURN(HASHVAL % HASHSIZE);
             \)
 
    В результате  процесса  хеширования  выдается   начальный
индекс в массиве HASHTAB ; если данная строка может быть где-
то найдена,  то именно в цепи блоков,  начало которой указано
там. Поиск    осуществляется  функцией  LOOKUP.  Если функция
LOOKUP находит,  что данный элемент уже присутствует,  то она
возвращает указатель   на  него; если нет,  то она возвращает
NULL.
 
         STRUCT NLIST *LOOKUP(S) /* LOOK FOR S IN HASHTAB */
         CHAR *S;
         \(
         STRUCT NLIST *NP;
         
         FOR (NP = HASHTAB[HASH(S)]; NP != NULL;NP=NP->NEXT)
             IF (STRCMP(S, NP->NAME) == 0)
           RETURN(NP);  /* FOUND IT */
         RETURN(NULL);    /* NOT FOUND */
 
 
    Функция INSTALL    использует    функцию    LOOKUP    для
определения, не  присутствует ли уже вводимое в данный момент
имя; если это так,  то  новое  определение  должно  вытеснить
старое. В     противном  случае  создается  совершенно  новый
элемент. Если  по  какой-либо  причине  для  нового  элемента
больше нет места, то функция INSTALL возвращает NULL.
 
        STRUCT NLIST *INSTALL(NAME, DEF) /* PUT (NAME, DEF) */
        CHAR *NAME, *DEF;
        \(
      STRUCT NLIST *NP, *LOOKUP();
      CHAR *STRSAVE(), *ALLOC();
      INT HASHVAL;

      IF((NP = LOOKUP(NAME)) == NULL) \( /* NOT FOUND */
      NP = (STRUCT NLIST *) ALLOC(SIZEOF(*NP));
      IF (NP == NULL)
         RETURN(NULL);
      IF ((NP->NAME = STRSAVE(NAME)) == NULL)
         RETURN(NULL);
      HASHVAL = HASH(NP->NAME);
      NP->NEXT = HASHTAB[HASHVAL];
      HASHTAB[HASHVAL] = NP;
     \) ELSE        /* ALREADY THERE */
          FREE((NP->DEF);/* FREE PREVIOUS DEFINITION */
     IF ((NP->DEF = STRSAVE(DEF)) == NULL)
          RETURN (NULL);
     RETURN(NP);
       \)
 
    Функция STRSAVE  просто  копирует  строку,   указанную  в
качестве аргумента, в место хранения, полученное в результате
обращения к функции ALLOC. Мы уже привели эту функцию в главе
5. Так как обращение к функции ALLOC и FREE могут происходить
в любом  порядке и в связи с проблемой выравнивания,  простой
вариант функции ALLOC из главы  5  нам  больше  не  подходит;
смотрите главы 7 и 8.
    Упражнение 6-7.
    ---------------
    Напишите процедуру,    которая   будет   удалять   имя  и
определение из   таблицы,   управляемой  функциями  LOOKUP  и
INSTALL.
    Упражнение 6-8.
    ---------------
    Разработайте простую,    основанную   на  функциях  этого
раздела, версию  процессора для обработки конструкций #DEFINE
, пригодную   для использования с "C"-программами.  Вам могут
также оказаться полезными функции GETCHAR и UNGETCH.

     
     
     
     
 
     
     
               6.7. Поля.
    
    Когда вопрос    экономии    памяти    становится    очень
существенным, то  может оказаться необходимым помещать в одно
машинное слово несколько различных объектов; одно из особенно
распросраненных употреблений  - набор однобитовых признаков в
применениях, подобных символьным таблицам компилятора. Внешне
обусловленные форматы данных, такие как интерфейсы аппаратных
средств также  зачастую  предполагают  возможность  получения
слова по частям.
    Представьте себе фрагмент компилятора, который работает с
символьной таблицей.    С  каждым  идентификатором  программы
связана определенная  информация,  например,  является он или
нет ключевым словом,  является ли он или  нет  внешним  и/или
статическим и т.д. Самый компактный способ закодировать такую
информацию -   поместить  набор   однобитовых   признаков   в
отдельную переменную типа CHAR или INT.
    Обычный способ,    которым   это   делается,   состоит  в
определении набора "масок", отвечающих соответствущим битовым
позициям, как в
 
                       #DEFINE   KEYWORD   01
                       #DEFINE   EXTERNAL  02
                       #DEFINE   STATIC    04
 
(числа должны быть степенями двойки).  Тогда обработка  битов
сведется к  "жонглированию битами" с помощью операций сдвига,
маскирования и дополнения, описанных нами в главе 2.
    Некоторые часто встречающиеся идиомы:
 
                   FLAGS \!= EXTERNAL  \! STATIC;
 
включает биты EXTERNAL и STATIC в FLAGS, в то время как
 
                  FLAGS &= \^(еXTERNAL \! STATIC);
 
их выключает, а
 
            IF ((FLAGS & (EXTERNAL \! STATIC)) == 0) ...
 
истинно, если оба бита выключены.
    Хотя этими идиомами легко овладеть,  язык "C" в  качестве
альтернативы предлагает   возможность определения и обработки
полей внутри   слова  непосредственно,   а   не   посредством
побитовых логических операций. Поле - это набор смежных битов
внутри одной переменной типа INT.   Синтаксис  определения  и
обработки полей     основывается  на  структурах.   Например,
символьную таблицу конструкций  #DEFINE,   приведенную  выше,
можно бы было заменить определением трех полей:
 
                        STRUCT  \(
                      UNSIGNED IS_KEYWORD : 1;
                      UNSIGNED IS_EXTERN  : 1;
                      UNSIGNED IS_STATIC  : 1;
                        \)    FLAGS;
 
    Здесь определяется переменная с  именем  FLAGS,   которая
содержит три   1-битовых поля.  Следующее за двоеточием число
задает ширину поля в битах.  Поля описаны как UNSIGNED, чтобы
подчеркнуть, что    они  действительно  будут  величинами без
знака.
    На отдельные поля можно ссылаться,  как  FLAGS.IS_STATIE,
FLAGS. IS_EXTERN,  FLAGS.IS_KEYWORD И т.д., то есть точно так
же, как  на другие члены структуры.  Поля ведут себя  подобно
небольшим целым     без   знака   и   могут   участвовать   в
арифметических выражениях точно так же,  как и другие  целые.
Таким образом,      предыдущие   примеры   более  естественно
переписать так:
 
               FLAGS.IS_EXTERN = FLAGS.IS_STATIC = 1;
 
для включения битов;
 
               FLAGS.IS_EXTERN = FLAGS.IS_STATIC = 0;
 
для выключения битов;
 
         IF (FLAGS.IS_EXTERN == 0 &&FLAGS.IS_STATIC == 0)...
 
для их проверки.
    Поле не может перекрывать  границу  INT;  если  указанная
ширина такова,      что   это   должно  случиться,   то  поле
выравнивается по границе  следующего  INT.   Полям  можно  не
присваивать имена;   неименованные  поля  (только двоеточие и
ширина) используются  для заполнения свободного места.  Чтобы
вынудить выравнивание   на  границу  следующего  INT,   можно
использовать специальную ширину 0.
    При работе с полями имеется  ряд  моментов,   на  которые
следует обратить внимание.  По-видимому наиболее существенным
является то,    что  отражая  природу  различных   аппаратных
средств, распределение       полей   на   некоторых   машинах
осуществляется слева направо,  а на некоторых справа  налево.
Это означает,    что  хотя  поля  очень  полезны для работы с
внутренне определенными структурами данных,   при  разделении
внешне определяемых   данных  следует тщательно рассматривать
вопрос о том, какой конец поступает первым.
    Другие ограничения, которые следует иметь в виду: поля не
имеют знака; они могут храниться только в переменных типа INT
(или, что  эквивалентно,  типа  UNSIGNED);  они  не  являются
массивами; они  не имеют адресов,  так что к ним не применима
операция &.

     
     
     
     
  
          
     
               6.8. Объединения.
    
    Объединения - это переменная, которая в различные моменты
времени может содержать  объекты  разных  типов  и  размеров,
причем компилятор   берет  на  себя  отслеживание  размера  и
требований выравнивания. Объединения представляют возможность
работать с   различными видами данных в одной области памяти,
не вводя в программу никакой машинно-зависимой информации.
    В качестве   примера,    снова   из   символьной  таблицы
компилятора, предположим, что константы могут быть типа INT ,
FLOAT или   быть  указателями  на  символы.   значение каждой
конкретной константы     должно   храниться   в    переменной
соотвествующего типа, но все же для управления таблицей самым
удобным было бы,  если это значение занимало бы один и тот же
объем памяти   и хранилось в том же самом месте независимо от
его типа.  это и является назначением объединения -  выделить
отдельную переменную,   в которой можно законно хранить любую
одну из переменных нескольких типов.  Как и в  случае  полей,
синтаксис основывается на структурах.
 
                           UNION U_TAG \(
                           INT IVAL;
                           FLOAT FVAL;
                           CHAR *PVAL;
                           \) UVAL;
 
    Переменная UVAL    будет    иметь    достаточно   большой
размер,чтобы хранить наибольший из трех типов,  независимо от
машины, на  которой осуществляется компиляция, - программа не
будет зависить от характеристик аппаратных средств.  Любой из
этих трех  типов может быть присвоен UVAR и затем использован
в выражениях,      пока   такое   использование   совместимо:
извлекаемый тип   должен  совпадать  с  последним  помещенным
типом. Дело программиста - следить за тем, какой тип хранится
в объединении   в  данный  момент; если что-либо хранится как
один тип,  а извлекается как  другой,   то  результаты  будут
зависеть от используемой машины.
    Синтаксически доступ к членам объединения  осуществляется
следующим образом:
 
                        имя объединения.член
                        --------------------
или
                    указатель объединения ->член
                    ----------------------------
 
то есть  точно  так  же,   как и в случае структур.  если для
отслеживания типа,    хранимого  в  данный  момент  в   UVAL,
используется переменная   UTYPE,   то  можно  встретить такой
участок программы:
 
              IF (UTYPE == INT)
              PRINTF("%D\N", UVAL.IVAL);
              ELSE IF (UTYPE == FLOAT)
              PRINTF("%F\N", UVAL.FVAL);
              ELSE IF (UTYPE == STRING)
              PRINTF("%S\N", UVAL.PVAL);
              ELSE
              PRINTF("BAD TYPE %D IN UTYPE\N", UTYPE);
 
    Объединения могут появляться внутри структур и массивов и
наоборот. Запись     для  обращения  к  члену  объединения  в
структуре (или наоборот)  совершенно идентична той,   которая
используется во   вложенных структурах.  например,  в массиве
структур, определенным следующим образом
 
                         STRUCT \(
                         CHAR *NAME;
                         INT FLAGS;
                         INT UTYPE;
                         UNION \(
                         INT IVAL;
                         FLOAT FVAL;
                         CHAR *PVAL;
                         \) UVAL;
                          \) SYMTAB[NSYM];
 
на переменную IVAL можно сослаться как
 
                         SYMTAB[I].UVAL.IVAL
 
а на первый символ строки PVAL как
 
                        *SYMTAB[I].UVAL.PVAL
 
    В сущности объединение является структурой, в которой все
члены имеют  нулевое  смещение.   Сама  структура  достаточно
велика, чтобы   хранить "самый широкий" член,  и выравнивание
пригодно для всех типов,  входящих в объединение.   Как  и  в
случае структур,      единственными  операциями,   которые  в
настоящее время можно проводить  с  объединениями,   являются
доступ к члену и извлечение адреса; объединения не могут быть
присвоены, переданы  функциям или возвращены ими.   указатели
объединений можно использовать в точно такой же манере, как и
указатели структур.
    Программа распределения  памяти,   приводимая в главе 8 ,
показывает, как можно использовать объединение, чтобы сделать
некоторую переменную     выровненной  по  определенному  виду
границы памяти.

     
     
     
     
     
                                                                                                                                                 
     
     
                   6.9. Определение типа
    
    В языке "C" предусмотрена возможность, называемая TYPEDEF
для введения новых имен для типов данных.  Например, описание
 
                         TYPEDEF INT LENGTH;
 
делает имя LENGTH синонимом для INT.  "Тип" LENGTH может быть
использован в описаниях,  переводов типов и т.д.  Точно таким
же образом, как и тип INT:
 
                        LENGTH   LEN, MAXLEN;
                        LENGTH   *LENGTHS[];
 
аналогично описанию
 
                        TYPEDEF CHAR *STRING;
 
делает STRING  синонимом для CHAR*,  то есть для указателя на
символы, что затем можно использовать в описаниях вида
 
                 STRING P, LINEPTR[LINES], ALLOC();
 
    Обратите внимание,  что объявляемый в конструкции TYPEDEF
тип появляется   в  позиции  имени переменной,  а не сразу за
словом TYPEDEF.  Синтаксически  конструкция  TYPEDEF  подобна
описаниям класса   памяти  EXTERN,  STATIC и т.  Д.  мы также
использовали прописные буквы, чтобы яснее выделить имена.
    В качестве   более   сложного   примера   мы   используем
конструкцию TYPEDEF для описания узлов дерева,  рассмотренных
ранее в этой главе:
 
          TYPEDEF STRUCT TNODE \(     /* THE BASIC NODE */
          CHAR *WORD; /* POINTS TO THE TEXT */
          INT COUNT; /* NUMBER OF OCCURRENCES */
          STRUCT TNODE *LEFT;     /* LEFT CHILD */
          STRUCT TNODE *RIGHT;    /* RIGHT CHILD */
          \) TREENODE, *TREEPTR;
 
    В результате получаем два новых ключевых слова:  TREENODE
(структура) и TREEPTR (указатель на структуру). Тогда функцию
TALLOC можно записать в виде
 
          TREEPTR TALLOC()
          \(
             CHAR *ALLOC();
             RETURN((TREEPTR) ALLOC(SIZEOF(TREENODE)));
          \)
 
    Необходимо подчеркнуть,  что описание TYPEDEF не приводит
к созданию  нового  в  каком-либо  смысле  типа;  оно  только
добавляет новое   имя для некоторого существующего типа.  при
этом не возникает и никакой новой семантики:  описанные таким
способом переменные обладают точно теми же свойствами,  что и
переменные, описанные  явным образом. По существу конструкция
TYPEDEF сходна   с  #DEFINE  за  исключением  того,   что она
интерпретируется компилятором  и  потому  может  осуществлять
подстановки текста,   которые выходят за пределы возможностей
макропроцессора языка "C". Например,
 
                       TYPEDEF INT (*PFI) ();
 
создает тип PFI для "указателя функции, возвращающей значение
типа INT",   который  затем  можно  было  бы  использовать  в
программе сортировки из главы 5 в контексте вида
 
                      PFI STRCMP, NUMCMP, SWAP;
                                          
    Имеются две основные причины применения описаний TYPEDEF.
Первая причина связана с  параметризацией  программы,   чтобы
облегчить решение   проблемы  переносимости.   Если для типов
данных, которые  могут быть машинно-зависимыми,  использовать
описание TYPEDEF,  то при переносе программы на другую машину
придется изменить только  эти  описания.   Одна  из  типичных
ситуаций состоит   в  использовании  определяемых  с  помощью
TYPEDEF имен для различных  целых  величин  и  в  последующем
подходящем выборе   типов  SHORT,   INT  и  LONG  для  каждой
имеющейся машины.
    Второе назначение  TYPEDEF  состоит  в обеспечении лучшей
документации для программы  -  тип  с  именем  TREEPTR  может
оказаться более   удобным  для восприятия,  чем тип,  который
описан только как указатель сложной структуры.
    И наконец,  всегда существует вероятность,  что в будущем
компилятор или некоторая другая программа,  такая  как  LINT,
сможет использовать     содержащуюся   в   описаниях  TYPEDEF
информацию для проведения некоторой  дополнительной  проверки
программы.

     
     
     
 
 
                  7. Ввод и вывод

    Средства ввода/вывода  не являются составной частью языка
"с", так  что мы не выделяли их в нашем предыдущем изложении.
Однако реальные программы взаимодействуют со своей окружающей
средой гораздо более сложным образом,  чем мы видели  до  сих
пор. В этой главе будет описана "стандартная библиотека ввода
/вывода", то    есть  набор   функций,    разработанных   для
обеспечения стандартной     системы   ввода/вывода  для  "с"-
программ. Эти функции предназначены для удобства программного
интерфейса, и    все же отражают только те операции,  которые
могут быть обеспечены на большинстве современных операционных
систем. Процедуры    достаточно  эффективны  для того,  чтобы
пользователи редко чувствовали необходимость обойти их  "ради
эффективности", как   бы ни была важна конкретная задача.  И,
наконец, эти  процедуры задуманы быть  "переносимыми"  в  том
смысле, что    они  должны существовать в совместимом виде на
любой системе, где имеется язык "с", и что программы, которые
ограничивают свои   взаимодействия  с системой возможностями,
предоставляемыми стандартной    библиотекой,    можно   будет
переносить с    одной  системы  на  другую  по  существу  без
изменений.
    Мы здесь  не  будем  пытаться  описать   всю   библиотеку
ввода/вывода; мы     более   заинтересованы   в  том,   чтобы
продемонстрировать сущность написания "с"-программ,   которые
взаимодействуют со своей операционной средой.










       7.1. Обращение к стандартной библиотеке

    Каждый исходный  файл,   который  обращается к функции из
стандартной библиотеки, должен вблизи начала содержать строку

                         #INCLUDE <STDIO.H>

    В файле  STDIO.H   определяются   некоторые   макросы   и
переменные, используемые         библиотекой    ввода/вывода.
Использование угловых скобок вместо обычных двойных кавычек -
указание компилятору     искать   этот  файл  в  справочнике,
содержащем заголовки стандартной информации (на системе  UNIX
обычно LUSRLINELUDE).
    Кроме того,    при  загрузке  программы  может  оказаться
необходимым указать библиотеку явно; на системе PDP-11  UNIX,
например, команда компиляции программы имела бы вид:

                   CC   исходные файлы и т.д. -LS
 
где -LS указывает на загрузку из стандартной библиотеки.

     
     
     
     
     
   
     
   
   
 
      
  7.2. Стандартный ввод и вывод - функции GETCHAR и PUTCHAR
 
    Самый простой  механизм  ввода  заключается  в  чтении по
одному символу за раз  из  "стандартного  ввода",   обычно  с
терминала пользователя,   с помощью функции GETCHAR.  Функция
GETCHAR() при  каждом к ней  обращении  возвращает  следующий
вводимый символ.    В большинстве сред,  которые поддерживают
язык "с",  терминал может быть  заменен  некоторым  файлом  с
помощью обозначения   <  :   если  некоторая  программа  PROG
использует функцию GETCHAR то командная строка
 
                             PROG<INFILE
 
приведет к тому,  что PROG будет читать из файла INFILE, а не
с терминала.  Переключение ввода делается таким образом,  что
сама программа   PROG  не  замечает  изменения;  в  частности
строка"<INFILE" не включается в командную строку аргументов в
ARGV. Переключение    ввода  оказывается  незаметным  и в том
случае, когда вывод поступает из другой программы посредством
поточного (PIPE) механизма; командная строка
 
                          OTHERPROG \! PROG
 
прогоняет две программы,  OTHERPROG и PROG, и организует так,
что стандартным   вводом  для  PROG  служит стандартный вывод
OTHERPROG.
    Функция GETCHAR  возвращает  значение  EOF,   когда   она
попадает на   конец  файла,   какой  бы  ввод она при этом не
считывала. Стандартная    библиотека  полагает  символическую
константу EOF     равной  -1  (посредством  #DEFINE  в  файле
STDIO.H), но проверки следует писать в терминах EOF, а не -1,
чтобы избежать зависимости от конкретного значения.
    Вывод можно  осуществлять  с  помощью функции PUTCHAR(C),
помещающей символ  'с'  в  "стандартный  ввод",   который  по
умолчанию является   терминалом.   Вывод  можно  направить  в
некоторый файл с помощью обозначения >:  если PROG использует
PUTCHAR, то командная строка
 
                            PROG>OUTFILE
 
приведет к записи стандартного вывода в файл OUTFILE, а не на
терминал. На   системе UNIX можно также использовать поточный
механизм. Строка
 
                         PROG \! ANOTHERPROG
 
помещает стандартный   вывод   PROG   в   стандартный    ввод
ANOTHERPROG. И   опять PROG не будет осведомлена об изменении
направления.
    Вывод, осуществляемый функцией PRINTF,  также поступает в
стандартный вывод,  и обращения  к  PUTCHAR  и  PRINTF  могут
перемежаться.
    Поразительное количество программ читает только из одного
входного потока   и  пишет  только в один выходной поток; для
таких программ  ввод  и  вывод  с  помощью  функций  GETCHAR,
PUTCHAR и   PRINTF  может  оказаться  вполне адекватным и для
начала определенно  достаточным.   Это  особенно  справедливо
тогда, когда  имеется возможность указания файлов для ввода и
вывода и поточный механизм для связи вывода одной программы с
вводом другой. Рассмотрим, например, программу LOWER, которая
преобразует прописные буквы из своего ввода в строчные:
 
              #INCLUDE <STDIO.H>
 
              MAIN() /* CONVERT INPUT TO LOWER CASE */
              \(
               INT C;
              
               WHILE ((C = GETCHAR()) != EOF)
                  PUTCHAR(ISUPPER(C) ? TOLOWER(C) : C);
              \)
 
    "Функции" ISUPPER   и  TOLOWER  на  самом  деле  являются
макросами, определенными    в  STDIO.H  .    Макрос   ISUPPER
проверяет, является    ли  его  аргумент  буквой  из верхнего
регистра, и  возвращает ненулевое значение,  если это так,  и
нуль в противном случае.  Макрос TOLOWER преобразует букву из
верхнего регистра в ту же букву нижнего регистра.  Независимо
от того, как эти функции реализованы на конкретной машине, их
внешнее поведение совершенно одинаково,  так что использующие
их программы избавлены от знания символьного набора.
    Если требуется  преобразовать несколько файлов,  то можно
собрать эти файлы с помощью программы,  подобной утилите  CAT
системы UNIX,
 
                 CAT FILE1 FILE2 ... \! LOWER>OUTPUT
 
и избежать тем самым вопроса о том,  как  обратиться  к  этим
файлам из  программы.  (Программа CAT приводится позже в этой
главе).
    Кроме того  отметим,   что   в   стандартной   библиотеке
ввода/вывода "функции"  GETCHAR и PUTCHAR на самом деле могут
быть макросами.  Это позволяет избежать накладных расходов на
обращение к функции для обработки каждого символа.  В главе 8
мы продемонстрируем, как это делается.

     
     
     
     
     
 
      
          7.3. Форматный вывод - функция PRINTF
 
    Две функции:   PRINTF  для  вывода  и  SCANF  для   ввода
(следующий раздел)      позволяют  преобразовывать  численные
величины в символьное представлEние  и  обратно.   Они  также
позволяют генерировать   и интерпретировать форматные строки.
Мы уже всюду в  предыдущих  главах  неформально  использовали
функцию PRINTF;   здесь  приводится  более  полное  и  точное
описание. Функция
 
                  PRINTF(CONTROL, ARG1, ARG2, ...)
 
преобразует, определяет  формат  и  печатает свои аргументы в
стандартный вывод под управлением строки CONTROL. Управляющая
строка содержит два типа объектов:  обычные символы,  которые
просто копируются   в   выходной   поток,    и   спецификации
преобразований, каждая   из которых вызывает преобразование и
печать очередного аргумента PRINTF.
    Каждая спецификация преобразования начинается с символа %
и заканчивается  символом преобразования.  Между % и символом
преобразования могут находиться:
 - знак минус, который указывает о выравнивании преобразован-
   ного аргумента по левому краю его поля.
 - Строка цифр, задающая минимальную ширину поля. Преобразо-
   ванное число будет напечатано в поле по крайней мере этой
   ширины, а если необходимо, то и в более широком. Если пре-
   образованный аргумент имеет меньше символов, чем указанная
   ширина поля, то он будет дополнен слева (или справа, если
   было указано выравнивание по левому краю)заполняющими сим-
   волами до этой ширины. Заполняющим символом обычно являет-
   ся пробел, а если ширина поля указывается с лидирующим ну-
   лем, то этим символом будет нуль (лидирующий нуль в данном
   случае не означает восьмеричной ширины поля).
 - Точка, которая отделяет ширину поля от следующей строки
   цифр.
 - Строка цифр (точность), которая указывает максимальное
   число символов строки, которые должны быть напечатаны, или
   число печатаемых справа от десятичной точки цифр для пере-
   менных типа FLOAT или DOUBLE.
 - Модификатор длины L, который указывает, что соответствую-
   щий элемент данных имеет тип LONG, а не INT.
    Ниже приводятся символы преобразования и их смысл:
 
 D - аргумент преобразуется к десятичному виду.
 O - Аргумент преобразуется в беззнаковую восьмеричную форму
   (без лидирующего нуля).
 X - Аргумент преобразуется в беззнаковую шестнадцатеричную
   форму (без лидирующих 0X).
 U - Аргумент преобразуется в беззнаковую десятичную форму.
 C - Аргумент рассматривается как отдельный символ.
 S - Аргумент является строкой: символы строки печатаются до
   тех пор, пока не будет достигнут нулевой символ или не бу-
   дет напечатано количество символов, указанное в специфика-
   ции точности.
 E - Аргумент, рассматриваемый как переменная типа FLOAT или
   DOUBLE, преобразуется в десятичную форму в виде
   [-]M.NNNNNNE[+-]XX, где длина строки из N определяется
   указанной точностью. Точность по умолчанию равна 6.
 F - Аргумент, рассматриваемый как переменная типа FLOAT или
   DOUBLE, преобразуется в десятичную форму в виде
   [-]MMM.NNNNN, где длина строки из N определяется указанной
   точностью. Точность по умолчанию равна 6. отметим, что эта
   точность не определяет количество печатаемых в формате F
   значащих цифр.
 G - Используется или формат %E или %F, какой короче; незна-
   чащие нули не печатаются.
    Если идущий   за   %   символ   не   является    символом
преобразования, то печатается сам этот символ; следовательно,
символ % можно напечатать, указав %%.
    Большинство из  форматных  преобразований очевидно и было
проиллюстрировано в     предыдущих   главах.     Единственным
исключением является   то,   как  точность взаимодействует со
строками. Следующая  таблица  демонстрирует  влияние  задания
различных спецификаций     на   печать  "HELLO,   WORLD"  (12
символов). Мы  поместили двоеточия вокруг  каждого  поля  для
того, чтобы вы могли видеть его протяженность.
 
                :%10S:          :HELLO, WORLD:
                :%10-S:         :HELLO, WORLD:
                :%20S:          :    HELLO, WORLD:
                :%-20S:         :HELLO, WORLD      :

    Предостережение: PRINTF  использует  свой первый аргумент
для определения числа последующих аргументов и их типов. Если
количество аргументов   окажется  недостаточным или они будут
иметь несоответственные типы,  то  возникнет  путаница  и  вы
получите бессмысленные результаты.
    Упражнение 7-1.
    --------------
    Напишите программу,    которая  будет  печатать  разумным
образом произвольный ввод.  Как минимум она  должна  печатать
неграфические символы   в  восьмеричном или шестнадцатеричном
виде (в соответствии с принятыми у вас обычаями) и складывать
длинные строки.

     
     
     
     
     
     
 
      
         7.4. Форматный ввод - функция SCANF
    
    Осуществляющая ввод  функция  SCANF   является   аналогом
PRINTF и позволяет проводить в обратном направлении многие из
тех же самых преобразований. Функция
 
                   SCANF(CONTROL, ARG1, ARG2, ...)
 
читает символы из стандартного ввода,   интерпретирует  их  в
соответствии с   форматом,  указанном в аргументе CONTROL,  и
помещает результаты   в  остальные  аргументы.    Управляющий
аргумент описывается   ниже;  другие  аргументы,   каждый  из
которых должен быть указателем,   определяют,   куда  следует
поместить соответствующим образом преобразованный ввод.
    Управляющая строка     обычно    содержит    спецификации
преобразования, которые   используются  для  непосредственной
интерпретации входных последовательностей. Управляющая строка
может содержать:
 - пробелы, табуляции или символы новой строки ("символы пус-
   тых промежутков"), которые игнорируются.
 - Обычные символы (не %), которые предполагаются совпадающи-
   ми со следующими отличными от символов пустых промежутков
   символами входного потока.
 - Спецификации преобразования, состоящие из символа %, нео-
   бязательного символа подавления присваивания *, необяза-
   тельного числа, задающего максимальную ширину поля и сим-
   вола преобразования.
    Спецификация преобразования   управляет   преобразованием
следующего поля  ввода.   Нормально  результат  помещается  в
переменную, которая   указывается соответствующим аргументом.
Если, однако  ,   с  помощью  символа  *  указано  подавление
присваивания, то    это  поле  ввода  просто  пропускается  и
никакого присваивания     не   производится.    Поле    ввода
определяется как строка символов, которые отличны от символов
простых промежутков;  оно  продолжается  либо  до  следующего
символа пустого   промежутка,   либо  пока не будет исчерпана
ширина поля, если она указана. Отсюда следует, что при поиске
нужного ей   ввода,   функция  SCANF будет пересекать границы
строк, поскольку  символ новой строки входит в  число  пустых
промежутков.
    Символ преобразования   определяет   интерпретацию   поля
ввода; согласно  требованиям основанной на вызове по значению
семантики языка  "С"  соответствующий  аргумент  должен  быть
указателем. Допускаются следующие символы преобразования:
 D - на вводе ожидается десятичное целое; соответствующий ар-
    гумент должен быть указателем на целое.
 O - На вводе ожидается восьмеричное целое (с лидирующим ну-
    лем или без него); соответствующий аргумент должен быть
    указателем на целое.
 X - На вводе ожидается шестнадцатеричное целое (с лидирующи-
    ми 0X или без них); соответствующий аргумент должен быть
    указателем на целое.
 H - На вводе ожидается целое типа SHORT; соответсвующий ар-
    гумент должен быть указателем на целое типа SHORT.
 C - Ожидается  отдельный  символ;  соответствующий  аргумент
    должен быть   указателем  на  символы; следующий вводимый
    символ помещается в  указанное  место.   Обычный  пропуск
    символов пустых   промежутков  в этом случае подавляется;
    для чтения   следующего  символа,   который  не  является
    символом пустого   промежутка,  пользуйтесь спецификацией
    преобразования %1S.
 S - Ожидается символьная строка; соответствующий аргумент
    должен быть указателем символов, который указывает на
    массив символов, который достаточно велик для принятия
    строки и добавляемого в конце символа \0.
 F - Ожидается число с плавающей точкой; соответствующий ар-
    гумент должен быть указателем на переменную типа FLOAT.
 Е - символ преобразования E является синонимом для F. Формат
    ввода переменной типа FLOAT включает необязательный знак,
    строку цифр, возможно содержащую десятичную точку и нео-
    бязательное поле экспоненты, состоящее из буквы E, за ко-
    торой следует целое, возможно имеющее знак.
    Перед символами  преобразования D,  O и X может стоять L,
которая означает ,  что в списке аргументов должен находиться
указатель на переменную типа LONG, а не типа INT. Аналогично,
буква L может стоять перед символами преобразования E или  F,
говоря о   том,   что  в  списке аргументов должен находиться
указатель на переменную типа DOUBLE, а не типа FLOAT.
    Например, обращение
                  INT I;
                  FLOAT X;
                  CHAR NAME[50];
                  SCANF("%D %F %S", &I, &X, NAME);
 
со строкой на вводе
 
                       25  54.32E-1   THOMPSON
 
приводит к  присваиванию  I  значения 25,X - значения 5.432 и
NAME - строки  "THOMPSON",   надлежащим  образом  законченной
символом \0   .  Эти три поля ввода можно разделить столькими
пробелами, табуляциями  и символами новых строк,  сколько  вы
пожелаете. Обращение
 
               INT  I;
               FLOAT X;
               CHAR NAME[50];
               SCANF("%2D %F %*D %2S", &I, &X, NAME);
 
с вводом
 
                          56789 0123 45A72
 
присвоит I значение 56,  X - 789.0, пропустит 0123 и поместит
в NAME строку "45". при следующем обращении к любой процедуре
ввода рассмотрение  начнется с буквы A.  В этих двух примерах
NAME является указателем и, следовательно, перед ним не нужно
помещать знак &.
    В качестве  другого примера перепишем теперь элементарный
калькулятор из главы 4,  используя для  преобразования  ввода
функцию SCANF:
 
             #INCLUDE  <STDIO.H>
             MAIN()    /* RUDIMENTARY DESK CALCULATOR */
             \(
             DOUBLE SUM, V;
             SUM =0;
             WHILE (SCANF("%LF", &V) !=EOF)
                  PRINTF("\T%.2F\N", SUM += V);
             \)
 
выполнение функции SCANF заканчивается либо тогда,  когда она
исчерпывает свою управляющую строку,   либо  когда  некоторый
элемент ввода   не  совпадает с управляющей спецификацией.  В
качестве своего   значения  она  возвращает  число  правильно
совпадающих и   присвоенных элементов ввода.  Это число может
быть использовано   для  определения   количества   найденных
элементов ввода.  при выходе на конец файла возвращается EOF;
подчеркнем, что  это значение отлично от  0,   что  следующий
вводимый символ    не  удовлетворяет  первой  спецификации  в
управляющей строке.  При следующем обращении  к  SCANF  поиск
возобновляется непосредственно     за   последним   введенным
символом.
    Заключительное предостережение:   аргументы функции SCANF
должны быть указателями. Несомненно наиболее распространенная
ошибка состоит в написании
 
                           SCANF("%D", N);
 
вместо
 
                          SCANF("%D", &N);

     
     
     
     
   
 появления этих слов  в  заключенных  в
кавычки строках.

     
     
     
     
     
   
     
     
        7.5. Форматное преобразование в памяти
 
    От функции  SCANF  и  PRINTF  происходят функции SSCANF и
SPRINTF, которые  осуществляют аналогичные преобразования, но
оперируют со   строкой,   а  не  с  файлом.  Обращения к этим
функциям имеют вид:
 
              SPRINTF(STRING, CONTROL, ARG1, ARG2, ...)
              SSCANF(STRING, CONTROL, ARG1, ARG2, ...)
 
    Как и раньше , функция SPRINTF преобразует свои аргументы
ARG1, ARG2    и т.д.  В соответствии с форматом,  указанным в
CONTROL, но  помещает результаты в STRING, а не в стандартный
вывод. KОнечно,  строка STRING должна быть достаточно велика,
чтобы принять результат. Например, если NAME - это символьный
массив, а N - целое, то
 
                     SPRINTF(NAME, "TEMP%D", N);
 
создает в NAME строку вида TEMPNNN, где NNN - значение N.
    Функция SSCANF  выполняет  обратные  преобразования - она
просматривает строку  STRING  в  соответствии  с  форматом  в
аргументе CONTROL    и  помещает  результирующие  значения  в
аргументы ARG1,    ARG2  и  т.д.эти  аргументы  должны   быть
указателями. В результате обращения
 
                    SSCANF(NAME, "TEMP%D", &N);
 
переменная N получает значение строки цифр, следующих за TEMP
    в NAME.
     
    Упражнение  7-2.
    --------------
Перепишите настольный калькулятор из главы 4, используя
для ввода и преобразования чисел SCANF и/или SSCANF.

     
     
     
     
     
     
   
                                                        
     
     
              7.6. Доступ к файлам
    
    Все до   сих   пор   написанные   программы   читали   из
стандартного ввода и писали в стандартный вывод, относительно
которых мы   предполагали,   что   они   магическим   образом
предоставлены программе местной операционной системой.
    Следующим шагом в вопросе ввода-вывода является написание
программы, работающей  с файлом,  который не связан заранее с
программой. одной  из программ,  которая  явно  демонстрирует
потребность в    таких  операциях,   является  CAT,   которая
объединяет набор   из   нескольких   именованных   файлов   в
стандартный вывод.    Программа  CAT  используется для вывода
файлов на терминал и в качестве универсального сборщика ввода
для программ,    которые  не  имеют  возможности обращаться к
файлам по имени. Например, команда
 
                             CAT X.C.Y.C
 
печатает содержимое файлов X.C и Y.C в стандартный вывод.
    Вопрос состоит  в  том,   как  организовать   чтение   из
именованных файлов, т.е., как связать внешние имена, которыми
мыслит пользователь,      с   фактически   читающими   данные
операторами.
    Эти правила   просты.   Прежде  чем  можно  считывать  из
некоторого файла или записывать в него, этот файл должен быть
открыт с   помощью  функции  FOPEN из стандартной библиотеки.
функция FOPEN берет  внешнее  имя  (подобное  X.C  или  Y.C),
проводит некоторые   обслуживающие  действия  и  переговоры с
операционной системой (детали которых не должны нас касаться)
и возвращает   внутреннее имя,  которое должно использоваться
при последующих чтениях из файла или записях в него.
    Это внутреннее  имя,   называемое   "указателем   файла",
фактически является   указателем структуры,  которая содержит
информацию о  файле,   такую  как  место  размещения  буфера,
текущая позиция   символа  в буфере,  происходит ли чтение из
файла или запись в него и  тому  подобное.   Пользователи  не
обязаны знать   эти детали,  потому что среди определений для
стандартного ввода-вывода,    получаемых  из  файла  STDIO.H,
содержится определение структуры с именем FILE.  Единственное
необходимое для   указателя  файла  описание  демонстрируется
примером:
     
                         FILE *FOPEN(), *FP;
 
    Здесь говорится,   что  FP  является указателем на FILE и
FOPEN возвращает указатель на FILE.  Oбратите внимание,   что
FILE является   именем  типа,   подобным  INT,   а  не ярлыку
структуры; это реализовано как TYPEDEF.   (Подробности  того,
как все это работает на системе UNIX, приведены в главе 8).
    Фактическое обращение к функции FOPEN в  программе  имеет
    вид:
    
                        FP=FOPEN(NAME,MODE);
 
    Первым аргументом функции  FOPEN  является  "имя"  файла,
которое задается   в виде символьной строки.  Второй аргумент
MODE ("режим")  также является символьной  строкой,   которая
указывает, как   этот файл будет использоваться.  Допустимыми
режимами являются:  чтение ("R"),  запись ("W")  и добавление
("A").
    Если вы  откроете  файл,   который еще не сущетвует,  для
записи или добавления,  то такой файл будет создан (если  это
возможно). Открытие  существующего файла на запись приводит к
отбрасыванию его   старого   содержимого.    Попытка   чтения
несуществующего файла   является  ощибкой.  Ошибки могут быть
обусловлены и другими причинами (например, попыткой чтения из
файла, не    имея  на то разрешения).  При наличии какой-либо
ошибки функция возвращает  нулевое  значение  указателя  NULL
(которое для удобства также определяется в файле STDIO.H).
    Другой необходимой   вещью  является  способ  чтения  или
записи, если   файл  уже  открыт.   Здесь  имеется  несколько
возможностей, из        которых    GETC   и   PUTC   являются
простейшими.функция GETC   возвращает  следующий  символ   из
файла; ей необходим указатель файла,  чтобы знать,  из какого
файла читать. Таким образом,
 
                             C=GETC(FP)
 
помещает в   "C"   следующий  символ  из  файла,   указанного
посредством FP, и EOF, если достигнут конец файла.
    Функция PUTC, являющаяся обращением к функции GETC,
     
                             PUTC(C,FP)
 
помещает символ  "C"  в  файл  FP  и возвращает "C".  Подобно
функциям GETCHAR и PUTCHAR, GETC и PUTC могут быть макросами,
а не функциями.
    При запуске   программы   автоматически  открываются  три
файла, которые  снабжены  определенными  указателями  файлов.
Этими файлами являются стандартный ввод,  стандартный вывод и
стандартный вывод ошибок;  соответствующие  указатели  файлов
называются STDIN,  STDOUT и STDERR.  Обычно все эти указатели
связаны с   терминалом,   но  STDIN  и  STDOUT   могут   быть
перенаправлены на файлы или в поток (PIPE), как описывалось в
разделе 7.2.
    Функции GETCHAR  и  PUTCHAR  могут  быть   определены   в
терминалах GETC, PUTC, STDIN и STDOUT следующим образом:
    
  #DEFINE GETCHAR() GETC(STDIN)
  #DEFINE PUTCHAR(C)  PUTC(C,STDOUT)
    
    При работе с файлами для форматного ввода и вывода  можно
использовать функции FSCANF и FPRINTF. Они идентичны функциям
SCANF и PRINTF,  за исключением того,  что первым  аргументом
является указатель   файла,   определяющий тот файл,  который
будет читаться или куда  будет  вестись  запись;  управляющая
строка будет вторым аргументом.
    Покончив с  предварительными  замечаниями,   мы  теперь в
состоянии написать программу  CAT  для  конкатенации  файлов.
Используемая здесь   основная  схема  оказывается  удобной во
многих программах: если имеются аргументы в командной строке,
то они  обрабатываются последовательно.  Если такие аргументы
отсутствуют, то    обрабатывается  стандартный   ввод.    Это
позволяет использовать   программу как самостоятельно,  так и
как часть большей задачи.
 
 #INCLUDE <STDIO.H>
 MAIN(ARGC, ARGV)   /*CAT: CONCATENATE FILES*/
   INT ARGC;
   CHAR *ARGV[];
 \(
   FILE *FP, *FOPEN();
   IF(ARGC==1) /*NO ARGS; COPY STANDARD INPUT*/
     FILECOPY(STDIN);
   ELSE
     WHILE (--ARGC > 0)
       IF ((FP=FOPEN(*++ARGV,"R"))==NULL) \(
         PRINTF("CAT:CAN'T OPEN %\N",*ARGV);
         BREAK;
       \) ELSE \(
         FILECOPY(FP);
         FCLOSE(FP);
       \)
 \)
 FILECOPY(FP)  /*COPY FILE FP TO STANDARD OUTPUT*/
   FILE *FP;
 \(
   INT C;
   WHILE ((C=GETC(FP)) !=EOF)
   PUTC(C, STDOUT);
 \)
 
    Указатели файлов  STDIN  и  STDOUT  заранее  определены в
библиотеке ввода-вывода как стандартный  ввод  и  стандартный
вывод; они  могут быть использованы в любом месте,  где можно
использовать объект     типа   FILE*.они   однако    являются
константами, а    не  переменными,   так  что не пытайтесь им
что-либо присваивать.
    Функция FCLOSE является обратной по  отношению  к  FOPEN;
она разрывает  связь между указателем файла и внешним именем,
установленную функцией FOPEN,  и высвобождает указатель файла
для другого    файла.большинство  операционных  систем  имеют
некоторые ограничения на число одновременно открытых  файлов,
которыми может  распоряжаться программа.  Поэтому,  то как мы
поступили в CAT,  освободив  не  нужные  нам  более  объекты,
является хорошей    идеей.   Имеется  и  другая  причина  для
применения функции FCLOSE к выходному файлу  -  она  вызывает
выдачу информации  из буфера,  в котором PUTC собирает вывод.
(При нормальном завершении работы  программы  функция  FCLOSE
вызывается автоматически для каждого открытого файла).
   
     
     
     
     

     
           7.7. Обработка ошибок - STDERR и EXIT
    
    Обработка ошибок в CAT неидеальна. Неудобство заключается
в том,    что  если  один  из  файлов  по  некоторой  причине
оказывается недоступным,  диагностическое сообщение  об  этом
печатается в конце объединенного вывода.  Это приемлемо, если
вывод поступает на терминал,   но  не  годится,   если  вывод
поступает в   некоторый  файл  или  через поточный (PIPELINE)
механизм в другую программу.
    Чтобы лучше обрабатывать  такую  ситуацию,   к  программе
точно таким  же образом,  как STDIN и STDOUT,  присоединяется
второй выходной файл,  называемый STDERR.   Если  это  вообще
возможно, вывод,    записанный в файле STDERR,  появляется на
терминале пользователя,     даже   если   стандартный   вывод
направляется в другое место.
    Давайте переделаем  программу  CAT  таким образом,  чтобы
сообщения об ошибках писались в стандартный файл ошибок.
 
 #INCLUDE  <STDIO.H>
 MAIN(ARGC,ARGV)  /*CAT: CONCATENATE FILES*/
   INT ARGC;
   CHAR *ARGV[];
 \(
   FILE *FP, *FOPEN();
   IF(ARGC==1)  /*NO ARGS; COPY STANDARD INPUT*/
     FILECOPY(STDIN);
   ELSE
     WHILE (--ARGC > 0)
       IF((FP=FOPEN(*++ARGV,"R#))==NULL) \(
         PRINTF(STDERR,
           "CAT: CAN'T OPEN,%S\N", ARGV);
         EXIT(1);
       \) ELSE \(
         FILECOPY(FP);
       \)
     EXIT(0);
 \)
 
    Программа сообщает   об    ошибках    двумя    способами.
Диагностическое сообщение,     выдаваемое  функцией  FPRINTF,
поступает в STDERR и, таким образом, оказывается на терминале
пользователя, а    не  исчезает  в  потоке  (PIPELINE)  или в
выходном файле.
    Программа также использует функцию  EXIT  из  стандартной
библиотеки, обращение      к   которой   вызывает  завершение
выполнения программы.  Аргумент функции EXIT  доступен  любой
программе, обращающейся   к данной функции,  так что успешное
или неудачное   завершение  данной   программы   может   быть
проверено другой   программой,   использующей  эту в качестве
подзадачи. По  соглашению величина 0 в качетсве возвращаемого
значения свидетельствует   о  том,   что  все  в  порядке,  а
различные ненулевые значения являются  признаками  нормальных
ситуаций.
    Функция EXIT  вызывает   функцию   FCLOSE   для   каждого
открытого выходного файла, с тем чтобы вывести всю помещенную
в буферы выходную информацию, а затем вызывает функцию _EXIT.
Функция _EXIT  приводит к немедленному завершению без очистки
каких-либо буферов; конечно, при желании к этой функции можно
обратиться непосредственно.

     
     
     
     
   
  набором
необязательных аргументов.  (предметный указатель этой  книги
сортировался с помощью аргументов -DF для категории указателя
и с -N для номеров страниц).
     
     
     
     
        
     
     
              7.8. Ввод и вывод строк
    
    Стандартная библиотека содержит функцию FGETS, совершенно
аналогичную функции GETLINE,  которую мы использовали на всем
протяжении книги. В результате обращения
 
                      FGETS(LINE, MAXLINE, FP)
 
следующая строка  ввода   (включая   символ   новой   строки)
считывается из   файла  FP  в  символьный  массив LINE; самое
большое MAXLINE_1   символ  будет  прочитан.   Результирующая
строка заканчивается   символом \ 0.  Нормально функция FGETS
возвращает LINE; в конце файла она  возвращает  NULL.   (Наша
функция GETLINE   возвращает  длину  строки,  а при выходе на
конец файла - нуль).
    Предназначенная для  вывода  функция   FPUTS   записывает
строку (которая  не обязана содержать символ новой строки)  в
файл:
 
                           FPUTS(LINE, FP)
 
    Чтобы показать,   что  в  функциях типа FGETS и FPUTS нет
ничего таинственного,  мы приводим их  ниже,   скопированными
непосредственно из стандартной библиотеки ввода-вывода:
 
 #INCLUDE  <STDIO.H>
 CHAR *FGETS(S,N,IOP) /*GET AT MOST N CHARS FROM IOP*/
 CHAR *S;
 INT N;
 REGISTER FILE *IOP;
 \(
   REGISTER INT C;
   REGISTER CHAR *CS;
   CS = S;
   WHILE(--N>0&&(C=GETC(IOP)) !=EOF)
     IF ((*CS++ = C)=='\N')
       BREAK;
   *CS = '\0';
   RETURN((C==EOF && CS==S) 7 NULL : S);
 \)
 FPUTS(S,IOP) /*PUT STRING S ON FILS IOP*/
   REGISTER CHAR *S;
   REGISTER FILE *IOP;
 \(
   REGISTER INT C;
   WHILE (C = *S++)
   PUTC(C,IOP);
 \)
 
    Упражнение 7-3.
    ---------------
    Напишите программу  сравнения двух файлов,  которая будет
печатать первую   строку  и   позицию   символа,    где   они
различаются.
    Упражнение 7-4.
    ---------------
    Переделайте программу поиска заданной комбинации символов
из главы   5  таким  образом,    чтобы   в   качестве   ввода
использовался набор   именованных  файлов  или,  если никакие
файлы не указаны как аргументы,  стандартный ввод. Следует ли
печатать имя файла при нахождении подходящей строки?
    Упражнение 7-5.
    --------------
    Напишите программу печати набора файлов, которая начинает
каждый новый   файл  с  новой страницы и печатает для каждого
файла заголовок и счетчик текущих страниц.
   
     
     
     
     
     
     
     
   
  определенному  виду
границы памяти.

     
     
     
     
     
                                                                                                                                                 
     
     
           7.9. Несколько разнообразных функций
    
    Стандартная библиотека      предоставляет       множество
разнообразных функций,    некоторые  из  которых  оказываются
особенно полезными.  Мы уже упоминали функции для  работы  со
строками: STRLEN,    STRCPY,  STRCAT и STRCMP.  Вот некоторые
другие.
 
        7.9.1. Проверка вида символов и преобразования
    
    Некоторые макросы    выполняют    проверку   символов   и
преобразования:

  ISALPHA(C)  не 0, если "C" алфавитный символ, 0 - если нет.
  ISUPPER(C)  Не 0, если "C" буква верхнего регистра,
              0 - если нет.
  ISLOWER(C)  Не 0, если "C" буква нижнего регистра, 0 -
              если нет.
  ISDIGIT(C)  Не 0,  если "C" цифра, 0 - если нет.
  ISSPACL(C)  Не  0,  если "C" пробел, табуляция  или  новая
              строка, 0 - если нет.
  TOUPPER(C)  Преобразует "C" в букву верхнего регистра.
  TOLOWER(C)  Преобразует "C" в букву нижнего регистра.
 
                  7.9.2. Функция UNGETC
    
    Стандартная библиотека  содержит  довольно   ограниченную
версию функции   UNGETCH,   написанной  нами  в  главе 4; она
называется UNGETC. В результате обращения
 
                            UNGETC(C,FP)
 
символ "C" возвращается в файл FP.  Позволяется возвращать  в
каждый файл   только  один символ.  Функция UNGETC может быть
использована в любой из функций  ввода  и  с  макросами  типа
SCANF, GETC или GETCHAR.
 
                7.9.3. Обращение к системе
    
    Функция SYSTEM(S)   выполняет  команду,   содержащуюся  в
символьной строке S,  и затем возобновляет выполнение текущей
программы. Содержимое    S  сильно  зависит  от  используемой
операционной системы.     В  качестве  тривиального  примера,
укажем, что на системе UNIX строка
 
                           SYSTEM("DATE");
 
приводит к выполнению программы DATE, которая печатает дату и
время дня.

              7.9.4. Управление памятью
    
    Функция CALLOC   весьма   сходна   с   функцией    ALLOC,
использованной нами    в  предыдущих  главах.   В  результате
обращения
 
                      CALLOC(N, SIZEOF(OBJECT))
 
возвращается либо указатель пространства,   достаточного  для
размещения N   объектов указанного размера,  либо NULL,  если
запрос не   может  быть   удволетворен.    Отводимая   память
инициализируется нулевыми значениями.
    Указатель обладает  нужным  для  рассматриваемых объектов
выравниванием, но  ему  следует  приписывать  соответствующий
тип, как в
 
                  CHAR *CALLOC();
                  INT *IP;
                  IP=(INT*) CALLOC(N,SIZEOF(INT));
 
    Функция CFREE(P)  освобождает пространство,   на  которое
указывает "P",  причем указатель "P" певоначально должен быть
получен в результате обращения к CALLOC.  Здесь  нет  никаких
ограничений на   порядок освобождения пространства,  но будет
неприятнейшей ошибкой освободить  что-нибудь,   что  не  было
получено обращением к CALLOC.
    Реализация программы   распределения   памяти,   подобной
CALLOC, в  которой размещенные блоки  могут  освобождаться  в
произвольном порядке, продемонстрирована в главе 8.
 




спользовать     содержащуюся   в   описаниях  TYPEDEF
информацию для проведения некоторой  дополнительной  проверки
программы.

    



             8. Интерфейс системы UNIX

    Материал этой   главы   относится   к   интерфейсу  между
с-программами и   операционной  системой   UNIX.    Так   как
большинство пользователей языка "C" работают на системе UNIX,
эта глава окажется полезной для большинства читателей.   даже
если вы  используете с-компилятор на другой машине,  изучение
приводимых здесь примеров должно помочь вам глубже проникнуть
в методы программирования на языке "C".
    Эта глава  делится  на  три  основные части:  ввод/вывод,
система файлов и  распределение  памяти.   Первые  две  части
предполагают небольшое знакомство с внешними характеристиками
системы UNIX.
    В главе 7 мы имели дело с системным интерфейсом,  который
одинаков для   всего  многообразия  операционных  систем.  На
каждой конкретной   системе  функции  стандартной  библиотеки
должны быть   написаны в терминах ввода-вывода,  доступных на
данной машине.  В следующих  нескольких  разделах  мы  опишем
основную систему   связанных  с  вводом и выводом точек входа
операционной системы UNIX и проиллюстрируем, как с их помощью
могут быть      реализованы   различные   части   стандартной
библиотеки.









            8.1. Дескрипторы файлов

    В операционной   системе   UNIX   весь   ввод   и   вывод
осуществляется посредством   чтения  файлов  или  их  записи,
потому что все периферийные устройства, включая даже терминал
пользователя, являются файлами определенной файловой системы.
Это означает,  что один однородный интерфейс управляет  всеми
связями между программой и периферийными устройствами.
    В наиболее  общем  случае  перед  чтением  из  файла  или
записью в файл необходимо сообщить системе о вашем намерении;
этот процесс     называется   "открытием"   файла.    Система
выясняет,имеете ли   вы   право   поступать   таким   образом
(существует ли   этот  файл?   имеется ли у вас разрешение на
обращение к нему?),  и если  все  в  порядке,   возвращает  в
программу небольшое   положительное  целое число,  называемое
дескриптором файла.  всякий раз, когда этот файл используется
для ввода  или вывода,  для идентификации файла употребляется
дескриптор файла,  а не его имя.  (Здесь существует примерная
аналогия с   использованием  READ (5,...)  и WRITE (6,...)  в
фортране). Вся  информация об  открытом  файле  содержится  в
системе; программа   пользователя  обращается  к файлу только
через дескриптор файла.
    Для удобства выполнения обычных операций ввода и вывода с
помощью терминала     пользователя   существуют   специальные
соглашения. Когда   интерпретатор команд ("SHELL")  прогоняет
программу, он  открывает три файла,   называемые  стандартным
вводом, стандартным    выводом  и стандартным выводом ошибок,
которые имеют соответственно числа  0,   1  и  2  в  качестве
дескрипторов этих   файлов.   В  нормальном состоянии все они
связаны с  терминалом,   так  что  если  программа  читает  с
дескриптором файла 0 и пишет с дескрипторами файлов 1 и 2, то
она может осуществлять ввод и вывод с помощью терминала,   не
заботясь об открытии соответствующих файлов.
    Пользователь программы  может перенаправлять ввод и вывод
на файлы,  используя операции командного интерпретатора SHELL
"<" и ">" :
 
                        PROG <INFILE>OUTFILE
 
    В этом  случае   интерпретатор   команд   SHELL   изменит
присваивание по   умолчанию  дескрипторов  файлов  0  и  1  с
терминала на указанные файлы.  Нормально дескриптор  файла  2
остается связанным с терминалом, так что сообщения об ошибках
могут поступать туда. Подобные замечания справедливы и тогда,
когда ввод и вывод связан с каналом. Следует отметить, что во
всех случаях прикрепления файлов  изменяются  интерпретатором
SHELL, а  не программой.  Сама программа, пока она использует
файл 0 для ввода и файлы 1 и 2 для вывода, не знает ни откуда
приходит ее ввод, ни куда поступает ее выдача.
  
     
     
     
     
  
   
   
   
 рограммы имела бы вид: = D.YEAR % 4 == 0 && D.YEAR % 100 != 0
             \!\! D.YEAR % 400 == 0;
     
     
     
   8.2. Низкоуровневый ввод/вывод - операторы READ и WRITE.
    
    Самый низкий  уровень  ввода/вывода  в  системе  UNIX  не
предусматривает ни   какой-либо  буферизации,  ни какого-либо
другого сервиса; он  по  существу  является  непосредственным
входом в     операционную   систему.    Весь   ввод  и  вывод
осуществляется двумя   функциями:   READ  и  WRITE.    Первым
аргументом обеих   функций является дескриптор файла.  Вторым
аргументом является буфер в вашей программе,  откуда или куда
должны поступать    данные.   Третий  аргумент  -  это  число
подлежащих пересылке байтов.  Обращения к этим функциям имеют
вид:
 
                     N_READ=READ(FD,BUF,N);
                     N_WRITTEN=WRITE(FD,BUF,N);
 
    При каждом   обращении   возвращается   счетчик   байтов,
указывающий фактическое  число переданных байтов.  При чтении
возвращенное число   байтов  может  оказаться  меньше,    чем
запрошенное число. Возвращенное нулевое число байтов означает
конец файла,  а "-1" указывает на наличие какой-либо  ошибки.
При записи   возвращенное  значение  равно  числу  фактически
записанных байтов; несовпадение этого числа с числом  байтов,
которое предполагалось   записать,  обычно свидетельствует об
ошибке.
    Количество байтов,   подлежащих чтению или записи,  может
быть совершенно произвольным.  Двумя самыми распространенными
величинами являются   "1",   которая означает передачу одного
символа за обращение (т.е.   Без  использования  буфера),   и
"512", которая    соответствует  физическому размеру блока на
многих периферийных устройствах.  Этот последний размер будет
наиболее эффективным,    но  даже  ввод  или  вывод по одному
символу за обращение не будет необыкновенно дорогим.
    Объединив все эти факты,  мы написали  простую  программу
для копирования   ввода  на  вывод,   эквивалентную программе
копировки файлов,  написанной в главе 1.  На системе UNIX эта
программа будет копировать что угодно куда угодно, потому что
ввод и вывод могут быть  перенаправлены  на  любой  файл  или
устройство.
 
 #DEFINE BUFSIZE 512 /*BEST SIZE FOR PDP-11 UNIX*/
 MAIN() /*COPY INPUT TO OUTPUT*/
 \(
   CHAR BUF[BUFSIZE];
   INT N;
   WHILE((N=READ(0,BUF,BUFSIZE))>0)
     WRITE(1,BUF,N);
 \)
 
    Если размер  файла  не  будет  кратен  BUFSIZE,   то  при
некотором обращении к READ  будет  возвращено  меньшее  число
байтов, которые    затем  записываются  с  помощью WRITE; при
следующем после этого обращении к READ будет возвращен  нуль.
    Поучительно разобраться,   как можно использовать функции
READ и WRITE для построения процедур более  высокого  уровня,
таких как  GETCHAR,  PUTCHAR и т.д.  Вот,  например,  вариант
функции GETCHAR,    осуществляющий  ввод  без   использования
буфера.
 
 #DEFINE CMASK 0377 /*FOR MAKING CHAR'S > 0*/
 GETCHAR() /*UNBUFFERED SINGLE CHARACTER INPUT*/
 \(
   CHAR C;
   RETURN((READ(0,&C,1)>0 7 & CMASK : EOF);
 \)
 
    Переменная "C"  должна быть описана как CHAR,  потому что
функция READ принимает указатель  на  символы.   Возвращаемый
символ должен   быть  маскирован числом 0377 для гарантии его
положительности; в противном  случае  знаковый  разряд  может
сделать его значение отрицательным.  (Константа 0377 подходит
для эвм PDP-11, но не обязательно для других машин).
    Второй вариант функции GETCHAR осуществляет ввод большими
порциями, а выдает символы по одному за обращение.
 
 #DEFINE CMASK 0377 /*FOR MAKING CHAR'S>0*/
 #DEFINE BUFSIZE 512
 GETCHAR() /*BUFFERED VERSION*/
 \(
   STATIC CHAR  BUF[BUFSIZE];
   STATIC CHAR  *BUFP = BUF;
   STATIC INT   N = 0;
   IF (N==0) \( /*BUFFER IS EMPTY*/
     N=READ(0,BUF,BUFSIZE);
     BUFP = BUF;
   \)
   RETURN((--N>=0) ? *BUFP++ & CMASK : EOF);
 \)

     
     
     
     
     
 функции      
     
     
  8.3. Открытие, создание, закрытие и расцепление (UNLINK).
    
    Кроме случая,  когда по умолчанию определены  стандартные
файлы ввода, вывода и ошибок, вы должны явно открывать файлы,
чтобы затем читать из них или писать в них.   Для  этой  цели
существуют две точки входа: OPEN и CREAT.
    Функция OPEN   весьма   сходна    с    функцией    FOPEN,
рассмотренной в   главе  7,  за исключением того,  что вместо
возвращения указателя файла она возвращает дескриптор  файла,
который является просто целым типа INT.
 
                        INT FD;
                        FD=OPEN(NAME,RWMODE);
 
    Как и  в случае FOPEN,  аргумент NAME является символьной
строкой, соответствующей    внешнему  имени  файла.    Однако
аргумент, определяющий  режим доступа, отличен: RWMODE равно:
0 - для чтения, 1 - для записи, 2 - для чтения и записи. Если
происходит какая-то  ошибка,  функция OPEN возвращает "-1"; в
противном случае  она  возвращает  действительный  дескриптор
файла.
    Попытка открыть  файл,   который не существует,  является
ошибкой. Точка входа CREAT предоставляет возможность создания
новых файлов или перезаписи старых. В результате обращения
     
                        FD=CREAT(NAME,PMODE);
 
 возвращает дескриптор   файла,    если  оказалось  возможным
 создать файл с именем NAME,  и "-1" в противном случае. Если
 файл с   таким  именем  уже существует,  CREAT усечет его до
 нулевой длины; создание файла,  который уже существует,   не
 является ошибкой.
    Если файл является совершенно новым, то CREAT создает его
с определенным   режимом  защиты,  специфицируемым аргументом
PMODE. В  системе файлов на UNIX с файлом связываются  девять
битов защиты   информации,   которые управляют разрешением на
чтение, запись  и выполнение для владельца файла,  для группы
владельцев и для всех остальных пользователей. Таким образом,
трехзначное восьмеричное     число   наиболее   удобно    для
спецификации разрешений. Например, число 0755 свидетельствует
о разрешении на чтение, запись и выполнение для владельца и о
разрешении на     чтение  и  выполнение  для  группы  и  всех
остальных.
    Для иллюстрации  ниже  приводится  программа  копирования
одного файла   в  другой,   являющаяся  упрощенным  вариантом
утилиты CP   системы UNIX.  (Основное упрощение заключается в
том, что  наш вариант копирует только один файл и что  второй
аргумент не должен быть справочником).
 
 #DEFINE NULL 0
 #DEFINE BUFSIZE 512
 #DEFINE PMODE 0644/*RW FOR OWNER,R FOR GROUP,OTHERS*/
 MAIN(ARGC,ARGV) /*CP: COPY F1 TO F2*/
   INT ARGC;
   CHAR *ARGV[];
 \(
   INT F1, F2, N;
   CHAR BUF[BUFSIZE];
   IF (ARGC ! = 3)
     ERROR("USAGE:CP FROM TO", NULL);
   IF ((F1=OPEN(ARGV[1],0))== -1)
     ERROR("CP:CAN'T OPEN %S", ARGV[1]);
   IF ((F2=CREAT(ARGV[2],PMODE))== -1)
     ERROR("CP: CAN'T CREATE %S", ARGV[2]);
   WHILE ((N=READ(F1,BUF,BUFSIZE))>0)
     IF (WRITE(F2,BUF,N) !=N)
       ERROR("CP: WRITE ERROR", NULL);
   EXIT(0);
 \)
 ERROR(S1,S2) /*PRINT ERROR MESSAGE AND DIE*/
   CHAR *S1, S2;
 \(
   PRINTF(S1,S2);
   PRINTF("\N");
   EXIT(1);
 \)
 
    Существует ограничение (обычно 15 -  25)   на  количество
файлов, которые программа может иметь открытыми одновременно.
В соответствии с этим любая программа,  собирающаяся работать
со многими   файлами,   должна быть подготовлена к повторному
использованию дескрипторов файлов.  Процедура CLOSE прерывает
связь между     дескриптором   файла   и  открытым  файлом  и
освобождает дескриптор файла для  использования  с  некоторым
другим файлом. Завершение выполнения программы через EXIT или
в результате   возврата  из  ведущей  программы  приводит   к
закрытию всех открытых файлов.
    Функция расцепления UNLINK (FILENAME)  удаляет из системы
файлов файл с именем FILENAME ( из данного справочного файла.
Файл может быть сцеплен с другим справочником,  возможно, под
другим именем - примеч.переводчика).
    Упражнение 8-1.
    --------------
    Перепишите программу  CAT  из главы 7,  используя функции
READ, WRITE,     OPEN  и  CLOSE  вместо  их  эквивалентов  из
стандартной библиотеки.        Проведите   эксперименты   для
определения относительной     скорости   работы   этих   двух
вариантов.
 
     
     
     
     
 
    
     
        8.4. Произвольный доступ - SEEK и LSEEK.
    
    Нормально при   работе   с   файлами   ввод    и    вывод
осуществляется последовательно:     при  каждом  обращении  к
функциям READ и WRITE чтение или запись начинаются с позиции,
непосредственно следующей за предыдущей обработанной.  Но при
необходимости файл может читаться или  записываться  в  любом
произвольном порядке.   Обращение к системе с помощью функции
LSEEK позволяет   передвигаться  по  файлу,    не   производя
фактического чтения или записи. В результате обращения
 
                      LSEEK(FD,OFFSET,ORIGIN);
 
 текущая позиция в файле с дескриптором FD  передвигается  на
 позицию OFFSET  (смещение),  которая отсчитывается от места,
 указываемого аргументом ORIGIN (начало отсчета). Последующее
 чтение или   запись  будут теперь начинаться с этой позиции.
 Аргумент OFFSET имеет тип LONG; FD и ORIGIN имеют  тип  INT.
 Аргумент ORIGIN может принимать значения 0,1 или 2, указывая
 на то,      что   величина   OFFSET   должна   отсчитываться
 соответственно от   начала файла,  от текущей позиции или от
 конца файла.  Например,  чтобы дополнить файл, следует перед
 записью найти его конец:
 
                          LSEEK(FD,0L,2);
 
 чтобы вернуться  к  началу  ("перемотать  обратно"),   можно
 написать:
 
                           LSEEK(FD,0L,0);
 
 обратите внимание на аргумент 0L; его можно было бы записать
 и в виде (LONG) 0.
    Функция LSEEK позволяет обращаться с файлами примерно так
же, как  с большими массивами,  правда ценой более медленного
доступа. следующая простая функция, например, считывает любое
количество байтов, начиная с произвольного места в файле.
 
        GET(FD,POS,BUF,N) /*READ N BYTES FROM POSITION POS*/
        INT FD, N;
        LONG POS;
        CHAR *BUF;
        \(
       LSEEK(FD,POS,0); /*GET TO POS*/
       RETURN(READ(FD,BUF,N));
        \)
 
    В более ранних редакциях,  чем редакция 7  системы  UNIX,
основная точка  входа в систему ввода-вывода называется SEEK.
Функция SEEK идентична функции LSEEK,  за  исключением  того,
что аргумент OFFSET имеет тип INT,  а не LONG. в соответствии
с этим,  поскольку на PDP-11 целые  имеют  только  16  битов,
аргумент OFFSET,      указываемый  функции  SEEK,   ограничен
величиной 65535; по этой причине аргумент ORIGIN может  иметь
значения 3,  4,  5,  которые заставляют функцию SEEK умножить
заданное значение OFFSET на 512 (количество  байтов  в  одном
физическом блоке)  и затем интерпретировать ORIGIN,  как если
это 0,  1 или 2 соответственно.  Следовательно, чтобы достичь
произвольного места   в большом файле,  нужно два обращения к
SEEK: сначала  одно,  которое выделяет нужный блок,  а  затем
второе, где    ORIGIN имеет значение 1 и которое осуществляет
передвижение на желаемый байт внутри блока.
    Упражнение 8-2.
    ---------------
    Очевидно, что SEEK может быть написана в терминалах LSEEK
и наоборот. напишите каждую функцию через другую.

     
     
     
     
     
     
    SCANF("%D", &N);

     
     
     
     
   
 появления этих слов  в  заключенных  в
кавычки строках.

     
     
 
     
     
      8.5. Пример - реализация функций FOPEN и GETC.
    
    Давайте теперь на примере реализации функций FOPEN и GETC
из стандартной  библиотеки подпрограмм продемонстрируем,  как
некоторые из описанных элементов объединяются вместе.
    Напомним, что  в  стандартной библиотеке файлы описыватся
посредством указателей файлов,  а не дескрипторов.  Указатель
файла является   указателем  на  структуру,  которая содержит
несколько элементов информации о  файле:   указатель  буфера,
чтобы файл   мог  читаться  большими  порциями; счетчик числа
символов, оставшихся  в буфере; указатель  следующей  позиции
символа в   буфере;  некоторые  признаки,   указывающие режим
чтения или записи и т.д.; дескриптор файла.
    Описывающая файл  структура  данных  содержится  в  файле
STDIO.H, который  должен включаться (посредством #INCLUDE)  в
любой исходный  файл,   в  котором  используются  функции  из
стандартной библиотеки.    Он также включается функциями этой
библиотеки. В  приводимой  ниже  выдержке  из  файла  STDIO.H
имена, предназначаемые    только  для использования функциями
библиотеки, начинаются с подчеркивания, с тем чтобы уменьшить
вероятность совпадения с именами в программе пользователя.
 
 #DEFINE _BUFSIZE 512
 #DEFINE _NFILE   20 /*FILES THAT CAN BE HANDLED*/
   TYPEDEF STRUCT _IOBUF \(
     CHAR *_PTR;   /*NEXT CHARACTER POSITION*/
     INT  _CNT;    /*NUMBER OF CHARACTERS LEFT*/
     CHAR *_BASE;  /*LOCATION OF BUFFER*/
     INT  _FLAG;   /*MODE OF FILE ACCESS*/
     INT  _FD;     /*FILE DESCRIPTOR*/
  ) FILE;
 EXTERN FILE _IOB[_NFILE];
   
 #DEFINE   STDIN         (&_IOB[0])
 #DEFINE   STDOUT        (&_IOB[1])
 #DEFINE   STDERR        (&_IOB[2])
        
 #DEFINE   _READ   01  /* FILE OPEN FOR READING */
 #DEFINE   _WRITE  02  /* FILE OPEN FOR WRITING */
 #DEFINE   _UNBUF  04  /* FILE IS UNBUFFERED */
 #DEFINE   _BIGBUF 010 /* BIG BUFFER ALLOCATED */
 #DEFINE   _EOF 020 /* EOF HAS OCCURRED ON THIS FILE */
 #DEFINE   _ERR 040 /* ERROR HAS OCCURRED ON THIS FILE */
 #DEFINE   NULL 0
 #DEFINE   EOF  (-1)
   
 #DEFINE   GETC(P) (--(P)->_CNT >= 0 \
    ? *(P)->_PTR++ & 0377 : _FILEBUF(P))
 #DEFINE   GETCHAR() GETC(STDIN)
        
 #DEFINE   PUTC(X,P) (--(P)->_CNT >= 0 \
    ? *(P)->_PTR++ = (X) : _FLUSHBUF((X),P))
 #DEFINE   PUTCHAR(X)       PUTC(X,STDOUT)
 
    В нормальном  состоянии  макрос  GETC  просто   уменьшает
счетчик, передвигает    указатель и возвращает символ.  (Если
определение #DEFINE слишком длинное,  то оно  продолжается  с
помощью обратной косой черты). Если однако счетчик становится
отрицательным, то  GETC вызывает функцию  _FILEBUF,   которая
снова заполняет буфер,  реинициализирует содержимое структуры
и возвращает символ.  Функция может предоставлять переносимый
интерфейс и     в   то   же   время  содержать  непереносимые
конструкции: GETC  маскирует  символ  числом  0377,   которое
подавляет знаковое  расширение,  осуществляемое на PDP-11,  и
тем самым гарантирует положительность всех символов.
    Хотя мы не собираемся обсуждать какие-либо детали, мы все
же включили   сюда  определение макроса PUTC,  для того чтобы
показать, что  она работает в основном точно  также,   как  и
GETC, обращаясь при заполнении буфера к функции _FLUSHBUF.
    Теперь может быть написана функция FOPEN.  Большая  часть
программы функции    FOPEN  связана  с  открыванием  файла  и
расположением его в нужном месте,  а  также  с  установлением
битов признаков   таким  образом,  чтобы они указывали нужное
состояние. Функция  FOPEN  не  выделяет  какой-либо  буферной
памяти; это   делается функцией _FILEBUF при первом чтении из
файла.
 
 #INCLUDE <STDIO.H>
 #DEFINE  PMODE  0644 /*R/W FOR OWNER;R FOR OTHERS*/
 FILE *FOPEN(NAME,MODE) /*OPEN FILE,RETURN FILE PTR*/
 REGISTER CHAR *NAME, *MODE;
 \(
     REGISTER INT FD;
     REGISTER FILE *FP;
 IF(*MODE !='R'&&*MODE !='W'&&*MODE !='A') \(
     FPRINTF(STDERR,"ILLEGAL MODE %S OPENING %S\N",
    MODE,NAME);
     EXIT(1);
 \)
 FOR (FP=_IOB;FP<_IOB+_NFILE;FP++)
     IF((FP->_FLAG & (_READ \! _WRITE))==0)
    BREAK; /*FOUND FREE SLOT*/
 IF(FP>=_IOB+_NFILE) /*NO FREE SLOTS*/
     RETURN(NULL);
 IF(*MODE=='W') /*ACCESS FILE*/
     FD=CREAT(NAME,PMODE);
 ELSE IF(*MODE=='A') \(
     IF((FD=OPEN(NAME,1))==-1)
    FD=CREAT(NAME,PMODE);
     LSEEK(FD,OL,2);
 \) ELSE
     FD=OPEN(NAME,0);
 IF(FD==-1) /*COULDN'T ACCESS NAME*/
     RETURN(NULL);
 FP->_FD=FD;
 FP->_CNT=0;
 FP->_BASE=NULL;
 FP->_FLAG &=(_READ \! _WRITE);
 FP->_FLAG \!=(*MODE=='R') ? _READ : _WRITE;
 RETURN(FP);
 \)
 
    Функция _FILEBUF  несколько  более   сложная.    Основная
трудность заключается в том, что _FILEBUF стремится разрешить
доступ к файлу и в том  случае,   когда  может  не  оказаться
достаточно места   в памяти для буферизации ввода или вывода.
если пространство  для  нового  буфера  может  быть  получено
обращением к функции CALLOC,  то все отлично; если же нет, то
_FILEBUF осуществляет небуферизованный ввод/ вывод, используя
отдельный символ, помещенный в локальном массиве.
 
 #INCLUDE  <STDIO.H>
 FILLBUF(FP) /*ALLOCATE AND FILL INPUT BUFFER*/
   REGISTER FILE *FP;
 \(
   STATIC CHAR SMALLBUF(NFILE);/*FOR UNBUFFERED 1/0*/
   CHAR *CALLOC();
   IF((FP->_FLAG&_READ)==0\!\!(FP->_FLAG&(EOF\!_ERR))\!=0)
     RETURN(EOF);
   WHILE(FP->_BASE==NULL) /*FIND BUFFER SPACE*/
     IF(FP->_FLAG & _UNBUF) /*UNBUFFERED*/
       FP->_BASE=&SMALLBUF[FP->_FD];
     ELSE IF((FP->_BASE=CALLOC(_BUFSIZE,1))==NULL)
       FP->_FLAG \!=_UNBUF; /*CAN'T GET BIG BUF*/
     ELSE
       FP->_FLAG \!=_BIGBUF; /*GOT BIG ONE*/
   FP->_PTR=FP->_BASE;
   FP->_CNT=READ(FP->_FD, FP->_PTR,
   FP->_FLAG & _UNBUF ? 1 : _BUFSIZE);
   IF(--FP->_CNT<0) \(
     IF(FP->_CNT== -1)
       FP->_FLAG \! = _EOF;
     ELSE
       FP->_FLAG \! = _ ERR;
     FP->_CNT = 0;
     RETURN(EOF);
   \)
   RETURN(*FP->_PTR++ & 0377); /*MAKE CHAR POSITIVE*/
 \)
 
    При первом обращении к GETC для конкретного файла счетчик
оказывается равным нулю, что приводит к обращению к _FILEBUF.
Если функция   _FILEBUF  найдет,  что этот файл не открыт для
чтения, она немедленно возвращает EOF. В противном случае она
пытается выделить большой буфер, а если ей это не удается, то
буфер из одного  символа.   При  этом  она  заносит  в  _FLAG
соответствующую информацию о буферизации.
    Раз буфер  уже  создан,  функция _FILEBUF просто вызывает
функцию READ для его  заполнения,   устанавливает  счетчик  и
указатели и возвращает символ из начала буфера.
    Единственный оставшийся  невыясненным  вопрос  состоит  в
том, как  все начинается. Массив _IOB должен быть определен и
инициализирован для STDIN, STDOUT и STDERR:
 
              FILE _IOB[NFILE] = \(
             (NULL,0,_READ,0), /*STDIN*/
             (NULL,0,NULL,1),  /*STDOUT*/
             (NULL,0,NULL,_WRITE \! _UNBUF,2) /*STDERR*/
           );
 
    Из инициализации  части  _FLAG  этого  массива   структур
видно, что  файл STDIN предназначен для чтения, файл STDOUT -
для записи и файл  STDERR  -  для  записи  без  использования
буфера.
    Упражнение 8-3.
    --------------
    Перепишите функции  FOPEN  и  _FILEBUF,   используя  поля
вместо явных побитовых операций.
    Упражнение 8-4.
    ---------------
    Разработайте и напишите функции _FLUSHBUF и FCLOSE.
    Упражнение 8-5.
    ---------------
    Стандартная библиотека содержит функцию
 
                      FSEEK(FP, OFFSET, ORIGIN)
    
 которая идентична  функции  LSEEK,   исключая  то,   что  FP
 является указателем файла, а не дескриптором файла. Напишите
 FSEEK. Убедитесь,   что ваша FSEEK правильно  согласуется  с
 буферизацией, сделанной для других функций библиотеки.
  
     
     
     
     
     
 SSCANF(NAME, "TEMP%D", &N);
 
переменная N получает значение строки цифр, следующих за TEMP
    в NAME.
         
     
     
          8.6. Пример - распечатка справочников
    
    Иногда требуется  другой  вид  взаимодействия  с системой
файлов - определение информации о файле, а не того, что в нем
содержится. Примером    может  служить  команда  LS  ("список
справочника") системы  UNIX.  По этой команде распечатываются
имена файлов    из  справочника  и,   необязательно,   другая
информация, такая как размеры, разрешения и т.д.
    Поскольку, по крайней мере,  на системе  UNIX  справочник
является просто файлом, то в такой команде, как LS нет ничего
особенного; она  читает  файл  и  выделяет  нужные  части  из
находящейся там     информации.    Однако  формат  информации
определяется системой,  так что LS должна знать, в каком виде
все представляется в системе.
    Мы это  частично  проиллюстрируем при написании программы
FSIZE. Программа  FSIZE представляет собой специальную  форму
LS, которая  печатает размеры всех файлов, указанных в списке
ее аргументов.  Если один из файлов является справочником, то
для обработки   этого  справочника программа FSIZE обращается
сама к себе рекурсивно. если же аргументы вообще отсутствуют,
то обрабатывается текущий справочник.
    Для начала  дадим краткий обзор структуры системы файлов.
Справочник - это файл,  который содержит список имен файлов и
некоторое указание о том, где они размещаются. Фактически это
указание является   индексом  для  другой  таблицы,   которую
называют "I  - узловой таблицей".  Для файла I-узел - это то,
где содержится вся информация о файле,   за  исключением  его
имени. Запись в справочнике состоит только из двух элементов:
номера I-узла и имени файла.  Точная  спецификация  поступает
при включении файла SYS/DIR.H, который содержит
 
 #DEFINE DIRSIZ 14 /*MAX LENGTH OF FILE NAME*/
 STRUCT DIRECT /*STRUCTURE OF DIRECTORY ENTRY*/
 \(
   INO_T&_INO; /*INODE NUMBER*/
   CHAR &_NAME[DIRSIZ]; /*FILE NAME*/
 \);
 
    "Тип" INO_T  -  это определяемый посредством TYPEDEF тип,
который описывает индекс I-узловой таблицы.  На  PDP-11  UNIX
этим типом    оказывается  UNSIGNED,   но  это  не  тот  сорт
информации, который  помещают внутрь  программы:   на  разных
системах этот   тип  может быть различным.  Поэтому и следует
использовать TYPEDEF.    Полный   набор   "системных"   типов
находится в файле SYS/TUPES.H.
    Функция STAT   берет   имя   файла   и   возвращает   всю
содержащуюся в I-ом узле информацию об этом  файле  (или  -1,
если имеется ошибка). Таким образом, в результате
 
 STRUCT STAT STBUF;
 CHAR *NAME;
 STAT(NAME,&STBUF);
 
 структура STBUF наполняется информацией из I-го узла о файле
 с именем NAME. Структура, описывающая возвращаемую функцией
 STAT информацию, находится в файле SYS/STAT.H и выглядит
 следующим образом:
 
  STRUCT STAT /*STRUCTURE RETURNED BY STAT*/
  \(
    DEV_T ST_DEV;   /* DEVICE OF INODE */
    INO_T ST_INO;   /* INODE NUMBER */
    SHORT ST_MODE   /* MODE BITS */
    SHORT ST_NLINK; / *NUMBER OF LINKS TO FILE */
    SHORT ST_UID;   /* OWNER'S USER ID */
    SHORT ST_GID;   /* OWNER'S GROUP ID */
    DEV_T ST_RDEV;  /* FOR SPECIAL FILES */
    OFF_T ST_SIZE;  /* FILE SIZE IN CHARACTERS */
    TIME_T ST_ATIME; /* TIME LAST ACCESSED */
    TIME_T ST_MTIME; /* TIME LAST MODIFIED */
    TIME_T ST_CTIME; /* TIME ORIGINALLY CREATED */
  \)
 
    Большая часть этой информации объясняется в комментариях.
Элемент ST.MODE содержит набор флагов,  описывающих файл; для
удобства определения флагов также находятся в файле SYS/STAT.
H.
 
 #DEFINE S_IFMT    0160000 /* TYPE OF FILE */
 #DEFINE S_IFDIR   0040000 /* DIRECTORY */
 #DEFINE S_IFCHR   0020000 /* CHARACTER SPECIAL */
 #DEFINE S_IFBLK   0060000 /* BLOCK SPECIAL */
 #DEFINE S_IFREG   0100000 /* REGULAR */
 #DEFINE S_ISUID   04000   /* SET USER ID ON EXECUTION */
 #DEFINE S_ISGID   02000   /* SET GROUP ID ON EXECUTION */
 #DEFINE S_ISVTX   01000   /*SAVE SWAPPED TEXT AFTER USE*/
 #DEFINE S_IREAD   0400    /* READ PERMISSION */
 #DEFINE S_IWRITE  0200    /* WRITE PERMISSION */
 #DEFINE S_IEXEC   0100    /* EXECUTE PERMISSION */
 
    Теперь мы  в  состоянии  написать  программу FSIZE.  Если
полученный от функции STAT  режим  указывает,   что  файл  не
является справочником,    то его размер уже под рукой и может
быть напечатан   непосредственно.   Если  же  он  оказывается
справочником, то    мы  должны  обрабатывать  этот справочник
отдельно для каждого файла; так как справочник может  в  свою
очередь содержать   подсправочники,   этот  процесс обработки
является рекурсивным.
    Как обычно,  ведущая программа главным образом имеет дело
с командной  строкой аргументов; она передает каждый аргумент
функции FSIZE в большой буфер.
 
 #INCLUDE <STDIO.H.>
 #INCLUDE <SYS/TYPES.H> /*TYPEDEFS*/
 #INCLUDE <SYS/DIR.H>   /*DIRECTORY ENTRY STRUCTURE*/
 #INCLUDE <SYS/STAT.H>  /*STRUCTURE RETURNED BY STAT*/
 #DEFINE BUFSIZE  256
 MAIN(ARGC,ARGV) /*FSIZE:PRINT FILE SIZES*/
 CHAR *ARGV[];
 \(
    CHAR BUF[BUFSIZE];
    IF(ARGC==1) \( /*DEFAULT:CURRENT DIRECTORY*/
   ATRCPY(BUF,".");
   FSIZE(BUF);
    \) ELSE
   WHILE(--ARGC>0) \(
      STRCPY(BUF,*++ARGV);
      FSIZE(BUF);
   \)
 \)
 
    Функция FSIZE  печатает  размер  файла.  Если однако файл
оказывается справочником,  то FSIZE сначала вызывает  функцию
DIRECTORY для обработки всех указанных в нем файлов. Обратите
внимание на использование имен  флагов  S_IFMT  и  _IFDIR  из
файла STAT.H.
 
 FSIZE(NAME) /*PRINT SIZE FOR NAME*/
 CHAR *NAME;
 \(
   STRUCT STAT STBUF;
   IF(STAT(NAME,&STBUF)== -1) \(
     FPRINTF(STDERR,"FSIZE:CAN'T FIND %S\N",NAME);
     RETURN;
   \)
   IF((STBUF.ST_MODE & S_IFMT)==S_IFDIR)
     DIRECTORY(NAME);
   PRINTF("%8LD %S\N",STBUF.ST_SIZE,NAME);
 \)
    
    Функция DIRECTORY   является   самой   сложной.    Однако
значительная ее часть связана с созданием для обрабатываемого
в данный   момент файла его полного имени,  по которому можно
восстановить путь в дереве.
 
 DIRECTORY(NAME)    /*FSIZE FOR ALL FILES IN NAME*/
 CHAR *NAME;
 \(
    STRUCT DIRECT DIRBUF;
    CHAR *NBP, *NEP;
    INT I, FD;
    NBP=NAME+STRLEN(NAME);
    *NBP++='/'; /*ADD SLASH TO DIRECTORY NAME*/
    IF(NBP+DIRSIZ+2>=NAME+BUFSIZE) /*NAME TOO LONG*/
   RETURN;
    IF((FD=OPEN(NAME,0))== -1)
   RETURN;
    WHILE(READ(FD,(CHAR *)&DIRBUF,SIZEOF(DIRBUF))>0) \(
    IF(DIRBUF.D_INO==0) /*SLOT NOT IN USE*/
    CONTINUE;
    IF(STRCMP (DIRBUF.D_NAME,".")==0
    \!\! STRCMP(DIRBUF.D_NAME,"..")==0
    CONTINUE; /*SKIP SELF AND PARENT*/
    FOR (I=0,NEP=NBP;I<DIRSIZ;I++)
    *NEP++=DIRBUF.D_NAME[I];
    *NEP++='\0';
    FSIZE(NAME);
     \)
     CLOSE(FD);
     *--NBP='\0'; /*RESTORE NAME*/
  \)
 
    Если некоторая дыра в справочнике в  настоящее  время  не
используется (потому     что   файл   был   удален),    то  в
соответствующее I-узловое число равно нулю,   и  эта  позиция
пропускается. Каждый справочник также содержит запись в самом
себе, называемую  ".",   и  о  своем  родителе,   "..";  они,
очевидно, также  должны быть пропущены,  а то программа будет
работать весьма и весьма долго.
    Хотя программа FSIZE довольно специализированна,  она все
же демонстрирует    пару  важных  идей.   во-первых,   многие
программы не являются "системными  программами";  они  только
используют информацию,      форма   или   содержание  которой
определяется операционной системой.   Во-вторых,   для  таких
программ существенно,    что  представление  этой  информации
входит только в стандартные "заголовочные файлы",  такие  как
STAT.H и   DIR.H,   и что программы включают эти файлы,  а не
помещают фактические описания внутрь самих программ.

     
     
     
     
     
     
ина  для
применения функции FCLOSE к выходному файлу  -  она  вызывает
выдачу информации  из буфера,  в котором PUTC собирает вывод.
(При нормальном завершении работы  пр     
     
     
            8.7. Пример - распределитель памяти.
    
    В главе  5  мы  написали  бесхитростный  вариант  функции
ALLOC. Вариант,   который мы  напишем  теперь,   не  содержит
ограничений: обращения     к  функциям  ALLOC  и  FREE  могут
перемежаться в любом порядке; когда это необходимо,   функция
ALLOC обращается   к  операционной  системе за дополнительной
памятью. Кроме  того, что эти процедуры полезны сами по себе,
они также   иллюстрируют  некоторые соображения,  связанные с
написанием машинно-зависимых        программ     относительно
машинно-независимым образом,      и  показывают  практическое
применение структур, объединений и конструкций TYPEDEF.
    Вместо того,  чтобы выделять память из  скомпилированного
внутри массива фиксированного размера, функция ALLOC будет по
мере необходимости   обращаться  за  памятью  к  операционной
системе. Поскольку    различные  события  в  программе  могут
требовать асинхронного    выделения   памяти,    то   память,
управляемая ALLOC,   не может быть непрерывной.  В силу этого
свободная память хранится в виде  цепочки  свободных  блоков.
Каждый блок   включает  размер,  указатель следующего блока и
саму свободную   память.   Блоки  упорядочиваются  в  порядке
возрастания адресов     памяти,   причем  последний  блок  (с
наибольшим адресом)  указывает на первый,   так  что  цепочка
фактически оказывается кольцом.
    При поступлении   запроса   список    свободных    блоков
просматривается до  тех пор,  пока не будет найден достаточно
большой блок.  Если этот  блок  имеет  в  точности  требуемый
размер, то      он   отцепляется   от   списка  и  передается
пользователю. Если   же  этот  блок  слишком  велик,   то  он
разделяется, нужное    количество передается пользователю,  а
остаток возвращается в  свободный  список.   Если  достаточно
большого блока   найти  не удается,  то операционной системой
выделяется новый блок,  который включается в список свободных
блоков; затем поиск возобновляется.
    Освобождение памяти  также  влечет  за   собой   просмотр
свободного списка   в  поиске  подходящего места для введения
освобожденного блока.    Если  этот  освободившийся  блок   с
какой-либо стороны   примыкает  к  блоку  из списка свободных
блоков, то они объединяются в один блок большего размера, так
что память   не становится слишком раздробленной.  Обнаружить
смежные блоки просто,  потому что свободный список содержится
в порядке возрастания адресов.
    Одна из  проблем,   о  которой  мы  упоминали  в главе 5,
заключается в обеспечении того,  чтобы возвращаемая  функцией
ALLOC память   была  выровнена  подходящим  образом  для  тех
объектов, которые  будут в  ней  храниться.   Хотя  машины  и
различаются, для    каждой  машины существует тип,  требующий
наибольших ограничений по  размещению  памяти,   если  данные
самого ограничительного   типа  можно  поместить  в некоторый
определенный адрес,  то это же возможно и для всех  остальных
типов. Например,     на  IBM  360/370,HONEYWELL 6000 и многих
других машинах  любой  объект  может  храниться  в  границах,
соответствующим переменным   типа  DOUBLE;  на  PDP-11  будут
достаточны переменные типа INT.
    Свободный блок  содержит  указатель  следующего  блока  в
цепочке, запись    о   размере   блока   и   само   свободное
пространство; управляющая   информация  в  начале  называется
заголовком. Для   упрощения  выравнивания  все  блоки  кратны
размеру заголовка,    а  сам  заголовок  выровнен  надлежащим
образом. Это  достигается  с  помощью  объединения,   которое
содержит желаемую   структуру  заголовка  и  образец наиболее
ограничительного по выравниванию типа:
 
 TYPEDEF INT ALIGN; /*FORCES ALIGNMENT ON PDP-11*/
 UNION HEADER \( /*FREE BLOCK HEADER*/
    STRUCT \(
    UNION HEADER *PTR; /*NEXT FREE BLOCK*/
    UNSIGNED SIZE; /*SIZE OF THIS FREE BLOCK*/
    \) S;
    ALIGN  X; /*FORCE ALIGNMENT OF BLOCKS*/
 \);
 TYPEDEF UNION HEADER HEADER;
 
    Функция ALLOC  округляет  требуемый  размер в символах до
нужного числа единиц  размера  заголовка;  фактический  блок,
который будет   выделен,   содержит  на  одну единицу больше,
предназначаемую для самого заголовка,  и это и есть значение,
которое записывается   в  поле  SIZE  заголовка.   Указатель,
возвращаемый функцией    ALLOC,    указывает   на   свободное
пространство, а не на сам заголовок.
 
 STATIC HEADER BASE; /*EMPTY LIST TO GET STARTED*/
 STATIC HEADER *ALLOCP=NULL; /*LAST ALLOCATED BLOCK*/
 CHAR *ALLOC(NBYTES)/*GENERAL-PURPOSE STORAGE ALLOCATOR*/
 UNSIGNED NBYTES;
 \(
    HEADER *MORECORE();
    REGISTER HEADER *P, *G;
    REGISTER INT NUNITS;
    NUNITS=1+(NBYTES+SIZEOF(HEADER)-1)/SIZEOF(HEADER);
    IF ((G=ALLOCP)==NULL) \( /*NO FREE LIST YET*/
 BASE.S PTR=ALLOCP=G=&BASE;
 BASE.S.SIZE=0;
    \)
    FOR (P=G>S.PTR; ; G=P, P=P->S.PTR) \(
 IF (P->S.SIZE>=NUNITS) \( /*BIG ENOUGH*/
     IF (P->S.SIZE==NUNITS) /*EXACTLY*/
    G->S.PTR=P->S.PTR;
     ELSE \( /*ALLOCATE TAIL END*/
    P->S.SIZE-=NUNITS;
    P+=P->S.SIZE;
    P->S.SIZE=NUNITS;
     \)
     ALLOCP=G;
     RETURN((CHAR *)(P+1));
    \)
    IF(P==ALLOCP) /*WRAPPED AROUND FREE LIST*/
        IF((P=MORECORE(NUNITS))==NULL)
       RETURN(NULL); /*NONE LEFT*/
    \)
       \)
 
    Переменная BASE  используется  для  начала  работы.  Если
ALLOCP имеет значение NULL,  как в случае первого обращения к
ALLOC, то  создается вырожденный свободный список: он состоит
из свободного блока размера нуль и указателя на самого  себя.
В любом   случае  затем  исследуется свободный список.  Поиск
свободного блока подходящего размера начинается с того  места
(ALLOCP), где    был  найден  последний блок; такая стратегия
помогает сохранить однородность диска.  Если  найден  слишком
большой блок,    то  пользователю  предлагается его хвостовая
часть; это приводит к тому,  что в заголовке исходного  блока
нужно изменить     только   его   размер.   Во  всех  случаях
возвращаемый пользователю       указатель    указывает     на
действительно свободную   область,  лежащую на единицу дальше
заголовка. Обратите  внимание на то,  что функция ALLOC перед
возвращением "P" преобразует его в указатель на символы.
    Функция MORECORE получает память от операционной системы.
Детали того,  как это осуществляется,  меняются,  конечно, от
системы к системе.   На  системе  UNIX  точка  входа  SBRK(N)
возвращает указатель       на   "N"   дополнительных   байтов
памяти.(указатель удволетворяет     всем   ограничениям    на
выравнивание). Так   как запрос к системе на выделение памяти
является сравнительно дорогой операцией,  мы не хотим  делать
это при   каждом  обращении к функции ALLOC.  Поэтому функция
MORECORE округляет затребованное  число  единиц  до  большего
значения; этот   больший  блок будет затем разделен так,  как
необходимо. Масштабирующая    величина  является  параметром,
который может  быть подобран в соответствии с необходимостью.
 
 #DEFINE NALLOC 128 /*#UNITS TO ALLOCATE AT ONCE*/
 STATIC HEADER *MORECORE(NU) /*ASK SYSTEM FOR MEMORY*/
 UNSIGNED NU;
 \(
    CHAR *SBRK();
    REGISTER CHAR *CP;
    REGISTER HEADER *UP;
    REGISTER INT RNU;
    RNU=NALLOC*((NU+NALLOC-1)/NALLOC);
    CP=SBRK(RNU*SIZEOF(HEADER));
    IF ((INT)CP==-1) /*NO SPACE AT ALL*/
 RETURN(NULL);
    UP=(HEADER *)CP;
    UP->S.SIZE=RNU;
    FREE((CHAR *)(UP+1));
    RETURN(ALLOCP);
 \)
 
    Если больше  не  осталось  свободного  пространства,   то
функция SBRK  возвращает  "-1",   хотя  NULL  был  бы  лучшим
выбором. Для      надежности   сравнения   "-1"  должна  быть
преобразована к   типу  INT.   Снова  приходится  многократно
использовать явные   преобразования  (перевод)  типов,  чтобы
обеспечить определенную   независимость  функций  от  деталей
представления указателей на различных машинах.
    И последнее  - сама функция FREE.  Начиная с ALLOCP,  она
просто просматривает свободный  список  в  поиске  места  для
введения свободного   блока.   Это место находится либо между
двумя существующими блоками, либо в одном из концов списка. В
любом случае,  если освободившийся блок примыкает к одному из
соседних, смежные  блоки объединяются.  Следить нужно  только
затем, чтобы  указатели указывали на то,  что нужно,  и чтобы
размеры были установлены правильно.
 
 FREE(AP) /*PUT BLOCKE AP IN FREE LIST*/
 CHAR *AP;
 \(
    REGISTER HEADER *P, *G;
    P=(HEADER*)AP-1; /*POINT TO HEADER*/
    FOR (G=ALLOCP; !(P>G && P>G->S.PTR);G=G->S.PTR)
 IF (G>=G->S.PTR && (P>G \!\! P<G->S.PTR))
     BREAK; /*AT ONE END OR OTHER*/
 IF (P+P->S.SIZE==G->S.PTR)\(/*JOIN TO UPPER NBR*/
     P->S.SIZE += G->S.PTR->S.SIZE;
     P->S.PTR = G->S.PTR->S.PTR;
 \) ELSE
     P->S.PTR = G->S.PTR;
 IF (G+G->S.SIZE==P) \( /*JOIN TO LOWER NBR*/
     G->S.SIZE+=P->S.SIZE;
     G->S.PTR=P->S.PTR;
 \) ELSE
     G->S.PTR=P;
 ALLOCP = G;
    \)
 
    Хотя распределение  памяти  по  своей  сути  зависит   от
используемой машины,   приведенная выше программа показывает,
как эту зависимость можно регулировать  и  ограничить  весьма
небольшой частью   программы.   Использование TYPEDEF и UNION
позволяет справиться   с  выравниванием  (при  условии,   что
функция SBRK   обеспечивает  подходящий указатель).  Переводы
типов организуют выполнение  явного  преобразования  типов  и
даже справляются     с   неудачно   разработанным   системным
интерфейсом. И хотя рассмотренные здесь подробности связаны с
распределением памяти, общий подход равным образом применим и
к другим ситуациям.
    Упражнение 8-6.
    --------------
    Функция из    стандартной    библиотеки    CALLOC(N,SIZE)
возвращает указатель на "N" объектов  размера  SIZE,   причем
соответствующая память   инициализируется  на нуль.  напишите
программу для CALLOC, используя функцию ALLOC либо в качестве
образца, либо как функцию, к которой происходит обращение.
    Упражнение 8-7.
    ---------------
    Функция ALLOC принимает затребованный размер, не проверяя
его правдоподобности;   функция FREE полагает,  что тот блок,
который она должна освободить, содержит правильное значение в
поле размера. Усовершенствуйте эти процедуры, затратив больше
усилий на проверку ошибок.
    Упражнение 8-8.
    ---------------
    Напишите функцию     BFREE(P,N),      которая    включает
произвольный блок "P" из  "N"  символов  в  список  свободных
блоков, управляемый функциями ALLOC и FREE. С помощью функции
BFREE пользователь может в любое время добавлять в  свободный
список статический или внешний массив.
 




                                                                                                                                    
     
     

     9. Приложение А: справочное руководство по языку 'C'
 
                           9.1. Введение
 
    Это руководство описывает язык 'с'  для  компьютеров  DEC
PDP-11, HONEYWELL    6000,  IBM система/370 и INTERDATA 8/32.
там, где есть расхождения, мы сосредотачиваемся на версии для
PDP-11, стремясь    в  то  же  время указать детали,  которые
зависят от реализации.  За малым исключением, эти расхождения
непосредственно обусловлены          основными     свойствами
используемого аппаратного оборудования; различные компиляторы
обычно вполне совместимы.
    
     
     
     
     
     
     
й новый   файл  с  новой страницы и печатает для каждого
файла заголовок и счетчик текущих страниц.
   
     
     
      
     
     
     
                     10. Лексические соглашения
    
    Имеется шесть классов лексем:  идентификаторы,   ключевые
слова, константы,     строки,  операции и другие разделители.
Пробелы, табуляции  ,  новые строки и комментарии (совместно,
"пустые промежутки"),    как описано ниже,  игнорируются,  за
исключением тех  случаев,   когда  они  служат  разделителями
лексем. Необходим   какой-то пустой промежуток для разделения
идентификаторов, ключевых    слов  и  констант,   которые   в
противном случае сольются.
    Если сделан  разбор  входного потока на лексемы вплоть до
данного символа,  то в  качестве  следующей  лексемы  берется
самая длинная строка символов, которая еще может представлять
собой лексему.
    
                          10.1. Комментарии
    
    Комментарий открывается   символами  /*  и  заканчивается
символами /*. Комментарии не вкладываются друг в друга.
 
                    10.2. Идентификаторы (имена)
    
    Идентификатор -  это  последовательность  букв  и   цифр;
первый символ  должен быть буквой.  Подчеркивание _ считается
буквой. Буквы   нижнего  и  верхнего  регистров  различаются.
значащими являются не более, чем первые восемь символов, хотя
можно использовать  и  больше.   На  внешние  идентификаторы,
которые используются  различными ассемблерами и загрузчиками,
накладыватся более жесткие ограничения:
 
            DEC PDP-11             7 символов, 2 регистра
            HONEYWELL 6000         6 символов, 1 регистр
            IBM 360/370            7 символов, 1 регистр
            INTERDATA 8/32         8 символов, 2 регистра
 
                        10.3. Ключевые слова
 
    Следующие идентификаторы       зарезервированы        для
использования в     качестве   ключевых   слов   и  не  могут
использоваться иным образом:
 
                    INT      EXTERN      ELSE
                    CHAR      REGISTER      FOR
                    FLOAT      TYPEDEF      DO
                    DOUBLE      STATIC      WHILE
                    STRUCT      GOTO      SWITCH
                    UNION      RETURN      CASE
                    LONG      SIZEOF      DEFAULT
                    SHORT      BREAK      ENTRY
                    UNSIGNED    CONTINUE
                    *AUTO      IF
 
    Ключевое слово ENTRY в настоящее  время  не  используется
каким-либо компилятором;        оно    зарезервировано    для
использования в     будущем.    В    некоторых    реализациях
резервируется также слова FORTRAN и ASM
    
                           10.4. Константы
    
    Имеется несколько видов  констант,   которые  перечислены
ниже. В    пункте 10.6 резюмируются характеристики аппаратных
средств, которые влияют на размеры.
    
                      10.4.1. Целые константы
 
    Целая константа,  состоящая из  последовательности  цифр,
считается восьмеричной, если она начинается с 0 (цифра нуль),
и десятичной   в  противном  случае.   Цифры  8  и  9   имеют
восьмеричные значения        10    и    11    соответственно.
Последовательность цифр,   которой  предшествуют  символы  0х
(нуль, х-маленькое)  или 0х (нуль х-большое), рассматривается
как шестнадцатиричное целое. Шестнадцатиричные цифры включают
буквы от а (маленькое) или а (большое) до F (маленькое) или F
(большое) со  значениями от 10 до 15.  Десятичная  константа,
величина которой   превышает  наибольшее  машинное  целое  со
знаком, считается  длинной; восмеричная или шестнадцатиричная
константа, которое    превышает наибольшее машинное целое без
знака, также считается длинной.
    
                  10.4.2. Явные длинные константы
    
    Десятичная, восмеричная или шестнадцатиричная  константа,
за которой   непосредственно следует L (эль-маленькое)  или L
(эль-большое), является  длинной константой.  Как обсуждается
ниже, на    некоторых  машинах целые и длинные значения могут
рассматриваться как идентичные.
    
                    10.4.3. Символьные константы
    
    Символьная константа   -   это   символ,   заключенный  в
одиночные кавычки,  как,  например, 'X'. Значением символьной
константы является     численное  значение  этого  символа  в
машинном представлении набора символов.
    Некоторые неграфические  символы,   одиночная кавычка ' и
обратная косая черта \ могут быть представлены в соответствии
со следующей таблицей условных последовательностей:
 
           новая строка                      NL/LF/    \N
           горизонтальная табуляция          HT        \T
           символ возврата на одну позицию   BS        \B
           возврат каретки                   CR        \R
           переход на новую страницу         FF        \F
           обратная косая черта              \         \\
           одиночная кавычка                 '         \'
           комбинация битов                  DDD       \DDD
 
    Условная последовательность  \DDD  состоит  из   обратной
косой черты,  за которой следуют 1,2 или 3 восмеричных цифры,
которые рассмативаются   как  задающие   значение   желаемого
символа. Специальным     случаем  этой  конструкции  является
последовательность \0 (за нулем не следует  цифра),   которая
определяет символ   NUL.   если  следующий  за обратной косой
чертой символ не совпадает с одним из указанных,  то обратная
косая черта игнорируется.
    
               10.4.4. Плавающие константы
    
    Плавающая константа состоит из целой  части,   десятичной
точки, дробной  части,  буквы E (маленькая) или E (большая) и
целой экспоненты с необязательным знаком.  Как целая,  так  и
дробная часть являются последовательностью цифр.  Либо целая,
либо дробная часть (но не  обе)   может  отсутствовать;  либо
десятичная точка, либо е (маленькая) и экспонента (но не то и
другое одновременно)  может отсутствовать.  Каждая  плавающая
константа считается имеющей двойную точность.
    
                    10.5. Строки
    
    Строка - это последовательность символов,  заключенная  в
двойные кавычки,    как,   наприимер,"...".  Строка имеет тип
"массив массивов" и класс памяти STATIC (см.  Пункт 4  ниже).
Строка инициализирована   указанными  в  ней  символами.  Все
строки, даже  идентично  записанные,   считаются  различными.
Компилятор помещает в конец каждой строки нулевой байт \0,  с
тем чтобы просматривающая строку программа  могла  определить
ее конец.    Перед  стоящим  внутри  строки  символом двойной
кавычки " должен быть поставлен символ обратной  косой  черты
\; кроме     того,    могут   использоваться  те  же  условия
последовательности, что    и  в  символьных  константах.    И
последнее, обратная косая черта \, за которой непосредственно
следует символ новой строки, игнорируется.
    
              10.6. Характеристики аппаратных средств
    
    Следующая ниже  таблица  суммирует   некоторые   свойства
аппаратного оборудования,    которые  меняются  от  машины  к
машине. Хотя  они и влияют  на  переносимость  программ,   на
практике они  представляют маленькую проблему,  чем это может
казаться заранее.
           Таблица 1
      -------------------------------------------------------
       DEC PDP-11   HONEYWELL      IBM 370    INTERDATA 8/32
         ASCII        ASCII          EBCDIC     ASCII
  CHAR    8 BITS     9 BITS         8 BITS     8 BITS
  INT     16           36             32         32
  SHORT   16           36             16         16
  LONG    32           36             32         32
  FLOAT   32           36             32         32
  DOUBLE  64           72             64         64
  RANGE  -38/+38    -38/+38         -76/+76    -76/+76
      --------------------------------------------------------

     
     
     






спользовать     содержащуюся   в   описаниях  TYPEDEF
информацию для проведения некоторой  дополнительной  проверки
программы.

    
     
     
     
              11. Синтаксическая нотация
 
    В используемой  в этом руководстве синтаксической нотации
синтаксические категории выделяются курсивом (прим. перев.: в
настоящее время   синтексические  категории  вместо  курсивом
выделяются подчеркиванием),  а литерные  слова  и  символы  -
жирным шрифтом.    Альтернативные  категории перечисляются на
отдельных строчках.  Необязательный символ,  терминальный или
нетерминальный, указывается индексом "необ", так что
 
                          \( выражение
                          --------- необ \)
     
указывает на необязательное выражение, заключенное в фигурных
скобках. Синтаксис суммируется в пункте 18.
   
     
     
     
     
     
     

 
                   
     
     
           12. Что в имене тебе моем?
    
    Язык "C" основывает интерпретацию идентификатора на  двух
признаках идентификатора: его классе памяти и его типе. Класс
памяти определяет место и время хранения памяти,  связанной с
идентификатором; тип определяет смысл величин,  находящихся в
памяти, определенной под идентификатором.
    Имеются четыре     класса     памяти:     автоматическая,
статическая, внешняя и регистровая. Автоматические переменные
являются локальными   для каждого вызова блока и исчезают при
выходе из   этого  блока.   Статические  переменные  являются
локальными, но сохраняют свои значения для следующего входа в
блок даже после того,  как управление передается  за  пределы
блока. Внешние     переменные  существуют  и  сохраняют  свои
значения в   течение  выполнения  всей  программы   и   могут
использоваться для связи между функциями, в том числе и между
независимо скомпилированными       функциями.     Регистровые
переменные хранятся   (ели это возможно)  в быстрых регистрах
машины; подобно   автоматическим  переменным   они   являются
локальными для   каждого блока и исчезают при выходе из этого
блока.
    В языке  "C"  предусмотрено  несколько   основных   типов
объектов: объекты,  написанные как символы (CHAR), достаточно
велики, чтобы  хранить любой член из соответствующего  данной
реализации внутреннего набора символов, и если действительный
символ из   этого  набора  символов  хранится  в   символьной
переменной, то    ее  значение эквивалентно целому коду этого
символа. В  символьных  переменных  можно  хранить  и  другие
величины, но реализация будет машинно-зависимой.
    Можно использовать до трех размеров  целых,   описываемых
как SHORT   INT,   INT и LONG INT.  Длинные целые занимают не
меньше памяти, чем короткие, но в конкретной реализации может
оказаться, что  либо короткие целые, либо длинные целые, либо
те и другие будут эквивалентны простым целым. "Простые" целые
имеют естественный   размер,  предусматриваемый архиитектурой
используемой машины;     другие    размеры    вводятся    для
удволетворения специальных потребностей.
    Целые без  знака,  описываемые как UNSIGNED,  подчиняются
законам арифметики по модулю 2**N,  где N - число битов в  их
представлении. (На    PDP-11  длинные  величины  без знака не
предусмотрены).
    Плавающие одинарной точности (FLOAT)  и плавающие двойной
точности (DOUBLE)      в  некоторых  реализациях  могут  быть
синонимами.
    Поскольку объекты  упомянутых  выше  типов   могут   быть
разумно интерпретированы как числа, эти типы будут называться
арифметическими. типы  CHAR и  INT  всех  размеров  совместно
будут называться     целочисленными.   Типы  FLOAT  и  DOUBLE
совместно будут называться плавающими типами.
    Кроме основных    арифметических     типов     существует
концептуально бесконечный   класс производных типов,  которые
образуются из основных типов следующим образом:
      массивы объектов большинства типов;
      функции, которые возвращают объекты заданного типа;
      указатели на объекты данного типа;
      структуры, содержащие последовательность объектов
      различных типов;
      объединения, способные содержать один из нескольких
        объектов различных типов.
    Вообще говоря,   эти  методы  построения  объектов  могут
применяться рекурсивно.
    
     
     
     
     
     
ой библиотеки.

     
     
     
     
     
   
                                                                                                      
     
     
                13. Объекты и L-значения
    
    Объект является   доступным  обработке  участком  памяти;
L-значение - это выражение,  ссылающееся на объект. Очевидным
примером выражения     L-значения   является   идентификатор.
Существуют операции, результатом которых являются L-значения;
если, например, E - выражение указанного типа, то *E является
выражением L-значения,  ссылающимся на  объект  E.   Название
"L-значение" происходит   от выражения присваивания E1=E2,  в
котором левая часть должна быть выражением  L-значения.   При
последующем обсуждении   каждой  операции  будет указываться,
ожидает ли   она  операндов  L-значения  и  выдает   ли   она
L-значение.

     
     
     
     
     
     
     
     
я обработки каждого символа.  В главе 8
мы продемонстрируем, как это делается.

     
     
     
     
     
   
                                                                                                                                        
     
     
                  14. Преобразования
 
    Ряд операций  может  в  зависимости  от  своих  операндов
вызывать преобразование значение операнда из  одного  типа  в
другой. В    этом  разделе  объясняются  результаты,  которые
следует ожидать от таких преобразований. В п. 14.6 Подводятся
итоги преобразований,      требуемые   большинством   обычных
операций; эти сведения дополняются  необходимым  образом  при
обсуждении каждой операции.
 
                       14.1. Символы и целые
    
    Символ или короткое целое можно использовать всюду,   где
можно использовать     целое.    Во   всех  случаях  значение
преобразуется к целому. Преобразование более короткого целого
к более  длинному всегда сопровождается знаковым расширением;
целые являются величинами со знаком.  Осуществляется или  нет
знаковое расширение   для  символов,  зависит от используемой
машины, но   гарантируется,   что  член  стандартного  набора
символов неотрицателен. из всех машин, рассматриваемых в этом
руководстве, только  PDP-11 осуществляет знаковое расширение.
область значений  символьных переменных на PDP-11 меняется от
-128 до 127; символы  из  набора  ASC11  имеют  положительные
значения. Символьная      константа,    заданная   с  помощью
восьмеричной условной     последовательности,    подвергается
знаковому расширению     и   может  оказаться  отрицательной;
например, '\377' имеет значение -1.
    Когда более  длинное целое преобразуется в более короткое
или в   CHAR,   оно  обрезается  слева;  лишние  биты  просто
отбрасываются.
 
                      14.2. Типы FLOAT и DOUBLE
    
    Вся плавающая арифметика  в  "C"  выполняется  с  двойной
точностью каждый   раз,  когда объект типа FLOAT появляется в
выражении, он  удлиняется до  DOUBLE  посредством  добавления
нулей в   его дробную часть.  когда объект типа DOUBLE должен
быть преобразован к типу FLOAT,  например,  при присваивании,
перед усечением DOUBLE округляется до длины FLOAT.
    
              14.3. Плавающие и целочисленные величины
    
    Преобразование плавающих значений к  целочисленному  типу
имеет тенденцию  быть до некоторой степени машинно-зависимым;
в частности направление усечения отрицательных чисел меняется
от машине к машине.  Результат не определен, если значение не
помещается в предоставляемое пространство.
    Преобразование целочисленных    значений    в   плавающие
выполняется без осложнений.  Может произойти некоторая потеря
точности, если    для  результата  не содержится достаточного
количества битов.
    
                      14.4. Указатели и целые
    
    Целое или длинное целое может быть прибавлено к указателю
или вычтено   из  него;  в  этом   случае   первая   величина
преобразуется так,     как  указывается  в  разделе  описания
операции сложения.
    Два указателя на  объекты  одинакового  типа  могут  быть
вычтены; в этом случае результат преобразуется к целому,  как
указывается в разделе описания операции вычитания.
    
                       14.5. Целое без знака
    
    Всякий раз,  когда целое без знака объединяется с простым
целым, простое    целое  преобразуется  в  целое  без знака и
результат оказывается целым без  знака.   Значением  является
наименьшее целое без знака,  соответствующее целому со знаком
(по модулю   2**размер  слова).   В  двоичном  дополнительном
представлении это преобразование является чисто умозрительным
и не изменяет фактическую комбинацию битов.
    Когда целое без знака преобразуется к типу LONG, значение
результата совпадает   со  значением целого без знака.  Таким
образом, это   преобразование  сводится  к  добавлению  нулей
слева.
    
                 14.6. Арифметические преобразования
    
    Подавляющее большинство операций вызывает  преобразование
и определяет типы результата аналогичным образом.  Приводимая
ниже схема    в   дальнейшем   будет   называться   "обычными
арифметическими преобразованиями".
    Сначала любые операнды типа CHAR или SHORT  преобразуются
в INT, а любые операнды типа FLOAT преобразуются в DOUBLE.
    Затем, если какой-либо  операнд  имеет  тип  DOUBLE,   то
другой преобразуется   к  типу  DOUBLE,   и  это  будет типом
результата.
    В противном случае,  если какой-либо  операнд  имеет  тип
LONG, то   другой операнд преобразуется к типу LONG,  и это и
будет типом результата
    В противном  случае,   если  какой-либо операнд имеет тип
UNSIGNED, и это будет типом результата. В противном
    случае оба  операнда  будут  иметь  тип INT,  и это будет
типом результата.
     

     
     
     
     
     
     
     
     
     
     
     
     
ной   библиотеке
ввода/вывода "функции"  GETCHAR и PUTCHAR на самом деле могут
быть макросами.  Это позволяет избежать накладных расходов на
обращение к функции                            


               15. Выражения
    
    Старшинство операций в выражениях  совпадает  с  порядком
следования основных подразделов настоящего раздела, начиная с
самого высокого    уровня   старшинства.    Так,    например,
выражениями, указываемыми в качестве операндов операции + (п.
15.4), Являются  выражения,   определенные  в  п.п.15.1-15.3.
Внутри каждого     подраздела   операции   имеет   одинаковое
старшинство. В каждом подразделе для описываемых там операций
указывается их ассоциативность слева или справа.  Старшинство
и ассоциативность всех операций в выражениях  резюмируются  в
грамматической сводке в п.18.
    В противном   случае   порядок  вычислений  выражений  не
определен. В  частности,  компилятор  считает  себя  в  праве
вычислять подвыражения   в  том  порядке,  который он находит
наиболее эффективным,  даже если эти подвыражения приводят  к
побочным эффектам.    Порядок,  в котором происходят побочные
эффекты, не      специфицируется.    Выражения,    включающие
коммутативные и  ассоциативные операции ( *,+,&,!,^ ),  могут
быть переупорядочены произвольным образом  даже  при  наличии
круглых скобок;     чтобы   вынудить   определенный   порядок
вычислений, в   этом  случае  необходимо  использовать  явные
промежуточные переменные.
    При вычислении   выражений   обработка   переполнения   и
проверка при     делении  являются  машинно-зависимыми.   Все
существующие реализации  языка  "C"  игнорируют  переполнение
целых; обработка  ситуаций при делении на 0 и при всех особых
случаях с плавающими числами меняется от машины  к  машине  и
обычно выполняется с помощью библиотечной функции.
    
                     15.1. Первичные выражения
    
    Первичные выражения,  включающие .,   ->,   индексацию  и
обращения к функциям, группируются слева направо.
    Первичное выражение:
                    идентификатор
                    константа
                    строка
                    (выражение)
                    первичное-выражение  [выражение]
               первичное-выражение  (список-выражений   нео
                    первичное-L-значение . Идентификатор
                    первичное-выражение -> идентификатор
                    список-выражений:
                    выражение
                    список-выражений, выражение
      
    Идентификатор является  первичным выражением при условии,
что он описан подходящим образом,  как это обсуждается  ниже.
тип идентификатора определяется его описанием.  Если, однако,
типом идентификатора является  "массив  ...",   то  значением
выражения, состоящего    из  этого идентификатора ,  является
указатель на первый объект в этом массиве,  а типом выражения
будет "указатель на ...".  Более того,  идентификатор массива
не является    выражением   L-значения.    подобным   образом
идентификатор, который    описан  как "функция,  возвращающая
...", за  исключением того случая,  когда он  используется  в
позиции имени     функции  при  обращении,   преобразуется  в
"указатель на функцию, которая возвращает ...".
    Константа является первичным выражением. В зависимости от
ее формы типом константы может быть INT, LONG или DOUBLE.
    Строка является  первичным выражением.  Исходным ее типом
является "массив символов"; но следуя тем же самым  правилам,
которые приведены выше для идентификаторов, он модифицируется
в "указатель на символы", и результатом является указатель на
первый символ    строки.   (имеется  исключение  в  некоторых
инициализаторах; см. П. 16.6.)
    Выражение в    круглых    скобках    является   первичным
выражением, тип и значение которого идентичны типу и значению
этого выражения без скобок.  Наличие круглых скобок не влияет
на то, является ли выражение L-значением или нет.
    Первичное выражение,   за  которым  следует  выражение  в
квадратных скобках, является первичным выражением. Интуитивно
ясно, что    это  выражение  с  индексом.   Обычно  первичное
выражение имеет тип "указатель на
...", индексное  выражение имеет тип INT,  а типом результата
является "...".  Выражение E1[E2]  по  определению  идентично
выражению * ((E1)  + (E2)). Все, что необходимо для понимания
этой записи,  содержится в этом разделе; вопросы, связанные с
понятием идентификаторов   и операций * и + рассматриваются в
п.п. 15.1,   15.2 И 15.4 соответственно;  выводы  суммируются
ниже в п. 22.3.
    Обращение к  функции  является  первичным выражением,  за
которым следует заключенный в круглые скобки возможно  пустой
список выражений,      разделенных   запятыми,    которые   и
представляют собой фактические аргументы функции.   Первичное
выражение должно   быть типа "функция,  возвращающая ...",  а
результат обращения   к  функции  имеет   тип   "...".    Как
указывается ниже,   ранее не встречавщийся идентификатор,  за
которым непосредственно   следует   левая   круглая   скобка,
считается описанным по контексту, как представляющий функцию,
возвращающую целое; следовательно  чаще  всего  встречающийся
случай функции,  возвращающей целое значение,  не нуждается в
описании.
    Перед обращением  любые  фактические аргументы типа FLOAT
преобразуются к типу DOUBLE,  любые аргументы типа  CHAR  или
SHORT преобразуются к типу INT, и, как обычно, имена массивов
преобразуются в указатели.  Никакие другие преобразования  не
выполняются автоматически;   в частности,  не сравнивает типы
фактических аргументов с типами формальных аргументов.   Если
преобразование необходимо,    используйте  явный перевод типа
(CAST); см. П.п. 15.2, 16.7.
    При подготовке к вызову функции  делается  копия  каждого
фактического параметра;     таким   образом,    все  передачи
аргументов в языке "C"  осуществляются  строго  по  значению.
функция может  изменять значения своих формальных параметров,
но эти   изменения  не   влияют   на   значения   фактических
параметров. С    другой строны имеется возможность передавать
указатель при таком  условии,   что  функция  может  изменять
значение объекта,    на  который  этот  указатель  указывает.
Порядок вычисления аргументов в языке не определен;  обратите
внимание на   то,   что  различные  компиляторы  вычисляют по
разному.
    Допускаются рекурсивные обращения к любой функции.
    Первичное выражение,   за   которым   следует   точка   и
идентификатор, является  выражением.  Первое выражение должно
быть L-значением,  именующим структуру  или  объединение,   а
идентификатор должен     быть   именем  члена  структуры  или
объединения. Результатом  является L-значение, ссылающееся на
поименованный член структуры или объединения.
    Первичное выражение,     за   которым   следует   стрелка
(составленная из знаков - и >)   и  идентификатор,   является
выражением. первое    выражение  должно  быть  указателем  на
структуру или объединение,  а идентификатор должен  именовать
член этой   структуры  или объединения.  Результатом является
L-значение, ссылающееся  на поименованный член структуры  или
объединения, на который указывает указательное выражение.
    Следовательно, выражение  E1->MOS  является тем же самым,
что и   выражение   (*E1).MOS.    Структуры   и   объединения
рассматриваются в    п.   16.5.   Приведенные  здесь  правила
использования структур и объединений не навязываются  строго,
для того  чтобы иметь возможность обойти механизм типов.  См.
П. 22.1.
    
                       15.2. Унарные операции
    
    Выражение с   унарными   операциями  группируется  справо
    налево. Унарное-выражение:
                           *  выражение
                           &  L-значение
                           -  выражение
                           !  Выражение
                           \^ выражение
                           ++ L-значение
                           -- L-значение
                           L-значение ++
                           L-значение --
                           (имя-типа) выражение
                           SIZEOF выражение
                           SIZEOF имя-типа
 
    Унарная операция   *   означает   косвенную    адресацию:
выражение должно   быть  указателем,   а результатом является
L-значение, ссылающееся  на тот объект,  на который указывает
выражение. Если   типом выражения является "указатель на...",
то типом результата будет "...".
    Результатом унарной  операции  &  является  указатель  на
объект, к    которому  ссылается L-значение.  Если L-значение
имеет тип "...",  то типом  результата  будет  "указатель  на
...".
    Результатом унарной   операции  -  (минус)   является  ее
операнд, взятый  с противоположным знаком.  Для величины типа
UNSIGNED результат  получается вычитанием ее значения из 2**N
(два в степени N),  где N-число битов в INT. Унарной операции
+ (плюс) не существует.
    Результатом операции логического отрицания !  Является 1,
если значение ее операнда равно 0,  и 0,   если  значение  ее
операнда отлично   от  нуля.   Результат  имеет тип INT.  Эта
операция применима   к  любому   арифметическому   типу   или
указателям.
    Операция \^ дает обратный код, или дополнение до единицы,
своего операнда.      Выполняются   обычные    арифметические
преобразования. Операнд должен быть целочисленного типа.
    Объект, на   который   ссылается    операнд    L-значения
префиксной операции   ++,  увеличивается.  значением является
новое значение операнда,  но это не L-значение. Выражение ++х
эквивалентно х+=1.    Информацию  о  преобразованиях смотри в
разборе операции сложения (п.  15.4)  и операции присваивания
(п. 15.14).
    Префиксная операция -- аналогична префиксной операции ++,
но приводит к уменьшению своего операнда L-значения.
    При применении   постфиксной  операции  ++  к  L-значению
результатом является значение объекта, на который ссылается L
-значение. После    того,   как  результат принят к сведению,
объект увеличивается точно таким же образом,  как и в  случае
префиксной операции   ++.  Результат имеет тот же тип,  что и
выражение L-значения.
    При применении  постфиксной  операции  --  к   L-значению
результатом является значение объекта, на который ссылается L
-значение. После  того,  как  результат  принят  к  сведению,
объект уменьшается   точно  таким же образом,  как и в случае
префиксной операции --.  Результат имеет тот же тип,   что  и
выражение L-значения.
    Заключенное в  круглые  скобки  имя  типа  данных,стоящее
перед выражением ,  вызывает  преобразование  значения  этого
выражения к   указанному  типу.   Эта  конструкция называется
перевод (CAST). Имена типов описываются в п. 16.7.
    Операция SIZEOF  выдает  размер своего операнда в байтах.
(Понятие байт  в  языке  не  определено,   разве  только  как
значение операции    SIZEOF.   Однако  во  всех  существующих
реализациях байтом является  пространство,   необходимое  для
хранения объекта   типа  CHAR).   При  применении  к  массиву
результатом является полное число байтов в  массиве.   Размер
определяется из описаний объектов в выражении.  Это выражение
семантически является   целой   константой   и   может   быть
использовано в любом месте, где требуется константа. Основное
применение эта операция находит  при  связях  с  процедурами,
подобным распределителям памяти,  и в системах ввода- вывода.
    Операция SIZEOF   может   быть   также   применена   и  к
заключенному в круглые скобки имени типа.  В этом случае  она
выдает размер в байтах объекта указанного типа.
    Конструкция SIZEOF (тип)  рассматривается как целое,  так
что выражение SIZEOF (тип) - 2 эквивалентно выражению (SIZEOF
(тип)9 - 2.
    
                  15.3. Мультипликативные операции
    
    Мультипликативные операции *,  /,  и % группируются слева
направо. Выполняются обычные арифметические преобразования.
   Мультипликативное-выражение:
                        выражение * выражение
                        выражение / выражение
                        выражение % выражение
    
    Бинарная операция  *  означает  умножение.   Операция   *
ассоциативна, и  выражения с несколькими умножениями на одном
и том же уровне могут быть перегруппированы компилятором.
    Бинарная операция   /   означает  деление.   При  делении
положительных целых осуществляется усечение по направлению  к
нулю, но    если  один  из  операндов  отрицателен,  то форма
усечения зависит от используемой машины.   На  всех  машинах,
охватываемых настоящим   руководством,   остаток имеет тот же
знак ,  что и делимое.  Всегда справедливо,  что  (A/B)*B+A%B
равно A (если B не равно 0).
    Бинарная операция  %  выдает  остаток  от деления первого
выражения на   второе.   Выполняются  обычные  арифметические
преобразования. Операнды не должны быть типа FLOAT.
    
                     15.4. Аддитивные операции
    
    Аддитивные операции  +  и  -  группируются слева направо.
выполняются обычные арифметические преобразования. Для каждой
операции имеются     некоторые   дополнительные  возможности,
связанные с типами операндов.
    Аддитивное-выражение:
                        выражение + выражение
                        выражение - выражение
 
    Результатом операции + является сумма  операндов.   Можно
складывать указатель   на  объект в массиве и значение любого
целочисленного типа.  во всех случаях последнее преобразуется
в адресное   смещение  посредством  умножения  его  на  длину
объекта, на  который указывает этот  указатель.   Результатом
является указатель   того  же  самого  типа,   что и исходный
указатель, который  указывает  на  другой  объект  в  том  же
массиве, смещенный     соответствующим  образом  относительно
первоначального объекта.  Таким  образом,   если  P  является
указателем объекта   в  массиве,   то  выражение P+1 является
указателем на следующий объект в этом массиве.
    Никакие другие комбинации типов для указателей не разрешаются.
    Операция +  ассоциативна,   и  выражение  с   несколькими
сложениями на  том же самом уровне могут быть переупорядочены
компилятором.
    Результатом операции   -   является  разность  операндов.
Выполняются обычные   арифметические  преобразования.   Кроме
того, из    указателя  может  быть  вычтено  значение  любого
целочисленного типа,    причем,   проводятся  те   же   самые
преобразования, что и при операции сложения.
    Если вычитаются  два  указателя  на  объекты  одинакового
типа, то  результат преобразуется (делением на длину объекта)
к типу INT,  представляя собой число  объектов,   разделяющих
указываемые объекты.    Если  эти  указатели не на объекты из
одного и того же массива,  то такое  преобразование,   вообще
говоря, даст     неожиданные  результаты,   потому  что  даже
указатели на объекты одинакового типа не  обязаны  отличаться
на величину, кратную длине объекта.
    
                       15.5. Операции сдвига
    
    Операции сдвига << и >> группируются слева направо.   Для
обеих операций        проводятся    обычные    арифметические
преобразования их операндов,  каждый из которых  должен  быть
целочисленного типа.    Затем  правый операнд преобразуется к
типу INT; результат имеет тип левого операнда.  Результат  не
определен, если    правый  операнд отрицателен или больше или
равен, чем длина объекта в битах.
    Выражение-сдвига:
                       выражение << выражение
                       выражение >> выражение
 
    Значением выражения E1<<E2 является E1  (интерпретируемое
как комбинация     битов),   сдвинутое  влево  на  E2  битов;
освобождающиеся биты заполняются нулем.  значением  выражения
E1>>E2 является  E1,  сдвинутое вправо на E2 битовых позиций.
Если E1 имеет тип UNSIGNE,  то  сдвиг  вправо  гарантированно
будет логическим (заполнение нулем); в противном случае сдвиг
может быть   (и  так  и  есть  на   PDP-11)    арифметическим
(освобождающиеся биты заполняются копией знакового бита).

     
     
     
     
     
     
     
     
     
     
     
антов.
 
     
     
     
     
     
                                 
     
     
                      15.6. Операции отношения
    
    Операции отношения группируются слева направо,   но  этот
факт не очень полезен; выражение A<B<C не означает того,  что
оно казалось бы должно означать.
    Выражение-отношения:
                       выражение < выражение
                       выражение > выражение
                       выражение <= выражение
                       выражение >= выражение
 
    Операции < (меньше),  > (больше), <= (меньше или равно) и
>= (больше или равно)  все дают 0,  если указанное  отношение
ложно, и    1,   если  оно истинно.  Результат имеет тип ITN.
Выполняются обычные   арифметические  преобразования.   Могут
сравниваться два       указателя;    результат   зависит   от
относительного расположения указываемых объектов  в  адресном
пространстве. Сравнение    указателей переносимо только в том
случае, если  указатели указывают на объекты из одного и того
же массива.
    
                      15.7. Операции равенства
    
    Выражение-равенства:
                       выражение == выражение
                       выражение != выражение
 
    Операции == (равно) и != (не равно) в точности аналогичны
операциям отношения, за исключением того, что они имеют более
низкий уровень старшинства. (Поэтому значение выражения A<B==
C<D равно 1 всякий раз,  когда  выражение  A<B  и  C<D  имеют
одинаковое значение истинности).
    Указатель можно  сравнивать  с целым,  но результат будет
машиннонезависимым только в том случае,  если целым  является
константа 0. Гарантируется, что указатель, которому присвоено
значение 0,  не указывает ни на какой объект и на самом  деле
оказывается равным   0;  общепринято  считать такой указатель
нулем.
    
                    15.8. Побитовая операция 'и'
    
    Выражение-и:
                        выражение & выражение
 
    Операция &  является  ассоциативной,   и   включающие   &
выражения могут   быть  переупорядочены.  Выполняются обычные
арифметические преобразования; результатом является побитовая
функция 'и'   операндов.   Эта  операция  применима  только к
операндам целочисленного типа.
    
            15.9. Побитовая операция исключающего 'или'
    
    Выражение-исключающего-или:
                        выражение ^ выражение
 
    Операция ^  является  ассоциативной,   и   включающие   ^
выражения могут   быть  переупорядочены.  выполняются обычные
арифметические преобразования; результатом является побитовая
функция исключающего   'или'  операндов.   Операция применима
только к операндам целочисленного типа.
    
            15.10. Побитовая операция включающего 'или'
    
    Выражение-включающего-или:
                       выражение \! Выражение
 
    Операция \!  Является  ассоциативной,   и  содержащие  \!
Выражения могут   быть  переупорядочены.  выполняются обычные
арифметические преобразования; результатом является побитовая
функция включающего   'или'  операндов.   Операция  применима
только к операндам целочисленного типа.
    
                   15.11. Логическая операция 'и'
    
    Выражение-логического-и:
                       выражение && выражение
 
    Операция && группируется слева направо. Она возвращает 1,
если оба ее операнда отличны от нуля, и 0 в противном случае.
В отличие от  &  операция  &&  гарантирует  вычисление  слева
направо; более того, если первый операнд равен 0, то значение
второго операнда вообще не вычисляется.
    Операнды не  обязаны быть одинакового типа,  но каждый из
них должен   быть  либо  одного  из  основных  типов,    либо
указателем. результат всегда имеет тип ITN.
    
                 15.12. Операция логического 'или'
    
    Выражение-логического-или:
                      выражение \!\! выражение
 
    Операция \!\!  Группируется слева направо. Она возвращает
1, если   один из операндов отличен от нуля,  и 0 в противном
случае. В  отличие от операции \!  Операция \!\!  Гарантирует
вычисление слева   направо;  более того,  если первый операнд
отличен от нуля,  то  значение  второго  операнда  вообще  не
вычисляется.
    Операнды не  обязаны быть одинакового типа,  но каждый из
них должен   быть  либо  одного  из  основных  типов,    либо
указателем. Результат всегда имеет тип INT.
    
                      15.13. Условная операция
    
    Условное-выражение:
                  выражение ? выражение : выражение
 
    Условные выражения    группируются     слево     направо.
Вычисляется значение первого выражения, и если оно отлично от
нуля, то  результатом будет  значение  второго  выражения;  в
противном случае     результатом   будет   значение  третьего
выражения. Если      это   возможно,    проводятся    обычные
арифметические преобразования, с тем, чтобы привести второе и
третье выражения к общему типу; в противном случае,  если оба
выражения являются указателями одинакового типа, то результат
имеет тот же тип; в противном случае  одно  выражение  должно
быть указателем,  а другое - константой 0,  и результат будет
иметь тип указателя.  Вычисляется только одно  из  второго  и
третьего выражений.
    
                    15.14. Операция присваивания
    
    Имеется ряд  операций  присваивания,   каждая  из которых
группируется слева направо.  Все операции требуют в  качестве
своего левого     операнда  L-значение,   а  типом  выражения
присваивания является тип  его  левого  операнда.   Значением
выражения присваивания   является значение,  хранимое в левом
операнде после того,  как присваивание уже будет произведено.
Две части составной операции присваивания являются отдельными
лексемами.
    Выражение-присваивания:
                       L-значение = выражение
                       L-значение += выражение
                       L-значение -= выражение
                       L-значение *= выражение
                       L-значение /= выражение
                       L-значение %= выражение
                       L-значение >>= выражение
                       L-значение <<= выражение
                       L-значение &= выражение
                       L-значение ^= выражение
                       L-значение \!= выражение
 
    Когда производится  простое  присваивание C'=',  значение
выражения заменяет значение объекта,   на  которое  ссылается
L-значение. Если   оба операнда имеют арифметический тип,  то
перед присваиванием   правый  операнд  преобразуется  к  типу
левого операнда.
    О свойствах  выражения вида E1 оп = E2,  где Oп - одна из
перечисленных выше  операций,   можно  сделать  вывод,   если
учесть, что    оно  эквивалентно  выражению  E1 = E1 оп (E2);
однако выражение E1 вычисляется только один  раз.   В  случае
операций += и -= левый операнд может быть указателем,  причем
при этом (целочисленный)  правый операнд преобразуется  таким
образом, как  объяснено в п.  15.4; все правые операнды и все
отличные от    указателей   левые   операнды   должны   иметь
арифметический тип.
    Используемые в  настоящее  время  компиляторы   допускают
присваивание указателя  целому,  целого указателю и указателя
указателю другого типа.  такое присваивание  является  чистым
копированием без       каких-либо    преобразований.    Такое
употребление операций присваивания является  непереносимым  и
может приводить   к  указателям,   которые  при использовании
вызывают ошибки адресации.  Тем не менее гарантируется,   что
присваивание указателю   константы  0 дает нулевой указатель,
который можно отличать от указателя на любой объект.
    
                      15.15. Операция запятая
    
    Выражение-с-запятой:
                        выражение , выражение
 
    Пара выражений,  разделенных запятой,  вычисляется  слева
направо и   значение левого выражения отбрасывается.  Типом и
значением результата   является  тип   и   значение   правого
операнда. Эта     операция  группируется  слева  направо.   В
контексте, где  запятая  имеет  специальное  значение,   как,
например, в  списке фактических аргументов функций (п.  15.1)
Или в списках инициализаторов (п.  16.6),  Операция  запятая,
описываемая в этом разделе, может появляться только в круглых
скобках; например, функция
 
                          F(A,(T=3,T+2),C)
 
имеет три аргумента, второй из которых имеет значение 5.

     
     
     
     
     
     
     
     
     
     
     
                                                                                                                                                                                                                                                    
     
     
                            16. Описания
    
    Описания используются для указания интерпретации, которую
язык "C"   будет  давать  каждому  идентификатору;   они   не
обязательно резервируют          память,      соответствующую
идентификатору. Описания имеют форму
                      Описание:
                    спецификаторы-описания список-описателей
                               необ;
 
    Описатели в  списке   описателей   содержат   описываемые
идентификаторы. Спецификаторы    описания  представляют собой
последовательность спецификаторов   типа   и   спецификаторов
класса памяти.
    Спецификаторы-описания:
                 спецификатор-типа спецификаторы-описания
                      необ
             спецификатор-класса-памяти спецификатор-описания
                     необ
 
список должен  быть  самосогласованным в смысле,  описываемом
    ниже.
    
                  16.1. Спецификаторы класса памяти
    
    Ниже перечисляются спецификаторы класса памяти:
                      Спецификатор-класса-памяти:
                           AUTO
                           STATIC
                           EXTERN
                           REGISTER
                           TYPEDEF
 
    Спецификатор TYPEDEF  не  реализует  памяти  и называется
"спецификатором класса   памяти"  только  по   синтаксическим
соображениям; это   обсуждается  в п.  16.8.  Смысл различных
классов памяти был обсужден в п. 12.
    Описания AUTO,  STATIC и REGISTER служат также в качестве
определений в   том  смысле,  что они вызывают резервирование
нужного количества    памяти.    В   случае   EXTERN   должно
присутствовать внешнее   определение  (п.   18)   Указываемых
идентификаторов где-то вне функции, в которой они описаны.
    Описание REGISTER   лучше  всего  представлять  себе  как
описание AUTO вместе с намеком  компилятору,   что  описанные
таким образом     переменные   будут   часто  использоваться.
Эффективны только несколько  первых  таких  описаний.   Кроме
того, в      регистрах   могут  храниться  только  переменные
определенных типов; на PDP-11 это INT,  CHAR  или  указатель.
Существует и  другое ограничение на использование регистровых
переменных: к  ним нельзя применять операцию взятия адреса &.
При разумном использовании регистровых описаний можно ожидать
получения меньших по размеру и более  быстрых  программ,   но
улучшение в   будущем  генерирования  кодов  может сделать их
ненужными.
    Описание может  содержать  не  более одного спецификатора
класса памяти. Если описание не содержит спецификатора класса
памяти, то    считается,   что  он имеет значение AUTO,  если
описание находится внутри  некоторой  функции,   и  EXTERN  в
противном случае.    исключение:   функции  никогда не бывает
автоматическими.
    
                      16.2. Спецификаторы типа
    
    Ниже перечисляются спецификаторы типа.
    Спецификатор-типа:
                        CHAR
                        SHORT
                        INT
                        LONG
                        UNSIGNED
                        FLOAT
                        DOUBLE
                     спецификатор-структуры-или-объединения
                     определяющее-тип-имя
 
    Слова LONG,   SHORT  и  USIGNED  можно  рассматривать как
прилагательные; допустимы следующие комбинации:
 
                                SHORT INT
                                LONG INT
                                USIGNED INT
                                LONG FLOAT
 
    Последняя комбинация  означает  то  же,  что и DOUBLE.  В
остальном описание    может   содержать   не   более   одного
спецификатора типа.   Если описание не содержит спецификатора
типа, то считается, что он имеет значение INT.
    Спецификаторы структур  и  объединений  обсуждаются  в п.
16.5; Описания    с   определяющими   тип   именами   TYPEDEF
обсуждаются в п. 16.8.
    
                          16.3. Описатели
    
    Входящий в описание список описателей представляет  собой
последовательность разделенных запятыми описателей, каждый из
которых может иметь инициализатор.
    Список-описателей:
                     инициализируемый-описатель
             инициализируемый-описатель, список-описателей
                      инициализируемый-описатель:
                     описатель-инициализатор
                        необ
 
    Инициализаторы описываются в п.  16.6.   Спецификаторы  и
описания указывают   тип и класс памяти объектов,  на которые
ссылаются описатели. Описатели имеют следующий синтаксис:
 
                       описатель:
                       идентификатор
                       ( описатель )
                       * описатель
                       описатель ()
                       описатель [константное-выражение
                               необ]
 
    Группирование такое же как и в выражениях.
    
                       16.4. Смысл описателей
    
    Каждый описатель рассматривается  как  утверждение  того,
что когда   конструкция той же самой формы,  что и описатель,
появляется в выражении,  то она выдает объект указанного типа
и указанного  класса памяти.  Каждый описатель содержит ровно
один идентификатор; это именно тот идентификатор,  который  и
описывается.
    Если в     качестве     описателя    появляется    просто
идентификатор, то он имеет тип, указываемый в специфицирующем
заголовке описания.
    Описатель в   круглых  скобках  идентичен  описателю  без
круглых скобок,  но круглые скобки  могут  изменять  связи  в
составных описателях. Примеры смотри ниже.
    Представим себе описание
 
                              T     DI
 
где T - спецификатор типа (подобный INT  и  т.д.),   а  DI  -
описатель. Предположим, что это описание приводит к тому, что
соответствующий идентификатор имеет тип  "...T",   где  "..."
пусто, если  DI просто отдельный идентификатор (так что тип X
в "INT X" просто INT). Тогда , если DI имеет форму
 
                                 *D
 
то содержащийся идентификатор будет иметь тип "...  Указатель
    на T". Если DI имеет форму
 
                                 D()
 
то содержащийся   идентификатор   имеет  тип  "...   Функция,
    возвращающая T". Если DI имеет форму
 
                      D[константное-выражение]
 
или
 
                                D[ ]
 
то содержащийся идентификатор имеет  тип  "...массив  T".   В
первом случае   константным  выражением  является  выражение,
значение которого можно  определить  во  время  компиляции  и
которое имеет   тип  INT.   (Точное  определение константного
выражения дано в п.  23).  Когда несколько спецификаций  вида
"массив из"     оказываются   примыкающими,    то   создается
многомерный массив; константное выражение,  задающее  границы
массивов, может    отсутствовать  только у первого члена этой
последовательности. Такое  опускание полезно,   когда  массив
является внешним   и  его  фактическое  определение,  которое
выделяет память,    приводится  в   другом   месте.    Первое
константное выражение  может быть опущено также тогда,  когда
за описателем следует инициализация.  В  этом  случае  размер
определяется по числу приведенных инициализируемых элементов.
    Массив может  быть  образован  из  элементов  одного   из
основных типов,   из указателей,  из структур или объединений
или из других массивов (чтобы образовать многомерный массив).
    Не все  возможности,   которые  разрешены  с точки зрения
указанного выше синтаксиса,  фактически  допустимы.   Имеются
следующие ограничения:   функции не могут возвращать массивы,
структуры, объединения или функции, хотя они могут возвращать
указатели на такие вещи; не существует массивов функций, хотя
могут быть   массивы  указателей  на  функции.    Аналогично,
структуры или объединения не могут содержать функцию,  но они
могут содержать указатель на функцию.
    В качестве примера рассмотрим описание
 
                 INT I, *IP, F(), *FIP(), (*PFI)();
 
в котором описывается целое I, указатель IP на целое, функция
F, возвращающая целое, функция FIP, возвращающая указатель на
целое, и  указатель PFI на функцию, которая возвращает целое.
Особенно полезно   сравнить два последних описателя.  Связь в
*FIP() можно  представить в виде *(FIP()),  так что описанием
предполагается, а такой же конструкцией в выражении требуется
обращение к функции FIP и последующее использование косвенной
адресации для     выдачи  с  помощью  полученного  результата
(указателя) целого.   В  описателе  (*PFI)()   дополнительные
скобки необходимы,    поскольку  они  точно  так же,  как и в
выражении, указывают, что косвенная адресация через указатель
на функцию   выдает  функцию,   которая затем вызывается; эта
вызванная функция возвращает целое.
    В качестве другого примера приведем описание
 
                       FLOAT FA[17], *AFP[17];
 
в котором  описывается  массив  чисел  типа  FLOAT  и  массив
указателей на числа типа FLOAT. Наконец,
 
                      STATIC INT X3D[3][5][7];
 
описывает статический трехмерный массив целых размером 3*5*7.
более подробно,    X3D  является  массивом из трех элементов;
каждый элемент   является  массивом  пяти  массивов;   каждый
последний массив  является массивом из семи целых.  Каждое из
выражений X3D,    X3D[I],   X3D[I][J]  и  X3D[I][J][K]  может
разумным образом   появляться в выражениях.  Первые три имеют
тип "массив", последнее имеет тип INT.

     
     
     
     
     
     
                                                                                                                
     
     
               16.5. Описание структур и объединений
    
    Структура -  это объект,  состоящий из последовательности
именованных членов.  каждый  член  может  быть  произвольного
типа. Объединение - это объект, который в данный момент может
содержать любой   из  нескольких  членов.   Спецификаторы   и
объединения имеют одинаковую форму.
    Спецификатор-структуры-или-объединения
 
   структура-или-объединение \( список-описаний-структуры\)
      
      идентификатор    структуры-или-объединения
      \(список-описаний-структуры\)
      идентификатор структуры-или-объединения
      
      Структура-или-объединение:
      
         STRUCT
         UNION
 
    Список-описаний-структуры является    последовательностью
описаний членов структуры или объединения:
 
    Список-описаний-структуры:
              описание-структуры
              описание-структуры список-описаний-структуры
               описание-структуры:
              спецификатор-типа список-описателей-структуры
               список-описателей-структуры:
              описатель-структуры
            описатель-структуры, список-описателей-структуры
 
    В обычном  случае  описатель  структуры  является  просто
описателем члена   структуры или объединения.  Член структуры
может также состоять из специфицированного числа битов. Такой
член называется   также  полем; его длина отделяется от имени
поля двоеточием.
 
    Описатель-структуры:
               описатель
               описатель: константное выражение
               : константное выражение
 
    Внутри структуры описанные в ней  объекты  имеют  адреса,
которые увеличиваются   в  соответствии с чтением их описаний
слева направо.  Каждый член структуры,  который  не  является
полем, начинается    с адресной границы,  соответствующей его
типу; следовательно в структуре могут оказаться неименованные
дыры. Члены,  являющиеся полями, помещаются в машинные целые;
они не перекрывают границы слова.  Поле, которое не умещается
в оставшемся   в  данном  слове  пространстве,   помещается в
следующее слово.  Поля выделяются справа налево на  PDP-11  и
слева направо на других машинах.
    Описатель структуры,   который  не содержит описателя,  а
только двоеточие и  ширину,   указывает  неименованное  поле,
полезное для   заполнения  свободного  пространства  с  целью
соответствия задаваемых  извне  схемам.   Специальный  случай
неименованного поля   с шириной 0 используется для указания о
выравнивании следующего поля  на  границу  слова.   При  этом
предполагается, что   "следующее поле" действиетльно является
полем, а  не обычным членом структуры,  поскольку в последнем
случае выравнивание осуществляется автоматически.
    Сам язык  не  накладывает  ограничений  на типы объектов,
описанных как   поля,   но   от   реализаций   не   требуется
обеспечивать что-либо   отличное от целых полей.  Более того,
даже поля типа INT могут рассматриваться как неимеющие знака.
На PDP-11  поля не имеют знака и могут принимать только целые
значения. Во  всех реализациях отсутствуют массивы полей и  к
полям не   применима  операция  взятия  адреса &,  так что не
существует и указателей на поля.
    Объединение можно представить себе  как  структуру,   все
члены которой   начинаются  со  смещения  0  и размер которой
достаточен, чтобы  содержать любой из ее  членов.   В  каждый
момент объединение   может содержать не более одного из своих
членов.
    Спецификатор структуры  или  объединения во второй форме,
т.е. Один из
 
         STRUCT идентификатор \(список-описаний-структуры\)
 
         UNION идентификатор \(список-описаний-структуры\)
 
описывает идентификатор  в  качестве  ярлыка  структуры  (или
ярлыка объединения)    структуры,    специфицированной   этим
списком. Последующее описание может затем использовать третью
форму спецификатора, один из
 
                        STRUCT идентификатор
 
                        UNION идентификатор
 
    Ярлыки структур  дают  возможность  определения структур,
которые ссылаются   на  самих  себя;  они   также   позволяют
неоднократно использовать приведенную только один раз длинную
часть описания.     Запрещается   описывать   структуру   или
объединение, которые    содержат  образец  самого  себя,   но
структура или   объединение  могут  содержать  указатель   на
структуру или объединение такого же вида, как они сами.
    Имена членов  и ярлыков могут совпадать с именами обычных
переменных. Однако имена ярлыков и членов должны быть взаимно
различными.
    Две структуры     могут     иметь     общую     начальную
последовательность членов; это означает,  что  тот  же  самый
член может   появиться  в двух различных структурах,  если он
имеет одинаковый тип в обеих структурах и если все предыдущие
члены обеих структур одинаковы. (Фактически компилятор только
проверяет, что    имя  в  двух  различных  структурах   имеет
одинаковый тип и одинаковое смещение,  но если предшествующие
члены отличаются,  то конструкция оказывается непереносимой).
    Вот простой пример описания структуры:
 
                           STRUCT TNODE \(
                           CHAR TWORD[20];
                           INT COUNT;
                           STRUCT TNODE *LEFT;
                           STRUCT TNODE *RIGHT;
                           \);
    Такая структура содержит массив из 20 символов,  целое  и
два указателя   на  подобные структуры.  Как только приведено
такое описание, описание
 
                        STRUCT TNODE S, *SP;
 
говорит о том,  что S является структурой указанного вида,  а
SP является   указателем  на  структуру указанного вида.  При
наличии этих описаний выражение
 
                              SP->COUNT
 
ссылается к полю COUNT структуры,  на которую  указывает  SP;
 выражение
 
                               S.LEFT
 
ссылается на указатель левого поддерева  в  структуре  S,   а
 выражение
 
                          S.RIGHT->TWORD[0]
 
ссылается на первый символ члена TWORD правого  поддерева  из
    S.
    
                         16.6. Инициализация
    
    Описатель может указывать начальное значение описываемого
идентификатора. Инициализатор     состоит  из  выражения  или
заключенного в   фигурные  скобки  списка  значений,    перед
которыми ставится знак =.
    Инициализатор:
                       = выражение
                       = \(список-инициализатора\)
                       = \(список-инициализатора,\)
                       список-инициализатора:
                       выражение
                 список-инициализатора,список-инициализатора
                       \(список-инициализатора\)
 
    Все выражения,  входящие в инициализатор статической  или
внешней переменной,       должны   быть   либо   константными
выражениями, описываемыми  в п. 23, Либо выражениями, которые
сводятся к   адресу  ранее  описанной  переменной,   возможно
смещенному на   константное  выражение.    Автоматические   и
регистровые переменные       могут    быть   инициализированы
произвольными выражениями,    включающие  константы  и  ранее
описанные переменные и функции.
     Гарантируется, что  неинициализированные  статические  и
внешние переменные получают в качестве начальных значений  0;
неинициализированные автоматические  и регистровые переменные
в качестве начальных значений содержат мусор.
     Когда инициализатор  применяется  к  скаляру ( указателю
или обьекту арифметического типа),  то он состоит  из  одного
выражения, возможно заключенного в фигурные скобки. Начальное
значение объекта находится из выражения;  выполняются  те  же
самые преобразования, что и при присваивании.
    Когда описываемая     переменная    является    агрегатом
(структурой или массивом  ),   то  инициализатор  состоит  из
заключенного в фигурные скобки и разделенного запятыми списка
инициализаторов для членов агрегата. Этот список составляется
в порядке   возрастания индекса или в соответствии с порядком
членов. Если  агрегат содержит подагрегаты,  то  это  правило
применяется рекурсивно   к  членам агрегата.  Если количество
инициализаторов в  списке  оказывается  меньше  числа  членов
агрегата, то    оставшиеся члены агрегата заполняются нулями.
Запрещается инициализировать объединения  или  автоматические
агрегаты.
    Фигурные скобки могут  быть  опущены  следующим  образом.
Если инициализатор   начинается  с левой фигурной скобки,  то
последующий разделенный   запятыми   список   инициализаторов
инициализирует члены  агрегата; будет ошибкой,  если в списке
окажется больше инициализаторов,  чем членов агрегата.   Если
однако инициализатор   не начинается с левой фигурной скобки,
то из   списка  берется  только  нужное  для  членов  данного
агрегата число   элементов;  оставшиеся элементы используются
для инициализации следующего члена агрегата,  частью которого
является настоящий агрегат.
    Последнее сокращение допускает возможность  инициализации
массива типа   CHAR  с  помощью  строки.  В этом случае члены
массива последовательно  инициализируются  символами  строки.
Например,
 
                        INT X[] = \(1,3,5\);
 
описывает и инициализирует X как одномерный массив; поскольку
размер массива   не  специфицирован,  а список инициализитора
содержит три элемента,  считается, что массив состоит из трех
членов.
Вот пример инициализации  с  полным  использованием  фигурных
скобок:
 
                         FLOAT *Y[4][3] = \(
                            ( 1, 3, 5 ),
                            ( 2, 4, 6 ),
                            ( 3, 5, 7 ),
                         \);
 
    Здесь 1, 3 и 5 инициализируют первую строку массива Y[0],
а именно Y[0][0],  Y[0][1] и  Y[0][2].   Аналогичным  образом
следующие две     строчки   инициализируют   Y[1]   и   Y[2].
Инициализатор заканчивается преждевременно,  и, следовательно
массив Y[3]   инициализируется  нулями.  В точности такого же
эффекта можно было бы достичь, написав
 
                        FLOAT Y[4][3] = \(
                         1, 3, 5, 2, 4, 6, 3, 5, 7
                        \);
 
    Инициализатор для  Y  начинается с левой фигурной скобки,
но инициализатора  для  Y[0]  нет.   Поэтому  используется  3
элемента из    списка.   Аналогично  следующие  три  элемента
используются последовательно  для  Y[1]  и  Y[2].   Следующее
описание
 
                         FLOAT Y[4][3] = \(
                          (1), (2), (3), (4)
                         \);
 
инициализирует первый столбец Y (если его  рассматривать  как
двумерный массив), а остальные элементы заполняются нулями.
    И наконец, описание
 
              CHAR MSG[] = "SYNTAX ERROR ON LINE %S\N";
 
демонстрирует инициализацию элементов символьного  массива  с
помощью строки.
    
                         16.7. Имена типов
    
    В двух случаях (для явного указания типа преобразования в
конструкции перевода   и  для  аргументов  операции   SIZEOF)
желательно иметь   возможность задавать имя типа данных.  Это
осуществляется с помощью "имени типа",  которое  по  существу
является описанием   объекта такого типа ,  в котором опущено
имя самого объекта.
    Имя типа:
                   спецификатор-типа абстрактный-описатель
                     абстрактный-описатель:
                   пусто
                   (абстрактный-описатель)
                   * абстрактный описатель
                   абстрактный-описатель ()
                абстрактный-описатель [константное выражение
                         необ]
 
    Во избежании двусмысленности в конструкции
 
                       (абстрактный описатель)
 
требуется, чтобы абстрактный-описатель был непуст.  При  этом
ограничении возможно    однозначено  определить  то  место  в
абстрактном-описателе, где бы появился идентификатор, если бы
эта конструкция  была описателем в описании.  Именованный тип
совпадает тогда   с  типом  гипотетического   идентификатора.
Например, имена типов
 
                            INT
                            INT *
                            INT *[3]
                            INT (*)[3]
                            INT *()
                            INT (*)()
 
именуют соответственно  типы  "целый",  "указатель на целое",
"массив из трех указателей на целое", "указатель на массив из
трех целых",   " функция,  возвращающая указатель на целое" и
"указатель на функцию, возвращающую целое".
    
                           16.8. TYPEDEF
    
    Описания, в  которых  "класс  памяти"специфицирован   как
TYPEDEF, не    вызывают  выделения  памяти.  вместо этого они
определяют идентификаторы ,которые позднее можно использовать
так, словно они являются ключевыми словами, имеющими основные
или производные типы.
    Определяющее-тип-имя
                            идентификатор
 
    В пределах  области  действия  описания со спецификатором
TYPEDEF каждый   идентификатор,   являющийся  частью   любого
описателя в     этом   описании,    становится  синтаксически
эквивалентным ключевому слову,  имеющему тот тип  ,   который
ассоциирует с  идентификатором в описанном в п.  16.4 Смысле.
Например, после описаний
 
             TYPEDEF INT MILES, >KLICKSP;
             TYPEDEF STRUCT ( DOUBLE RE, IM; ) COMPLEX;
 
конструкции
 
                         MILES DISTANCE;
                         EXTERN KLICKSP METRICP;
                         COMPLEX Z, *ZP;
 
становятся законными  описаниями;  при  этом  типом  DISTANCE
является INT,  типом METRICP - "указатель на INT",  типом Z -
специфицированная структура и типом ZP - указатель  на  такую
структуру.
    Спецификатор TYPEDEF   не  вводит  каких-либо  совершенно
новых типов,  а только определяет синонимы для типов, которые
можно было   бы  специфицировать  и  другим  способом.  Так в
приведенном выше   примере  переменная   DISTANCE   считается
имеющей точно   такой  же  тип,   что  и любой другой объект,
описанный в INT.

     
     
     
     
     
     
     
                                                                                                                                                                                        
     
     
                  17. Операторы
    
    За исключением  особо  оговариваемых  случаев,  операторы
выполняются последовательно.
    
                    17.1. Операторное выражение
    
    Большинство операторов являются операторными выражениями,
которые имеют форму
 
                             выражение;
 
    обычно операторные  выражения являются присваиваниями или
обращениями к функциям.
    
                17.2. Составной оператор (или блок)
    
    С тем   чтобы   допустить    возможность    использования
нескольких операторов  там,  где ожидается присутствие только
одного, предусматривается составной оператор (который также и
эквивалентно называют "блоком"):
 
               составной оператор:
               \(список-описаний    список-операторов
                                         необ  необ\)
                 список-описаний:
                описание
                описание список-описаний
                 список-операторов:
                оператор
                оператор список-операторов
 
    Если какой-либо  идентификатор  из  списка-описаний   был
описан ранее,   то во время выполнения блока внешнее описание
подавляется и снова вступает в силу после выхода из блока.
    Любая инициализация   автоматических   и  регистрационных
переменных проводится при  каждом  входе  в  блок  через  его
начало. В     настоящее  время  разрешается  (но  это  плохая
практика) передавать  управление внутрь блока; в таком случае
эти инициализации  не выполняются.  Инициализации статических
переменных проводятся  только  один  раз,   когда  начинается
выполнение программы.
    Находящиеся внутри  блока внешние описания не резервируют
памяти, так что их инициализация не разрешается.
    
                      17.3. Условные операторы
    
    Имеются две формы условных операторов:
 
                    IF (выражение) оператор
                    IF (выражение) оператор ELSE оператор
 
    В обоих случаях вычасляется выражение и, если оно отлично
от нуля, то выполняется первый подоператор. Во втором случае,
если выражение   равно нулю,  выпалняется второй подоператор.
Как обычно,  двусмысленность "ELSE" разрешается  связываением
ELSE с последним встречающимся IF, у которого нет ELSE.
    
                        17.4. Оператор WHILE
    
    Оператор WHILE имеет форму
 
                     WHILE (выражение) оператор
 
    Подоператор выполняется   повторно   до  тех  пор,   пока
значение выражения   остается  отличным  от  нуля.   проверка
производится перед каждым выполнением оператора.
    
                         17.5. Оператор DO
    
    Оператор DO имеет форму
 
                    DO оператор WHILE (выражения)
 
    Оператор выполняется  повторно до тех пор,  пока значение
выражения не станет равным нулю.  Проверка производится после
каждого выполнения оператора.
    
                         17.6. Оператор FOR
    
    Оператор FOR имеет форму
 
        (выражение-1  ; выражение-2 ; выражение-3  )оператор
                 необ          необ          необ
 
    Оператор FOR эквивалентен следующему
 
                       выражение-1;
                          WHILE   (выражение-2) \(
                             оператор
                             выражение-3
                       \)
 
    Таким образом,  первое выражение определяет инициализацию
цикла; второе   специфиуирует  проверку,   выполняемую  перед
каждой итерацией,  так что выход из цикла  происходит  тогда,
когда значение   выражения становится нулем; третье выражение
часто задает приращение параметра,  которое проводится  после
каждой итерации.
    Любое выражение или даже все они могут быть опущены. Если
отсутствует второе   выражение,   то  предложение   с   WHILE
считается эквивалентным     WHILE(1);   другие  отсутствующие
выражения просто опускаются из приведенного выше  расширения.
    
                       17.7. Оператор SWITCH
    
    Оператор SWITCH   (переключатель),    вызывает   передачу
управления к  одному из нескольких операторов,  в зависимости
от значения выражения. Оператор имеет форму
 
                     SWITCH (выражение) оператор
 
    В выражении     проводятся     обычные     арифметические
преобразования, но  результат должен иметь тип INT.  Оператор
обычно является   составным.   Любой  оператор  внутри  этого
оператора может   быть  помечен  одним  или  более вариантным
префиксом CASE, имеющим форму:
 
                    CASE констанстное выражение:
 
где константное  выражение должно иметь тип INT.  Никакие две
вариантные константы в одном и том же переключателе не  могут
иметь одинаковое   значение.  точное определение константного
выражения приводится в п. 23.
    Кроме того,   может  присутствовать  самое  большее  один
операторный префикс вида
     
                              DEFAULT:
 
    При выполнении оператора SWITCH  вычисляется  входящее  в
него выражение и сравнивается с каждой вариантной константой.
Если одна из вариантных констант оказывается равной  значению
этого выражения,  то управление передается оператору, который
следует за совпадающим вариантным префиксом.  Если ни одна из
вариантных констант   не  совпадает  со значением выражения и
если при этом присутствует префикс  DEFAULT,   то  управление
передается оператору,    помеченному этим префиксом.  если ни
один из вариантов не подходит и префикс DEFAULT  отсутствует,
то ни один из операторов в переключателе не выполняется.
    Сами по  себе  префиксы  CASE и DEFAULT не изменяют поток
управления, которое   беспрепятсвенно  проходит  через  такие
префиксы. Для    выхода  из  переключателя  смотрите оператор
BREAK, п. 17.8.
    Обычно оператор, который входит в переключатель, является
составным. Описания      могут   появляться  в  начале  этого
оператора, но   инициализации  автоматических  и  регистровых
переменных будут неэффективными.
    
                        17.8. Оператор BREAK
    
    Оператор
 
                               BREAK;
 
вызывает завершение выполнения наименьшего охватывающего этот
оператор оператора   WHILE,   DO,  FOR или SWITCH; управление
передается оператору, следующему за завершенным оператором.
    
                      17.9. Оператор CONTINUE
 
    Оператор
 
                              CONTINUE;
 
приводит к передаче управления  на  продолжающую  цикл  часть
наименьшего охватывающего  этот оператор оператора WHILE,  DO
или FOR; то есть на конец цикла.  Более точно,  в  каждом  из
операторов
 
  WHILE(...) \(          DO \(             FOR(...) \(
              ...             ...                    ...
              CONTIN: ;       CONTIN: ;             CONTIN: ;
             \)              \) WHILE(...);          \)
 
    Оператор CONTINUE эквивалентен оператору GOTO CONTIN. (За
CONTIN: следует пустой оператор; см. П. 17.13.).
    
                      17.10. Оператор возврата
    
    Возвращение из    функции    в    вызывающую    программу
осуществляется с помощью оператора RETURN, который имеет одну
из следующих форм
 
                            RETURN;
                            RETURN выражение;
 
    В первом случае возвращаемое значение  неопределено.   Во
втором случае   в  вызывающую  функцию  возвращается значение
выражения. Если  требуется,  выражение преобразуется  к  типу
функции, в которой оно появляется, как в случае присваивания.
Попадание на   конец  функции   эквивалентно   возврату   без
возвращаемого значения.
    
                        17.11. Оператор GOTO
    
    Управление можно   передавать   безусловно   с    помощью
 оператора
 
                         GOTO идентификатор1
 
идентификатор должен быть меткой (п.  9.12), Локализованной в
данной функции.
    
                     17.12. Помеченный оператор
    
    Перед любым  оператором  может  стоять помеченный префикс
                           вида идентификатор:
 
который служит для описания идентификатора в качестве  метки.
Метки используются только для указания места, куда передается
управление оператором GOTO.  Областью действия метки является
данная функция, за исключением любых подблоков, в которых тот
же идентификатор описан снова. Смотри п. 19.
    
                       17.13. Пустой оператор
    
    Пустой оператор имеет форму:
     
                                  ;
 
    Пустой оператор  оказывается  полезным,    так   как   он
позволяет поставить    метку  перед  закрывающей  скобкой  \)
составного оператора или указать  пустое  тело  в  операторах
цикла, таких как WHILE.
   
     
     
     
     
     
     
--------------------------------------

     
     
     






спользовать     содержащуюся   в   описаниях  TYPEDEF
информацию для проведения некоторой  дополнительной  проверки
программы.

         
     
     
                 18. Внешние определения
    
    C-программа представляет собой последовательность внешних
определений. Внешнее  определение описывает идентификатор как
имеющий класс памяти EXTERN  (по  умолчанию),   или  возможно
STATIC, и  специфицированный тип. Спецификатор типа (п. 16.2)
Также может быть пустым; в этом случае  считается,   что  тип
является типом   INT.   Область  действия внешних определений
распространяется до конца файла,  в  котором  они  приведены,
точно так   же  ,  как влияние описаний простирается до конца
блока. Синтаксис    внешних  определений  не  отличается   от
синтаксиса описаний,  за исключением того, что только на этом
уровне можно приводить текст функций.
    
                 18.1. Внешнее определение функции
    
    Определение функции имеет форму
 
                определение-функции:
                    
                спецификаторы-описания   описатель-функции
                тело-функции
                    необ
 
    Единственными спецификаторами класса памяти, допускаемыми
в качестве   спецификаторов-описания,   являются  EXTERN  или
STATIC; о   различии  между  ними смотри п.  19.2.  Описатель
функции подобен описателю для "функции,  возвращающей...", за
исключением того,    что  он перечисляет формальные параметры
определяемой функции.
    Описатель-функции:
                    описатель (список-параметров
                            необ)
                     список параметров:
                     идентификатор
                     идентификатор, список-параметров
 
тело-функции имеет форму
 
                      тело-функции:
                     список-описаний составной-оператор
 
    Идентификаторы из списка параметров и  только  они  могут
быть описаны   в  списке описаний.  Любой идентификатор,  тип
которого не указан,  считается имеющим тип INT.  Единственным
допустимым здесь     спецификатором  класса  памяти  является
REGISTER; если такой класс памяти специфицирован, то в начале
выполнения функции     соответствующий  фактический  параметр
копируется, если это возможно, в регистр.
    Вот простой пример полного определения функции:
 
                          INT MAX(A, B, C)
                          INT A, B, C;
                          \(
                         INT M;
                         M = (A>B) ? A:B;
                         RETURN((M>C) ? M:C);
                          \)
 
    Здесь INT    -    спецификатор-типа,     MAX(A,B,C)     -
описатель-функции, INT    A,B,C; - список-описаний формальных
параметров, \( ... \) - Блок, содержащий текст оператора.
    В языке   "C"   все   фактические  параметры  типа  FLOAT
преобразуются к типу DOUBLE,   так  что  описания  формальных
параметров, объявленных    как FLOAT,  приспособлены прочесть
параметры типа DOUBLE. Аналогично, поскольку ссылка на массив
в любом   контексте  (в  частности  в  фактическом параметре)
рассматривается как  указатель  на  первый  элемент  массива,
описания формальных       параметров    вила   "массив   ..."
приспособлены прочесть :  "указатель  на  ...".   И  наконец,
поскольку структуры,    объединения  и  функции не могут быть
переданы функции,  бессмысленно описывать формальный параметр
как структуру,    объединение или функцию (указатели на такие
объекты, конечно, допускаются).
    
            18.2. Внешние определения данных
    
    Внешнее определение данных имеет форму
 
    определение-данных:
                              описание
 
    Классом памяти   таких   данных   может  быть  EXTERN  (в
частности, по умолчанию) или STATIC, но не AUTO или REGISTER.

     
     
     
     
     
     
скобках. Синтаксис суммируется в пункте 18.
   
     
     
     
     
     
     

 
                   
     
         19. Правила, определяющие область действия
    
    Вся C-программа необязательно компилируется одновременно;
исходный текст  программы может храниться в нескольких файлах
и ранее   скомпилированные  процедуры  могут  загружаться  из
библиотек. Связь    между  функциями может осуществляться как
через явные обращения,  так и в результате манипулирования  с
внешними данными.
    Поэтому следует  рассмотреть  два вида областей действия:
    во-первых, ту,  которая может  быть  названа  лексической
    областью
действия идентификатора и которая по  существу  является  той
областью в     программе,    где   этот  идентификатор  можно
использовать, не      вызывая   диагностического    сообщения
"неопределенный идентификатор";     и   во-вторых,    область
действия, которая   связана  с  внешними  идентификаторами  и
которая характеризуется правилом, что ссылки на один и тот же
внешний идентификатор являются ссылками  на  один  и  тот  же
объект.
    
            19.1. Лексическая область действия
    
    Лексическая область действия идентификаторов,   описанных
во внешних определениях, простирается от определения до конца
исходного файла,  в котором он находится. Лексическая область
действия идентификаторов, являющихся формальными параметрами,
распространяется на ту функцию,   к  которой  они  относятся.
Лексическая область   действия  идентификаторов,  описанных в
начале блока,  простирается до конца этого блока. Лексической
областью действия   меток является та функция,  в которой они
находятся.
    Поскольку все  обращения  на  один  и  тот   же   внешний
идентификатор обращаются  к одному и тому же объекту (см.  П.
19.2), Компилятор  проверяет все описания одного  и  того  же
внешнего идентификатора  на совместимость; в действительности
их область действия распространяется на весь файл,  в котором
они находятся.
    Во всех  случаях,  однако,  есть некоторый идентификатор,
явным образом описан в начале блока,  включая и блок, который
образует функцию,      то   действие  любого  описания  этого
идентификатора вне блока приостанавливается  до  конца  этого
блока.
    Напомним также    (п.     16.5),    Что   идентификаторы,
соответствующие обычным  переменным,   с  одной  стороны,   и
идентификаторы, соответствующие   членам и ярлыкам структур и
объединений, с другой стороны, формируют два непересекающихся
класса, которые   не вступают в противоречие.  Члены и ярлыки
подчиняются тем   же  самым  правилам  определения   областей
действия, как и другие идентификаторы. Имена, специфицируемые
с помощью TYPEDEF,  входят в тот же  класс,   что  и  обычные
идентификаторы. Они   могут быть переопределены во внутренних
блоках, но  во внутреннем описании  тип  должен  быть  указан
явно:
 
                       TYPEDEF FLOAT DISTANCE;
                                 ...
                       \(
                               AUTO INT DISTANCE;
                                 ...
 
    Во втором   описании   спецификатор   типа   INT   должен
присутствовать, так как в противном случае это описание будет
принято за   описание  без описателей с типом DISTANCE (прим.
Автора: согласитесь, что лед здесь тонок.).
    
      19.2. Область действия внешних идентификаторов
    
    Если функция ссылается на идентификатор,   описанный  как
EXTERN, то    где-то  среди файлов или библиотек,  образующих
полную программу,   должно  содержаться  внешнее  определение
этого идентификатора.  Все функции данной программы,  которые
ссылаются на один и тот же внешний идентификатор,   ссылаются
на один и тот же объект,  так что следует позаботиться, чтобы
специфицированные в   этом  определении  тип  и  размер  были
совместимы с типом и размером, указываемыми в каждой функции,
которая ссылается на эти данные.
    Появление ключевого слова EBTERN во  внешнем  определении
указывает на     то,    что   память   для  описанных  в  нем
идентификаторов будет выделена в другом файле. Следовательно,
в состоящей   из  многих файлов программе внешнее определение
идентификатора, не  содержащее спецификатора EXTERN,   должно
появляться ровно в одном из этих файлов.  любые другие файлы,
которые желают дать внешнее определение этого идентификатора,
должны включать в это определение слово EXTERN. Идентификатор
может быть инициализирован только в  том  описании,   которое
приводит к выделению памяти.
    Идентификаторы, внешнее определение которых начинается со
слова STATIC, недоступны из других файлов. Функции могут быть
описаны как STATIC.

     
     
     
     
     
     
     
кты данного типа;
      структуры, содержащие последовательность объектов
      различных типов;
      объединения, способные содержать один из нескольких
        объектов различных типов.
    Вообще говоря,   эти  ме     
     
     
                 20. Строки управления компилятором
    
    Компилятор языка   "C"  содержит  препроцессор,   который
позволяет осуществлять макроподстановки,  условную компиляцию
и включение   именованных файлов.  Строки,  начинающиеся с #,
общаются с этим  препроцессором.   Синтаксис  этих  строк  не
связан с остальным языком; они могут появляться в любом месте
и их   влияние  распространяется   (независимо   от   области
действия) до конца исходного программного файла.
    
                        20.1. Замена лексем
    
    Управляющая компилятором строка вида
 
                 #DEFINE идентификатор строка-лексем
 
    (Обратите внимание на отсутствие в конце точки с запятой)
приводит к   тому,   что  препроцессор  заменяет  последующие
вхождения этого идентификатора на  указанную  строку  лексем.
Строка вида
 
              #DEFINE        идентификатор
              (идентификатор,...,идентификатор)строка лексем
 
где между  первым  идентификатором  и открывающейся скобкой (
нет пробела,      представляет   собой   макроопределение   с
аргументами. Последующее вхождение первого идентификатора, за
которым следует открывающая скобка  '(',   последовательность
разделенных запятыми     лексем  и  закрывающая  скобка  ')',
заменяются строкой лексем из определения.   каждое  вхождение
идентификатора, упомянутого  в списке формальных параметров в
определении ,  заменяется соответствующей строкой  лексем  из
обращения. Фактическими    аргументами  в  обращении являются
строки лексем, разделенные запятыми; однако запятые, входящие
в закавыченные   строки или заключенные в круглые скобки,  не
разделяют аргументов.  Количество  формальных  и  фактических
параметров должно     совпадать.   Текст  внутри  строки  или
символьной константы не подлежит замене.
    В обоих случаях замененная строка просматривается снова с
целью обнаружения  других  определенных  идентификаторов.   В
обоих случаях   слишком длинная строка определения может быть
продолжена на   другой  строке,   если  поместить   в   конце
продолжаемой строки обратную косую черту \ .
    Описываемая возможность  особенно полезна для определения
"объявляемых констант", как, например,
                #DEFINE TABSIZE 100
                INT TABLE[TABSIZE];
 Управляющая строка вида
               #UNDEF идентификатор
 приводит к   отмене   препроцессорного  определения  данного
    идентификатора.
    
                  20.2. Включение файлов
    
    Строка управления компилятором вида
 
                         #INCLUDE "FILENAME"
 
приводит  к  замене  этой  строки  на  все  содержимое  файла с именем
FILENAME. Файл с этим именем сначала ищется в  справочнике  начального
исходного  файла, а затем в последовательности стандартных мест. В от-
личие от этого управляющая строка вида
 
                         #INCLUDE <FILENAME>
 
ищет файл только в  стандартных  местах  и  не  просматривает
справочник исходного файла.
    Строки #INCLUDE могут быть вложенными.
    
                 20.3. Условная компиляция
    
    Строка управления компилятором вида
 
                      #IF константное выражение
 
проверяет, отлично ли от нуля значение константного выражения
(см. П. 15). Управляющая строка вида
 
                        #IF DEF идентификатор
 
проверяет, определен ли этот идентификатор в настоящий момент
в препроцессоре,  т.е.  Определен  ли  этот  идентификатор  с
помощью управляющей строки #DEFINE.
  
     
     
     
     
     
                          
     
     
                21. Неявные описания
    
    Не всегда  является  необходимым  специфицировать и класс
памяти и   тип  идентификатора  в   описании.    Во   внешних
определениях и   описаниях  формальных  параметров  и  членов
структур класс памяти  определяется  по  контексту.   Если  в
находящемся внутри  функции описании не указан тип,  а только
класс памяти,  то предполагается, что идентификатор имеет тип
INT; если   не  указан  класс  памяти,   а  только  тип,   то
идентификатор предполагается описанным как AUTO.   Исключение
из последнего    правила  дается  для  функций,   потому  что
спецификатор AUTO для функций  является  бессмысленным  (язык
"C" не   в  состоянии  компилировать  программу в стек); если
идентификатор имеет тип "функция,  возвращающая ...",  то  он
предполагается неявно описанным как EXTERN.
    Входящий в выражение и неописанный  ранее  идентификатор,
за которым   следует  скобка  (  ,   считается  описанным  по
контексту как "функция, возвращающая INT".
  
     
     
     
     
     
    
     
     
     
     
     
ной   библиотеке
ввода/вывода "функции"  GETCHAR и PUTCHAR на самом деле могут
быть макросами.  Это позволяет избежать накладных расходов на
обращение к функции      
     
             22. Снова о типах
    
    В  этом  разделе  обобщаются  сведения об операциях, которые можно
применять только к объектам определенных типов.
    
              22.1. Структуры и объединения
    
    Только две   вещи   можно   сделать   со  структурой  или
объединением: назвать  один из их членов (с помощью операции)
или извлечь их адрес ( с помощью унарной операции &).  Другие
операции, такие  как присваивание им или из них и передача их
в качестве   параметров,   приводят к сообщению об ошибке.  В
будущем ожидается, что эти операции, но не обязательно какие-
либо другие, будут разрешены.
    В п.  15.1 Говорится, что при прямой или косвенной ссылке
на структуру (с помощью .  Или ->)  имя  справа  должно  быть
членом структуры,   названной или указанной выражением слева.
Это ограничение не навязывается строго  компилятором,   чтобы
дать возможность   обойти  правила типов.  В действительности
перед '.'     допускается   любое    L-значение    и    затем
предполагается, что это L-значение имеет форму структуры, для
которой стоящее справа имя является членом. Таким же образом,
от выражения,    стоящего  перед '->',  требуется только быть
указателем или целым.  В случае указателя предполагается, что
он указывает   на  структуру,  для которой стоящее справа имя
является членом.  В случае  целого  оно  рассматривается  как
абсолютный адрес    соответствующей  структуры,   заданный  в
единицах машинной памяти.
    Такие структуры не являются переносимыми.
   
 
                    22.2. Функции
    
    Только две вещи можно сделать с функцией:  вызвать ее или
извлечь ее адрес.  Если имя функции входит в выражение  не  в
позиции имени  функции,  соответствующей обращению к ней,  то
генерируется указатель на эту функцию.  Следовательно,  чтобы
передать одну функцию другой, можно написать
 
                              INT F();
                                 ...
                              G(F);
 
    Тогда определение функции G могло бы выглядеть так:
 
                              G(FUNCP)
                              INT(*FUNCP)();
                              \(
                                 ...
                                 (*FUNCP)();
                                 ...
                              \)
 
    Обратите внимание,   что в вызывающей процедуре функция F
должна быть описана явно,  потому что за ее появлением в G(F)
не следует скобка ( .
   
                     
     
         22.3. Массивы, указатели и индексация
    
    Каждый раз,   когда  идентификатор,  имеющий тип массива,
появляется в выражении,   он  преобразуется  в  указатель  на
первый член этого массива. Из-за этого преобразования массивы
не являются L-значениями.  По определению операция индексация
[] интерпретируется   таким  образом,   что  E1[E2] считается
идентичным выражению     *((е1)+(е2)).    Согласно   правилам
преобразований, применяемым при операции +, если E1 - массив,
а е2 - целое,  то е1[е2] ссылается на е2-й член  массива  е1.
Поэтому несмотря   на  несимметричный вид операция индексации
является коммутативной.
    В случае       многомерных      массивов      применяется
последовательное правило.  Если е является N-мерным  массивом
размера I*J*...*K,      то   при   появлении  в  выражении  е
преобразуется в  указатель  на  (N-1)-мерный  массив  размера
J*...*K. Если    операция  *  либо  явно,   либо неявно,  как
результат индексации,  применяется  к  этому  указателю,   то
результатом операции   будет  указанный  (N-1)-мерный массив,
который сам немедленно преобразуется в указатель.
    Рассмотрим, например, описание
 
                            INT X[3][5];
 
    Здесь X  массив  целых  размера  3*5.   При  появлении  в
выражении X   преобразуется  в  указатель  на  первый из трех
массивов из 5 целых. В выражении X[I], которое эквивалентно *
(X+I), сначала  X преобразуется в указатель так,  как описано
выше; затем I преобразуется к типу X,  что вызывает умножение
I на длину объекта,  на который указывает указатель, а именно
на 5 целых объектов.  Результаты складываются,  и  применение
косвенной адресации дает массив (из 5 целых),  который в свою
очередь преобразуется в указатель на первое  из  этих  целых.
Если в   выражение  входит  и  другой  индекс,  то таже самая
аргументация применяется снова; результатом на этот раз будет
целое.
    Из всего этого следует,  что массивы в языке "C" хранятся
построчно ( последний индекс изменяется быстрее всего)  и что
первый индекс в описании помогает определить общее количество
памяти, требуемое  для хранения массива, но не играет никакой
другой роли в вычислениях, связанных с индексацией.
   
     
                     
     
       22.4. Явные преобразования указателей
    
    Разрешаются определенные преобразования, с использованием
указателей ,   но они имеют некоторые зависящие от конкретной
реализации аспекты. Все эти преобразования задаются с помощью
операции явного преобразования типа; см. П. 15.2 и 16.7.
    Указатель может   быть   преобразован    в    любой    из
целочисленных типов,    достаточно  большой для его хранения.
Требуется ли при этом INT или LONG,   зависит  от  конкретной
машины. Преобразующая          функция     также     является
машинно-зависимой, но  она будет вполне естественной для тех,
кто знает структуру адресации в машине.  Детали для некоторых
конкретных машин приводятся ниже.
    Объект целочисленного  типа  может  быть  явным   образом
преобразован в     указатель.   такое  преобразование  всегда
переводит преобразованное из указателя целое в тот  же  самый
указатель, но в других случаях оно будет машинно-зависимым.
    Указатель на один тип может быть преобразован в указатель
на другой  тип.  Если преобразуемый указатель не указывает на
объекты, которые  подходящим образом выравнены в памяти,   то
результирующий указатель   может  при  использовании вызывать
ошибки адресации.  Гарантируется,  что  указатель  на  объект
заданного размера   может  быть  преобразован  в указатель на
объект меньшего размера и снова обратно,   не  претерпев  при
этом изменения.
    Например, процедура   распределения   памяти   могла   бы
принимать запрос на размер выделяемого объекта в  байтах,   а
возвращать указатель     на   символы;   это  можно  было  бы
использовать следующим образом.
 
                        EXTERN CHAR *ALLOC();
                        DOUBLE *DP;
                        DP=(DOUBLE*) ALLOC(SIZEOF(DOUBLE));
                        *DP=22.0/7.0;
 
    Функция ALLOC  должна   обеспечивать   (машинно-зависимым
способом), что  возвращаемое ею значение будет подходящим для
преобразования в   указатель  на  DOUBLE;  в   таком   случае
использование этой функции будет переносимым.
    Представление указателя    на    PDP-11     соответствует
16-битовому целому  и измеряется в байтах.  Объекты типа CHAR
не имеют никаких ограничений на выравнивание;  все  остальные
объекты должны иметь четные адреса.
    На HONEYWELL  6000  указатель  соответствует  36-битовому
целому; слову    соответствует   18   левых   битов   и   два
непосредственно примыкающих   к  ним  справа  бита,   которые
выделяют символ в слове.  Таким образом, указатели на символы
измеряются в   единицах  2 в степени 16 байтов; все остальное
измеряется в единицах 2 в степени 18 машинных слов.  Величины
типа DOUBLE  и содержащие их агрегаты должны выравниваться по
четным адресам слов (0 по модулю 2 в степени 19). Эвм IBM 370
и INTERDATA 8/32 сходны между собой.  На обеих машинах адреса
измеряются в   байтах;  элементарные  объекты   должны   быть
выровнены по границе,  равной их длине,  так что указатели на
SHORT должны быть кратны двум,  на INT и FLOAT - четырем и на
DOUBLE -   восьми.   Агрегаты  выравниваются по самой строгой
границе, требуемой каким-либо из их элементов.
 
     
     
     
     
                                                                                                                                                                                                                    
     
               23. Константные выражения
    
    В нескольких местах  в  языке  "C"  требуются  выражения,
которые после    вычисления  становятся  константами:   после
вариантного префикса CASE,  в качестве границ  массивов  и  в
инициализаторах. В    первых  двух  случаях  выражение  может
содержать только целые  константы,   символьные  константы  и
выражения SIZEOF,      возможно   связанные   либо  бинарными
операциями
 
               + - * / . % & \! Ч << >> == 1= <> <= >=
 
либо унарными операциями
 
                                - \^
 
либо тернарной операцией ?:
 
    Круглые скобки могут использоваться для группировки,   но
не для обращения к функциям.
    В случае инициализаторов допускается большая (ударение на
букву о)    свобода;  кроме  перечисленных  выше  константных
выражений можно также применять унарную операцию & к  внешним
или статическим     объектам  и  к  внешним  или  статическим
массивам, имеющим  в качестве индексов константное выражение.
Унарная операция   &  может  быть  также применена неявно,  в
результате появления неиндексированных  массивов  и  функций.
Основное правило   заключается  в  том,  что после вычисления
инициализатор должен становится либо константой, либо адресом
ранее описанного   внешнего или статического объекта плюс или
минус константа.
  
     
     
     
     
                                                                                                                                                        
     
           24. Соображения о переносимости
    
    Некоторые части языка "C" по своей сути машинно-зависимы.
Следующие ниже   перечисление потенциальных трудностей хотя и
не являются всеобъемлющими, но выделяет основные из них.
    Как показала  практика,   вопросы,   целиком  связанные с
аппаратным оборудованием,  такие как размер слова,   свойства
плавающей арифметики   и  целого  деления,   не  представляют
особенных затруднений.   Другие  аспекты  аппаратных  средств
находят свое отражение в различных реализациях.  Некоторые из
них, в    частности,   знаковое   расширение   (преобразующее
отрицательный символ   в  отрицательное целое)  и порядок,  в
котором помещаются   байты  в  слове,    представляют   собой
неприятность, которая      должна   тщательно  отслеживаться.
Большинство из  остальных  проблем  этого  типа  не  вызывает
сколько-нибудь значительных затруднений.
    Число переменных типа REGISTER,  которое фактически может
быть помещено в регистры,  меняется от машины к машине, также
как и набор допустимых для  них  типов.   Тем  не  менее  все
компиляторы на   своих  машинах  работают надлежащим образом;
лишние или недопустимые регистровые описания игнорируются.
    Некоторые трудности  возникают  только  при использовании
сомнительной практики  программирования.   Писать  программы,
которые зависят   от  каких-  либо  этих  свойств,   является
чрезвычайно неразумным.
    Языком не  указывается  порядок   вычисления   аргументов
функций; они   вычисляются справа налево на PDP-11 и VAX-11 и
слева направо на  остальных  машинах.   порядок,   в  котором
происходят побочные эффекты, также не специфицируется.
    Так как символьные константы в действительности  являются
объектами типа   INT,   допускается  использование символьных
констант, состоящих из нескольких символов. Однако, поскольку
порядок, в котором символы приписываются к слову, меняется от
машины к машине,  конкретная  реализация  оказывается  весьма
машинно-зависимой.
    Присваивание полей   к   словам   и   символов   к  целым
осуществляется справо налево  на  PDP-11  и  VAX-11  и  слева
направо на   других  машинах.   эти  различия  незаметны  для
изолированных программ, в которых не разрешено смешивать типы
(преобразуя, например, указатель на INT в указатель на CHAR и
затем проверяя указываемую память), но должны учитываться при
согласовании с накладываемыми извне схемами памяти.
    Язык, принятый  на  различных  компиляторах,   отличается
только незначительными   деталями.   Самое  заметное  отличие
состоит в том,  что используемый в настоящее время компилятор
на PDP-11 не инициализирует структуры,  которые содержат поля
битов, и    не  допускает  некоторые  операции присваивания в
определенных контекстах,  связанных с использованием значения
присваивания.

     
     
     
     
     
ассив", последнее имеет тип INT.

     
     
     
     
     
     
                                                                                                                
     
                          25. Анахронизмы
    
    Так как язык "C" является развивающимся языком,  в старых
программах можно  встретить некоторые устаревшие конструкции.
Хотя большинство   версий  компилятора   поддерживает   такие
анахронизмы, они   в конце концов исчезнут,  оставив за собой
только проблемы переносимости.
    В ранних    версиях    "C"   для   проблем   присваивания
использовалась форма     =ON,    а   не   ON=,    приводя   к
двусмысленностям, типичным примером которых является
     
                               X = -1
 
где X фактически  уменьшается,   поскольку  операции  =  и  -
примыкают друг к другу, но что вполне могло рассматриваться и
как присваивание -1 к X.
    Синтаксис инициализаторов    изменился:     раньше   знак
равенства, с которого начинается инициализатор, отсутствовал,
так что вместо
 
                             INT X = 1;
 
использовалось
 
                              INT X 1;
 
изменение было внесено из-за инициализации
 
                             INT F (1+2)
 
которая достаточно  сильно  напоминает  определение  функции,
чтобы смутить компиляторы.
     
     
     
     
переменная   DISTANCE   считается
имеющей точно   такой  же  тип,   что  и любой другой о     
     
                  26. Сводка синтаксических правил
    
    Эта сводка  синтаксиса языка "C" предназначена скорее для
облегчения понимания   и  не  является  точной  формулировкой
языка.

 
                          26.1. Выражения
    
    Основными выражениями являются следующие:
 
    выражение:
                      первичное-выражение
                    * выражение
                    & выражение
                    - выражение
                    ! Выражение
                   \^ выражение
                   ++ L-значение
                   -- L-значение
                    L-значение ++
                    L-значение --
                    SIZEOF выражение
                    (имя типа) выражение
                    выражение бинарная-операция выражение
                    выражение ? Выражение : выражение
                 L-значение операция-присваивания выражение
                    выражение , выражение
                     первичное выражение:
                    идентификатор
                    константа
                    строка
                    (выражение)
                    первичное-выражение (список выражений
                            необ)
                    первичное-выражение [выражение]
                    L-значение . Идентификатор
                    первичное выражение -> идентификатор
                     L-значение:
                    идентификатор
                    первичное-выражение [выражение]
                    L-значение . Идентификатор
                    первичное-выражение -> идентификатор
                    * выражение
                    (L-значение)
 
    Операции первичных выражений
 
                            () []  .  ->
 
имеют самый  высокий  приоритет и группируются слева направо.
Унарные операции
     
              *  &  -  !  \^  ++  --  SIZEOF(Имя типа)
 
имеют более  низкий  приоритет,    чем   операции   первичных
выражений, но    более высокий,  чем приоритет любой бинарной
операции. Эти   операции  группируются  справа  налево.   Все
бинарные операции   и  условная  операция  (прим.   Перевод.:
условная операция группируется справа налево;  это  изменение
внесено в   язык  в 1978 г.)  группируются слева направо и их
приоритет убывает в следующем порядке:
    Бинарные операции:
                          *   /   %
                          +   -
                          >>  <<
                          <   >  <=   >=
                          ==  !=
                          &
                          \^
                          \!
                          &&
                        \!\!
                          ?:
 
    Все операции  присваивания  имеют  одинаковый приоритет и
группируются справа налево.
    Операции присваивания:
            =  +=  -=  *=  ?=  %=  >>=  <<=  &=  \^=  \!=
 
    Операция запятая   имеет   самый   низкий   приоритет   и
группируется слева направо.

 
     
                   26.2. Описания
    
    Описание:
  спецификаторы-описания список-инициализируемых-описателей
              необ;
  ---------------------------------------------------------
      
      спецификаторы-описания:
      
        спецификатор-типа спецификаторы-описания
             необ
        спецификатор-класса-памяти спецификаторы-описания
             необ
      спецификатор-класса-памяти:
       AUTO
       STATIC
       EXTERN
       REGISTER
       TYPEDEF
      спецификатор-типа:
        CHAR
        SHORT
        INT
        LONG
        UNSIGNED
        FLOAT
        DOUBLE
         спецификатор-структуры-или-объединения
         определяющее-тип-имя
      список-инициализируемых-описателей:
         инициализируемый-описатель
         инициализируемый-описатель,
         список-инициализируемых-описателей
      инициализируемый-описатель
        описатель-инициализатор
          необ
      описатель:
         идентификатор
         (описатель)
         * описатель
         описатель ()
         описатель [константное выражение
               необ]
      спецификатор-структуры-или-объединения:
         STRUCT список-описателей-структуры
         STRUCT идентификатор \(список-описаний-структуры\)
         STRUCT идентификатор
         UNION \(список-описаний-структуры\)
         UNION идентификатор \(список-описаний-структуры\)
         UNION идентификатор
      список-описаний-структцры:
         описание-структуры
         описание-структуры список-описаний-структуры
      описание структуры:
         спецификатор-типа список-описателей-структуры:
      список-описателей-структуры
         описатель-структуры
         описатель-структуры,список-описателей-структуры
      описатель-структуры:
         описатель
         описатель: константное выражение
         :константное-выражение
      инициализатор:
         = выражение
         = \(список-инициализатора\)
         = \(список-инициализатора\)
      список инициализатора:
         выражение
         список-инициализатора,список-инициализатора
         \(список-инициализатора\)
      имя-типа:
         спецификатор-типа абстрактный-описатель
      абстрактный-описатель:
         пусто
         \(абстрактный-описатель\)
         * абстрактный-описатель
         абстрактный-описатель ()
         абстрактный-описатель [константное-выражение
                  необ]
      определяющее-тип-имя:
        идентификатор
                            
 
                          26.3. Операторы
    
    составной-оператор:
               \(список-описаний      список-операторов
                     необ      необ\)
             список-описаний:
               описание
               описание список-описаний
             список-операторов:
               оператор
               оператор список-операторов
             оператор:
               составной оператор
               выражение;
               IF (выражение) оператор
               IF (выражение) оператор ELSE оператор
               WHILE (выражение) оператор
               DO оператор WHILE (выражение);
               FOR(выражение-1 ;выражение-2 ;выражение-3  )
                   необ      необ   необ
              оператор
               SWITCH (выражение) оператор
               CASE константное-выражение : оператор
               DEFAULT: оператор
               BREAK;
               CONTINUE;
               RETURN;
               RETURN выражение;
               GOTO идентификатор;
               идентификатор : оператор
               ;
    
                      26.4. Внешние определения
    
    Программа:
                  внешнее-определение
                  внешнее-определение программа
                внешнее-определение:
                  определение-функции
                  определение-данных
                определение-функции:
     спецификатор-типа     описатель-функции тело-функции
                        необ
                описатель-функции:
                  описатель (список-параметров    )
                    необ
                список-параметров:
                   идетификатор
                   идентификатор , список-параметров
                тело-функции:
                   список-описаний-типа оператор-функции
                оператор-функции:
                   \(список описаний   список-операторов\)
                         необ
                определение данных:
                   EXTERN  спецификатор типа    список
                   необ   необ
                  инициализируемых описателей    ;
                     необ
                   STATIC  спецификатор типа     список
                   необ   необ
                  инициализируемых описателей
                     необ;
    
                         26.5. Препроцессор
    
             #DEFINE идентификатор строка-лексем
             #DEFINE
             #DEFINE идентификатор(идентификатор,
                                     ...,идентификатор)стр
             #UNDEF идентификатор
             #INCLUDE "имя-файла"
             #INCLUDE <имя-файла>
             #IF константное-выражение
             #IFDEF идентификатор
             #IFNDEF идентификатор
             #ELSE
             #ENDIF
             #LINE константа идентификатор
     
ограммы.

              

       Последние изменения языка "C" (15 ноября 1978 г.)
 
                     27. Присваивание структуры
    
    Структуры могут  быть  присвоены,   переданы  функциям  в
качестве аргументов  и возвращены функциям.  Типы участвующих
операндов должны   оставаться   теми   же   самыми.    Другие
правдоподобные операторы,   такие как сравнение на равенство,
не были реализованы.
    В реализации  возвращения  структур  функциями  на PDP-11
имеется коварный дефект:  если во время  возврата  происходит
прерывание и та же самая функция пеентерабельно вызывается во
время этого прерывания,  то значение возвращаемое из  первого
вызова, может  быть испорчено. Эта трудность может возникнуть
только при наличии истинного прерывания,  как из операционной
системы, так и из программы пользователя, прерывания, которое
существенно для использования сигналов;  обычные  рекурсивные
вызовы совершенно безопасны.

     
     
     
     
     
     
     
                                          
     
                        28. Тип перечисления
    
    Введен новый тип данных,аналогичный скалярным типам языка
паскаль. К спецификатору-типа в его синтаксическом описании в
разделе 8.2. Приложения а следует добавить
 
    спецификатор-перечисления
    -------------------------
    
        с синтаксисом
 
    спецификатор-перечисления:
    --------------------------
                ENUM список-перечисления
                     -------------------
                ENUM идентификатор  список-перечисления
                     -------------  -------------------
                ENUM идентификатор
                     -------------
 
    cписок-перечисления:
    -------------------
                перечисляемое
                -------------
                список-перечисления, перечисляемое
                -------------------  -------------
                перечисляемое:
                --------------
                  идентификатор
                 -------------
                 идентификатор = константное выражение
                 -------------   ---------------------
 
    Роль идентификатора     в      спецификаторе-перечисления
полностью аналогична         роли    ярлыка    структуры    в
спецификаторе-структуры; идентификатор             обозначает
определенное перечисление. Например, описание
 
              ENUM COLOR \(RED, WHITE, BLACK, BLUE \);
              . . .
              ENUM COLOR *CP, COL;
 
 
    Объявляет идентификатор  COLOR ярлыком перечисления типа,
описывающего различные цвета и затем объявляет CP  указателем
на объект этого типа, а COL - объектом этого типа.
    Идентификаторы в  списке-перечисления   описываются   как
константы и могут появиться там, где требуются (по контексту)
константы. Если  не используется вторая форма  перечисляемого
(с равеством   =),   то  величины  констант  начинаются с 0 и
возрастают на 1 в соответствии с прочтением их описания слева
на право.       Перечисляемое   с   присвоением   =   придает
соответствующему идентификатору       указанную     величину;
последующие идентификаторы       продолжают   прогрессию   от
приписанной величины.
    Все ярлыки перечисления и константы могут быть различными
и непохожими на ярлыки и  члены  структур  даже  при  условии
использования одного и того же множества идентификаторов.
    Объекты данного  типа  перечисления  рассматриваются  как
объекты, имеющие      тип,    отличный   от   любых  типов  и
контролирующая программа     LINT   сообщает    об    ошибках
несоответствия типов.    В  реализации  на  PDP-11  со  всеми
перечисляемыми переменными оперируют так,  как  если  бы  они
имели тип INT.

     
     
     
     
     
     
     
     
 Управляющая строка вида
 
                      
     
     29. Таблица изображений непечатных символов языка "C".
    
    В данной таблице приведены изображения некоторых символов
(фигурные скобки   и  т.д.)   языка  "C",   которых  может не
оказаться в   знаковом   наборе   дисплея   или   печатающего
устройства.
          -------------------------------------------------
          !    Значение          !   Изображение   **     !
          !                      !    В тексте            !
          -------------------------------------------------
          !  Фигурная открывающаяся  !                    !
          !    Скобка                !        \(          !
          !                          !                    !
          -------------------------------------------------
          !  Фигурная закрывающаяся  !                    !
          !    Скобка                !        \)          !
          !                          !                    !
          -------------------------------------------------
          ! Вертикальная             !                    !
          !    Черта                 !        \!          !
          !                          !                    !
          -------------------------------------------------
          !                          !                    !
          !   Апостороф              !        \'          !
          !                          !                    !
          -------------------------------------------------
          !    Волнистая             !                    !
          !      Черта               !        \^          !
          !                          !                    !
          -------------------------------------------------
           
           ** П_р_и_м_е_ч_а_н_и_е:
    
    Изображения приведены для операционой системы UNIX.   При
работе компилятора     "C"   под   управлением  любой  другой
операционной системы,          необходимо     воспользоваться
соответствующим руководством для данной системы.

     
     
     
     
